<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RxJS on Frontend Learning</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/</link><description>Recent content in RxJS on Frontend Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://shipengqi.github.io/frontend-learn/docs/rxjs/index.xml" rel="self" type="application/rss+xml"/><item><title>概念</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/01_overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/01_overview/</guid><description>概念 # RxJS：Think of RxJS as Lodash for events。也就是说，RxJS 是一个类似 lodash 的工具库，不过处理的对象是 Events。这里的 Events，可以称之为流。
什么是流？例如，代码中每秒会输出一个数据，或者用户每一次对元素的点击，就像是在时间这个维度上，产生了一个数据集。这个数据集不像数组那样，它不是一开始都存在的，而是随着时间的流逝，一个一个数据被输出出来。这种异步行为产生的数据，就可以被称之为一个流，在 Rxjs 中，称之为 Observalbe（本质其实就是一个数据集合，只是这些数据不一定是一开始就设定好的，而是随着时间而不断产生的）。而 Rxjs，就是为了处理这种流而产生的工具，比如流与流的合并，流的截断，延迟，消抖等等操作。
import {interval, map} from &amp;#39;rxjs&amp;#39;; const sub = interval(1000).pipe( map(second =&amp;gt; second + &amp;#39;s&amp;#39;) ).subscribe(res =&amp;gt; { console.log(res); }); // Output: // 0s // 2s // 3s // 4s // 5s // ... 利用 interval 返回一个 Observable 流，每 1 秒产生一个数据，然后交给 map 操作符将内容进行转换，最后交过观察者打印结果。
Observable 的核心 # 创建 # import { Observable } from &amp;#39;rxjs&amp;#39;; const observable = new Observable(function subscribe(subscriber) { const timer = setInterval(() =&amp;gt; { // 可以多次调用 next 方法向外发送数据 subscriber.</description></item><item><title>操作符</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/02_operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/02_operators/</guid><description>概述 # 操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。并且前面的 Observable 保持不变。
操作符有两类：
Pipeable 操作符：是指可以使用 observable.pipe(operator) 或更常用的 observable.pipe(operatorFactory()) 语法将操作符管道化的操作符。操作符工厂函数包括 filter(...) 和 mergeMap(...) 等。 创建操作符可以作为独立函数调用，可以创建一个新的 Observable。例如：of(1, 2, 3)。 创建操作符 # range # range(start, length)，调用方法后返回 Observable 对象，被订阅后会发出指定范围的数值。
import { range } from &amp;#34;rxjs&amp;#34; range(0, 5).subscribe(n =&amp;gt; console.log(n)) // Output: // 0 // 1 // 2 // 3 // 4 of # 将参数列表作为数据流返回。
of(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, [], {}, true, 20).subscribe(v =&amp;gt; console.log(v)) // Output: // a // b // [] // {｝ // true // 20 from, fromEvent, fromPromise # // 将数组转为 Observable from([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;]).</description></item><item><title>Subject</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/03_subject/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/03_subject/</guid><description>概述 # RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，这意味着 Subject 确保每个观察者之间共享 Observable 的值。
而普通的 Observable 是单播的，它会为每一个观察者创建一次新的、独立的执行。当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。
在 RxJS 中有四种 Subject 分别是：Subject，BehaviorSubject，AsyncSubject，ReplaySubject；这四种 Subject 都是特殊的 Observable。
Subject 既是 Observable 也是 Observer。
Subject # Subject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，它会把订阅者添加到观察者列表中，每当有接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next 方法，把值一一送出。
import { Subject } from &amp;#39;rxjs&amp;#39;; const subject$ = new Subject&amp;lt;number&amp;gt;(); subject$.next(1); subject$.subscribe({ next: (v) =&amp;gt; console.log(`observerA: ${v}`), }); subject$.next(2); subject$.subscribe({ next: (v) =&amp;gt; console.log(`observerB: ${v}`), }); subject$.next(3); // Output: // observerA: 2 // observerA: 3 // observerB: 3 创建了一个 Subject 发出了一个值 1，但由于此时并没有订阅者，所以这个值不会被订阅到 创建了 observerA 又发出一个值 2，这时候 observerA 会接收到这个值 又创建一个 observerB 最后发出一个值 3，这时候已经订阅的都会接收到这个值 BehaviorSubject # BehaviorSubject，它有一个当前值的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到最后发出的值。</description></item><item><title>实践</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/04_practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/04_practice/</guid><description>优雅的资源释放 # 对于无限值必须要取消订阅，反之可以不需要。例如监听 DOM 元素的事件：
Observable.fromEvent(node, &amp;#39;input&amp;#39;) .subscribe(value =&amp;gt; { console.log(value); }); 因为如果不取消订阅，事件所关联的方法会一直被占用，导致内存泄露。
传统方式 # @Component({ selector: &amp;#39;app-demo&amp;#39;, template: ` &amp;lt;div&amp;gt;Hello, world!&amp;lt;/div&amp;gt; ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = new Subject&amp;lt;void&amp;gt;(); private timer; constructor() { this.timer = interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } 上面的在组件中定义了一个私有变量 _destroy$，是一个 Subject 对象，用于在组件销毁时发出信号以释放资源。通过 takeUntil(this._destroy$) 操作符来限制 Observable 的生命周期，在 _destroy$ 发出信号时停止发出值。
这种方式虽然使用了 takeUntil 来限制 Observable 的生命周期，但是仍然需要在 ngOnDestroy 钩子中手动调用 _destroy$.next() 和 _destroy$.</description></item></channel></rss>