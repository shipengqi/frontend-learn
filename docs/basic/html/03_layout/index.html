<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="布局 # 浮动布局 # 浮动布局的好处：
可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。
元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。
例如下面的 html，三个 <div class=&#34;child&#34;></div> 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。
<div class=&#34;parent&#34;> <div class=&#34;child&#34;></div> <div class=&#34;child&#34;></div> <div class=&#34;child&#34;></div> </div> 如果不想有空格，可以像下面这样，把换行和空格去掉：
<div class=&#34;parent&#34;> <div class=&#34;child&#34;></div><div class=&#34;child&#34;></div><div class=&#34;child&#34;></div> </div> 上面的方式，不好看，可以使用浮动解决：
.child { float: left } 第一个子元素 <div class=&#34;child&#34;></div> 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。
清除浮动 # 浮动会导致父元素的高度塌陷。
比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。
因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。
解决方式：
设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：
.parent { } .parent:after{ content: &#34;&#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="布局"><meta property="og:description" content="布局 # 浮动布局 # 浮动布局的好处：
可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。
元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。
例如下面的 html，三个 <div class=&#34;child&#34;></div> 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。
<div class=&#34;parent&#34;> <div class=&#34;child&#34;></div> <div class=&#34;child&#34;></div> <div class=&#34;child&#34;></div> </div> 如果不想有空格，可以像下面这样，把换行和空格去掉：
<div class=&#34;parent&#34;> <div class=&#34;child&#34;></div><div class=&#34;child&#34;></div><div class=&#34;child&#34;></div> </div> 上面的方式，不好看，可以使用浮动解决：
.child { float: left } 第一个子元素 <div class=&#34;child&#34;></div> 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。
清除浮动 # 浮动会导致父元素的高度塌陷。
比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。
因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。
解决方式：
设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：
.parent { } .parent:after{ content: &#34;&#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。"><meta property="og:type" content="article"><meta property="og:url" content="http://shipengqi.github.io/frontend-learn/docs/basic/html/03_layout/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-08-15T13:03:41+08:00"><title>布局 | Frontend Learning</title><link rel=manifest href=/frontend-learn/manifest.json><link rel=icon href=/frontend-learn/favicon.png type=image/x-icon><link rel=stylesheet href=/frontend-learn/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/frontend-learn/flexsearch.min.js></script>
<script defer src=/frontend-learn/en.search.min.3e5757fbbac27fb242bd171ebb36e3b23fd04b1ea7341c1e44f18c96eeb32f44.js integrity="sha256-PldX+7rCf7JCvRceuzbjsj/QSx6nNBweRPGMlu6zL0Q=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/frontend-learn/><span>Frontend Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/frontend-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>前端基础</span><ul><li><a href=/frontend-learn/docs/basic/html/>HTML 和 CSS</a><ul><li><a href=/frontend-learn/docs/basic/html/01_tags/>HTML 标签</a></li><li><a href=/frontend-learn/docs/basic/html/02_css/>CSS 属性</a></li><li><a href=/frontend-learn/docs/basic/html/03_layout/ class=active>布局</a></li><li><a href=/frontend-learn/docs/basic/html/04_responsive/>响应式</a></li><li><a href=/frontend-learn/docs/basic/html/05_other/>其他</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/frontend-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>布局</strong>
<label for=toc-control><img src=/frontend-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#布局>布局</a><ul><li><a href=#浮动布局>浮动布局</a><ul><li><a href=#清除浮动>清除浮动</a></li></ul></li><li><a href=#弹性布局>弹性布局</a><ul><li><a href=#弹性主轴和侧轴>弹性主轴和侧轴</a></li><li><a href=#弹性子元素的排序>弹性子元素的排序</a></li><li><a href=#弹性子元素剩余空间配置>弹性子元素剩余空间配置</a></li></ul></li><li><a href=#定位>定位</a><ul><li><a href=#相对定位>相对定位</a></li><li><a href=#绝对定位>绝对定位</a></li><li><a href=#固定定位>固定定位</a></li><li><a href=#粘性定位>粘性定位</a></li></ul></li><li><a href=#层>层</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=布局>布局
<a class=anchor href=#%e5%b8%83%e5%b1%80>#</a></h1><h2 id=浮动布局>浮动布局
<a class=anchor href=#%e6%b5%ae%e5%8a%a8%e5%b8%83%e5%b1%80>#</a></h2><p>浮动布局的好处：</p><ol><li>可以让元素向左或者向右靠拢</li><li>可以解决一些边距问题</li><li>可以实现文字包围图片的样式</li></ol><blockquote><p><code>float: left/right;</code> 会让元素<strong>脱离文档流</strong>。</p></blockquote><p><strong>元素之间的多个空白，会合并成一个空格</strong>。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。
并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。</p><p>例如下面的 html，三个 <code>&lt;div class="child">&lt;/div></code> 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距，
其实就是一个空格。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;parent&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt; 
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>如果不想有空格，可以像下面这样，把换行和空格去掉：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;parent&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>上面的方式，不好看，可以使用浮动解决：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>child</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>float</span>: <span style=color:#66d9ef>left</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一个子元素 <code>&lt;div class="child">&lt;/div></code> 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。</p><h3 id=清除浮动>清除浮动
<a class=anchor href=#%e6%b8%85%e9%99%a4%e6%b5%ae%e5%8a%a8>#</a></h3><p>浮动会导致父元素的高度塌陷。</p><p>比如 <code>div</code> 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。</p><p><strong>因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了</strong>。</p><p>解决方式：</p><ol><li>设置父元素的高度（前提是父元素的高度是已知的）。</li><li>父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。<ul><li>在父元素最后添加一个子元素 <code>div</code>，并给子元素添加属性 <code>clear: both;</code>，缺点是会多一个空的 <code>div</code>。</li></ul></li><li>终极方案：原理与上个方法一样，通过伪元素来清除浮动。</li></ol><p>伪元素来清除浮动：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span>.<span style=color:#a6e22e>parent</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>parent</span>:<span style=color:#a6e22e>after</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>content</span>: <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>block</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>clear</span>: <span style=color:#66d9ef>both</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的示例中给父元素的类 <code>parant</code> 添加了一个 <code>:after</code> 伪元素。</p><h2 id=弹性布局>弹性布局
<a class=anchor href=#%e5%bc%b9%e6%80%a7%e5%b8%83%e5%b1%80>#</a></h2><p>弹性布局可以更方便的布局，但是对浏览器要求较高。</p><p>概念：</p><ol><li><strong>弹性容器</strong>：设置了 <code>display: flex;</code> 的元素即为弹性容器。</li><li><strong>弹性子元素</strong>：弹性容器里的<strong>直接子元素</strong>。</li></ol><p><code>display: flex</code>：如果一个元素的设置了这个属性（弹性容器），那么他的<strong>直接子元素</strong>（孙子元素就不是弹性布局），就会按着弹性布局的方式来布局。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>parent</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>flex</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>600</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>600</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>child</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>200</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>200</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;parent&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>body</span>&gt;
</span></span></code></pre></div><p>如果 <code>parent</code> 不是弹性布局，那么三个 <code>child</code> 都是块元素，每个元素会占据一整行。但是 <code>parent</code> 添加了 <code>display: flex;</code> 属性以后，三个子元素会在一行并排显示，不会有间距。</p><blockquote><p>直接子元素是弹性布局，但是<code>parent</code> 元素本身还是块级布局。</p></blockquote><h3 id=弹性主轴和侧轴>弹性主轴和侧轴
<a class=anchor href=#%e5%bc%b9%e6%80%a7%e4%b8%bb%e8%bd%b4%e5%92%8c%e4%be%a7%e8%bd%b4>#</a></h3><p>弹性布局有一个主轴和一个侧轴：</p><ul><li><strong>主轴</strong>：默认是<strong>水平向右</strong>，可以修改为<strong>水平向左</strong>或<strong>竖直向上</strong>，<strong>竖直向下</strong>。</li><li><strong>侧轴</strong>：默认是<strong>竖直向下</strong>，可以修改为<strong>竖直向上</strong>或<strong>水平向左</strong>，<strong>水平向右</strong>，</li></ul><p><strong>弹性布局的子元素默认是在主轴上一行或者一竖，不会换行</strong>，默认情况下（<code>flex-wrap: nowrap</code>）如果一行子元素的<strong>宽度或者高度超过了父元素，所有的子元素就会等比例缩小</strong>。</p><p>设置主轴的方向：</p><ul><li><code>flex-derection: row</code>：默认是 <code>row</code>。<ul><li><code>row</code> 水平向右。</li><li><code>row-reverse</code> 水平向左。</li><li><code>column</code> 竖直向下。</li><li><code>column-reverse</code> 竖直向上。</li></ul></li></ul><p>设置主轴的排布：</p><ul><li><code>justify-content: flex-start</code>：默认是 <code>flex-start</code>。<ul><li><code>flex-start</code> 靠近主轴的起点。</li><li><code>flex-end</code> 靠近主轴的终点。</li><li><code>center</code> 主轴居中。</li><li><code>space-between</code> 平均分布，和主轴的起点和终点没有间距。</li><li><code>space-around</code> 平均分布，和主轴的起点和终点有间距，两边的间距是中间的一半。</li><li><code>space-evenly</code> 平均分布，间距一致。</li></ul></li></ul><p>弹性布局，设置水平居中只需要 <code>justify-content:center</code> 就可以实现，如果不是弹性布局，可以用下面的方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>display</span><span style=color:#f92672>:</span> <span style=color:#f92672>block</span><span style=color:#f92672>;</span> <span style=color:#75715e>/* 设置为块级元素 */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>margin</span><span style=color:#f92672>:</span> <span style=color:#f92672>0</span> <span style=color:#f92672>auto</span><span style=color:#f92672>;</span> <span style=color:#75715e>/* auto 设置水平居中，必须是块元素 */</span>
</span></span></code></pre></div><p>设置侧轴的排布：</p><ul><li><code>align-items: stretch</code>：默认是 <code>stretch</code>。<ul><li><code>stretch</code> 拉伸，如果子元素没有设置高度或宽度，那么子元素会被拉伸到和父元素一样的高度或宽度。</li><li><code>flex-start</code> 靠近侧轴的起点。</li><li><code>flex-end</code> 靠近侧轴的终点。</li><li><code>center</code> 侧轴居中。<strong>单行的侧轴没有平均分布</strong>。</li></ul></li></ul><p>换行：</p><ul><li><code>flex-wrap: nowrap</code>：默认是 <code>nowrap</code>。<ul><li><code>nowrap</code> 不换行。</li><li><code>wrap</code> 换行，如果侧轴排布是 <code>stretch</code>，换行以后是两行，那么两行会被拉伸，各占一半。</li></ul></li></ul><p>多行存在的时候，侧轴分布：</p><ul><li><code>align-content: flex-start</code>：<ul><li><code>flex-start</code> 多行都向侧轴的起点靠拢。</li><li><code>flex-end</code> 多行都向侧轴的终点靠拢。</li><li><code>center</code> 多行居中。</li><li><code>space-around</code> 平均分布，和侧轴的起点和终点有间距，两边的间距是中间的一半。</li><li><code>space-between</code> 平均分布，和侧轴的起点和终点没有间距。</li><li><code>space-evenly</code> 平均分布，间距一致。</li></ul></li></ul><p>弹性子元素会存在多个，如果要单独设置一个子元素侧轴的分布，可以给<strong>弹性子元素添加属性</strong>：</p><ul><li><code>align-self: flex-start</code>：<ul><li><code>flex-start</code> 靠近侧轴的起点。</li><li><code>flex-end</code> 靠近侧轴的终点。</li><li><code>center</code> 侧轴居中。</li></ul></li></ul><p><strong>主轴是不能单独设置一个子元素的分布的</strong>。</p><h3 id=弹性子元素的排序>弹性子元素的排序
<a class=anchor href=#%e5%bc%b9%e6%80%a7%e5%ad%90%e5%85%83%e7%b4%a0%e7%9a%84%e6%8e%92%e5%ba%8f>#</a></h3><p>如果要设置弹性子元素的排序，可以给每个子元素添加属性：</p><ul><li><code>order: {num}</code> 子元素会沿主轴方向从小到大排序。</li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>parent</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>flex</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>600</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>600</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>child</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>200</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>200</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>c1</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>order</span>: <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>skyblue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>c2</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>order</span>: <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>c3</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>order</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellow</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;parent&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child c1&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child c2&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child c3&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>body</span>&gt;
</span></span></code></pre></div><h3 id=弹性子元素剩余空间配置>弹性子元素剩余空间配置
<a class=anchor href=#%e5%bc%b9%e6%80%a7%e5%ad%90%e5%85%83%e7%b4%a0%e5%89%a9%e4%bd%99%e7%a9%ba%e9%97%b4%e9%85%8d%e7%bd%ae>#</a></h3><p>给子元素添加属性 <code>flex: {num}</code>，占据剩余份额的份数。<code>flex: 1</code> 就表示占据剩余空间的 1 份。</p><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>parent</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>flex</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>600</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>600</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>gray</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>child</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 剩余空间被分为 3 份，c1 占 1/3，c2 占 2/3 */</span>
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>c1</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>flex</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>skyblue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>c2</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>flex</span>: <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>green</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .<span style=color:#a6e22e>c3</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>order</span>: <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>yellow</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;parent&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child c1&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child c2&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;child c3&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>body</span>&gt;
</span></span></code></pre></div><p>上面的示例，每个子元素的宽度为 <code>100px</code>，那么剩余空间就是 <code>300px</code>。<code>c1</code> 会占据剩余空间的 <code>100px</code>，<code>c2</code> 占 <code>200px</code>。</p><h2 id=定位>定位
<a class=anchor href=#%e5%ae%9a%e4%bd%8d>#</a></h2><p>定位：可以设置元素具体在某个位置上。元素默认就是 <code>static</code>，也就是没有定位。</p><p><code>relative</code>、<code>absolute</code>、<code>fixed</code> 这三个属性值有一个共同点，都是相对于某个基点的定位，只是基点不同。</p><h3 id=相对定位>相对定位
<a class=anchor href=#%e7%9b%b8%e5%af%b9%e5%ae%9a%e4%bd%8d>#</a></h3><p><code>position: relative</code>：相对于默认位置（即 <code>static</code> 时的位置）的定位，虽然形状移动了，但是原来的位置依然占据着。必须配合 <code>left/right/top/bottom</code> 属性使用，用来指定偏移的方向和距离。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>position</span>: <span style=color:#66d9ef>relative</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>top</span>: <span style=color:#ae81ff>20</span><span style=color:#66d9ef>px</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的示例，<code>div</code> 元素从默认位置向下偏移 <code>20px</code>（即距离顶部 <code>20px</code>）。</p><h3 id=绝对定位>绝对定位
<a class=anchor href=#%e7%bb%9d%e5%af%b9%e5%ae%9a%e4%bd%8d>#</a></h3><p><code>position: absolute</code>：相对于最接进自身并且已定位的父元素或者祖先元素（不是 <code>static</code> 的元素）。必须配合 <code>left/right/top/bottom</code> 属性使用。</p><p><strong>设置了绝对定位的元素，会脱离文档流</strong>，不会占据空间。正常的元素会顶上去。</p><h3 id=固定定位>固定定位
<a class=anchor href=#%e5%9b%ba%e5%ae%9a%e5%ae%9a%e4%bd%8d>#</a></h3><p><code>position: fixed</code>：固定在浏览器窗口中的某个位置，相对于浏览器窗口定位。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。配合 <code>left/right/top/bottom</code> 属性使用。</p><h3 id=粘性定位>粘性定位
<a class=anchor href=#%e7%b2%98%e6%80%a7%e5%ae%9a%e4%bd%8d>#</a></h3><p><code>sticky</code> 会产生动态效果，很像 <code>relative</code> 和 <code>fixed</code> 的结合。比如，网页的搜索工具栏，初始加载时，在自己的默认位置（<code>relative</code> 定位），页面向下滚动时，工具栏可以在距离浏览器相对应的位置固定住，始终停留在页面头部（<code>fixed</code> 定位）。等到页面重新向上滚动回到原位，工具栏也会回到默认位置。必须配合 <code>left/right/top/bottom</code> 属性使用。</p><p>当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 <code>sticky</code> 元素的距离达到生效门槛，<code>relative</code> 定位自动切换为 <code>fixed</code> 定位；等到父元素完全脱离视口时（即完全不可见），<code>fixed</code> 定位自动切换回 <code>relative</code> 定位。</p><h2 id=层>层
<a class=anchor href=#%e5%b1%82>#</a></h2><p><code>z-index: {num}</code> 设置层级：</p><ul><li>同一个父元素下，数值越大，越上层。</li><li>不同的父元素下的子元素，就向上追溯到同一父元素下比较，谁的父元素的层级大，谁就在上层。子元素的 <code>z-index</code> 就没用了。</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/frontend-learn/commit/577841d0764d8e9b413a1885e4b810ab0674ec6f title='Last modified by shipengqi | August 15, 2024' target=_blank rel=noopener><img src=/frontend-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 15, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/frontend-learn/edit/master/content/docs/basic/html/03_layout.md target=_blank rel=noopener><img src=/frontend-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#布局>布局</a><ul><li><a href=#浮动布局>浮动布局</a><ul><li><a href=#清除浮动>清除浮动</a></li></ul></li><li><a href=#弹性布局>弹性布局</a><ul><li><a href=#弹性主轴和侧轴>弹性主轴和侧轴</a></li><li><a href=#弹性子元素的排序>弹性子元素的排序</a></li><li><a href=#弹性子元素剩余空间配置>弹性子元素剩余空间配置</a></li></ul></li><li><a href=#定位>定位</a><ul><li><a href=#相对定位>相对定位</a></li><li><a href=#绝对定位>绝对定位</a></li><li><a href=#固定定位>固定定位</a></li><li><a href=#粘性定位>粘性定位</a></li></ul></li><li><a href=#层>层</a></li></ul></li></ul></nav></div></aside></main></body></html>