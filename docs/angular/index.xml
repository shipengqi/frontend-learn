<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Angular on Frontend Learning</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/</link><description>Recent content in Angular on Frontend Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://shipengqi.github.io/frontend-learn/docs/angular/index.xml" rel="self" type="application/rss+xml"/><item><title>概述</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/01_overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/01_overview/</guid><description>NgModule # Angular 应用是由一个个模块组成的，称作 NgModule。
NgModule 是一组相关功能的集合，专注于某个应用领域，可以将组件和一组相关代码关联起来，是应用组织代码结构的一种方式。
NgModule 可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。
NgModule 是由 NgModule 装饰器函数装饰的类。
import { BrowserModule } from &amp;#39;@angular/platform-browser&amp;#39;; import { NgModule } from &amp;#39;@angular/core&amp;#39;; @NgModule({ imports: [ BrowserModule ] }) export class AppModule { } @NgModule 元数据 # NgModule 是一个带有 @NgModule() 装饰器的类。@NgModule() 元数据对象比较重要的属性：
declarations 属于当前 NgModule 的组件、指令、管道。 exports 导出当前 NgModule 的组件、指令、管道的列表。 imports 导入的 NgModule、组件、指令、管道的列表。 providers 当前 NgModule 所需的服务。 bootstrap 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有 root module 才应该设置这个 bootstrap 属性。 组件 # 组件用来描述用户界面，它由三部分组成，组件类、组件模板、组件样式，它们可以被集成在组件类文件中，也可以是三个不同的文件。</description></item><item><title>组件模板</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/02_component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/02_component/</guid><description>数据绑定 # 数据绑定就是将组件类中的数据显示在组件模板中，当组件类中的数据发生变化时会自动被同步到组件模板中（数据驱动 DOM ）。
在 Angular 中使用差值表达式进行数据绑定，即 {{ }}。
&amp;lt;h2&amp;gt;{{message}}&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;{{getInfo()}}&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;{{a == b ? &amp;#39;相等&amp;#39;: &amp;#39;不等&amp;#39;}}&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;{{&amp;#39;Hello Angular&amp;#39;}}&amp;lt;/h2&amp;gt; &amp;lt;p [innerHTML]=&amp;#34;htmlSnippet&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;!-- 对数据中的代码进行转义 --&amp;gt; 属性绑定 # 普通属性 # 属性绑定分为两种情况，绑定 DOM 对象属性和绑定 HTML 标记属性。
使用 [属性名称] 为元素绑定 DOM 对象属性。
&amp;lt;img [src]=&amp;#34;imgUrl&amp;#34;/&amp;gt; 使用 [attr.属性名称] 为元素绑定 HTML 标记属性
&amp;lt;td [attr.colspan]=&amp;#34;colSpan&amp;#34;&amp;gt;&amp;lt;/td&amp;gt; 在大多数情况下，DOM 对象属性和 HTML 标记属性是对应的关系，所以使用第一种情况。但是某些属性只有 HTML 标记存在，DOM 对象中不存在，此时需要使用第二种情况，比如 colspan 属性，在 DOM 对象中就没有，或者自定义 HTML 属性也需要使用第二种情况。
class 属性 # &amp;lt;button class=&amp;#34;btn btn-primary&amp;#34; [class.active]=&amp;#34;isActive&amp;#34;&amp;gt;按钮&amp;lt;/button&amp;gt; &amp;lt;div [ngClass]=&amp;#34;{&amp;#39;active&amp;#39;: true, &amp;#39;error&amp;#39;: true}&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; ngClass 可以绑定多个类名。</description></item><item><title>组件通讯</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/03_communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/03_communication/</guid><description>向组件内部传递数据 # Input 装饰器 # &amp;lt;app-favorite [isFavorite]=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/app-favorite&amp;gt; // favorite.component.ts import { Input } from &amp;#39;@angular/core&amp;#39;; export class FavoriteComponent { @Input() isFavorite: boolean = false; } 注意：在属性的外面加 [] 表示绑定动态值，对于布尔类型，不加 [] 表示绑定普通值，例如 true 在组件内接收后是字符串 &amp;quot;true&amp;quot;。
&amp;lt;app-favorite [is-Favorite]=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/app-favorite&amp;gt; import { Input } from &amp;#39;@angular/core&amp;#39;; export class FavoriteComponent { @Input(&amp;#34;is-Favorite&amp;#34;) isFavorite: boolean = false } 向组件外部传递数据 # Output 装饰器 # &amp;lt;!-- 子组件模板 --&amp;gt; &amp;lt;button (click)=&amp;#34;onClick()&amp;#34;&amp;gt;click&amp;lt;/button&amp;gt; // 子组件类 import { EventEmitter, Output } from &amp;#34;@angular/core&amp;#34; export class FavoriteComponent { @Output() change = new EventEmitter() onClick() { this.</description></item><item><title>组件生命周期</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/04_lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/04_lifecycle/</guid><description>概述 # 生命周期钩子执行顺序：
ngOnChanges：当组件的输入属性（@Input）发生变化时会调用。 ngOnInit：当组件初始化时被调用。这通常在 Angular 初始化组件并绑定所有输入属性后触发。 ngDoCheck：在每次 Angular 检查组件变化时被调用。它比 ngOnChanges 更加底层，允许自定义检测逻辑。 ngAfterContentInit：当组件的内容投影（&amp;lt;ng-content&amp;gt;）初始化完成后触发。这个钩子在 Angular 投影内容进入组件后调用一次。 ngAfterContentChecked：当 Angular 完成对组件内容投影的变更检测后调用。 ngAfterViewInit：当组件的视图（包括子组件的视图）初始化完成后调用。也就是说，它在视图的所有子组件和模板内容都加载完毕后触发。 ngAfterViewChecked：每次视图（包括子视图）变更检测之后调用。它会在 Angular 每次更新视图之后触发。 ngOnDestroy：当组件销毁之前调用。可以用来执行清理工作，如取消订阅、清理定时器等。 挂载阶段 # 挂载阶段的生命周期函数只在挂载阶段执行一次，数据更新时不再执行。
constructor
Angular 在实例化组件类时执行, 可以用来接收 Angular 注入的服务实例对象。
export class ChildComponent { constructor (private test: TestService) { console.log(this.test) // &amp;#34;test&amp;#34; } } ngOnInit
ngOnInit 会在组件的输入属性被绑定之后被调用，适合在组件加载时执行需要的初始化工作。
&amp;lt;app-child name=&amp;#34;张三&amp;#34;&amp;gt;&amp;lt;/app-child&amp;gt; export class ChildComponent implements OnInit { @Input(&amp;#34;name&amp;#34;) name: string = &amp;#34;&amp;#34; ngOnInit() { console.log(this.name) // &amp;#34;张三&amp;#34; } } ngAfterContentInit</description></item><item><title>指令</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/05_directive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/05_directive/</guid><description>概述 # 指令是 Angular 提供的操作 DOM 的途径。指令分为属性指令和结构指令。
属性指令：修改现有元素的外观或行为，selector 使用 [] 包裹。
结构指令：增加、删除 DOM 节点以修改布局，使用 * 作为指令前缀。
内置指令 # *ngIf # 根据条件渲染 DOM 节点或移除 DOM 节点。
&amp;lt;div *ngIf=&amp;#34;data.length == 0&amp;#34;&amp;gt;没有更多数据&amp;lt;/div&amp;gt; &amp;lt;div *ngIf=&amp;#34;data.length &amp;gt; 0; then dataList else noData&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;ng-template #dataList&amp;gt;课程列表&amp;lt;/ng-template&amp;gt; &amp;lt;ng-template #noData&amp;gt;没有更多数据&amp;lt;/ng-template&amp;gt; [hidden] # 根据条件显示 DOM 节点或隐藏 DOM 节点。
&amp;lt;div [hidden]=&amp;#34;data.length == 0&amp;#34;&amp;gt;课程列表&amp;lt;/div&amp;gt; &amp;lt;div [hidden]=&amp;#34;data.length &amp;gt; 0&amp;#34;&amp;gt;没有更多数据&amp;lt;/div&amp;gt; *ngFor # 遍历数据生成HTML结构
interface List { id: number name: string age: number } list: List[] = [ { id: 1, name: &amp;#34;张三&amp;#34;, age: 20 }, { id: 2, name: &amp;#34;李四&amp;#34;, age: 30 } ] &amp;lt;li *ngFor=&amp;#34; let item of list; let i = index; // 下标 let isEven = even; // 是否是第偶数个元素 let isOdd = odd; // 是否是第奇数个元素 let isFirst = first; // 是否是第一个元素 let isLast = last; // 是否是最后一个元素 &amp;#34; &amp;gt; &amp;lt;/li&amp;gt; trackBy # 在 Angular 中遍历数组时，会用到 ngFor 指令，如果数组中的数据改变了（新数组替换旧数组），Angular 会删除与数据关联的所有 DOM 元素，然后再次创建它们。这意味着将有很多 DOM 操作。</description></item><item><title>管道</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/06_pipe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/06_pipe/</guid><description>概述 # 管道的作用是转换组件模板数据。要在 HTML 模板中指定值的转换方式，使用管道操作符 |。
内置管道 # date 日期格式化 currency 货币格式化 uppercase 转大写 lowercase 转小写 json 格式化 json 数据 {{ date | date: &amp;#34;yyyy-MM-dd&amp;#34; }} {{ num | currency: &amp;#34;￥&amp;#34; }} // ￥{num} 自定义管道 # 需求：指定字符串不能超过规定的长度
// summary.pipe.ts import { Pipe, PipeTransform } from &amp;#39;@angular/core&amp;#39;; @Pipe({ name: &amp;#39;summary&amp;#39; }); export class SummaryPipe implements PipeTransform { transform (value: string, limit?: number) { if (!value) return null; let actualLimit = (limit) ?</description></item><item><title>依赖注入</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/07_di/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/07_di/</guid><description>概述 # 依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的耦合度。
class MailService { constructor(APIKEY) {} } class EmailSender { mailService: MailService constructor() { this.mailService = new MailService(&amp;#34;APIKEY1234567890&amp;#34;) } sendMail(mail) { this.mailService.sendMail(mail) } } const emailSender = new EmailSender() emailSender.sendMail(mail) EmailSender 类运行时要依赖 MailService 类。
以上写法的耦合度太高，代码并不健壮。如果 MailService 类改变了参数的传递方式，在 EmailSender 的构造函数中的写法也要跟着改变。
class EmailSender { mailService: MailService constructor(mailService: MailService) { this.mailService = mailService; } } const mailService = new MailService(&amp;#34;APIKEY1234567890&amp;#34;) const emailSender = new EmailSender(mailService) 在实例化 EmailSender 类时将它的依赖项通过 constructor 构造函数参数的形式注入到类的内部，这种写法就是依赖注入。</description></item><item><title>服务</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/08_service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/08_service/</guid><description>创建服务 # import { Injectable } from &amp;#39;@angular/core&amp;#39;; @Injectable({ providedIn: &amp;#39;root&amp;#39; }) export class TestService { } 使用：
export class AppComponent { // 这里的 TestService 实际上就是获取示例对象的 Token（唯一标识） constructor (private _test: TestService) {} } 服务的作用域 # 使用服务可以轻松实现跨模块跨组件共享数据，这取决于服务的作用域。
在根注入器中注册服务，所有模块使用同一个服务实例对象。
import { Injectable } from &amp;#39;@angular/core&amp;#39;; @Injectable({ providedIn: &amp;#39;root&amp;#39; }) export class CarListService { } 在模块级别注册服务，该模块中的所有组件使用同一个服务实例对象。
新语法：
import { Injectable } from &amp;#39;@angular/core&amp;#39;; import { CarModule } from &amp;#39;./car.module&amp;#39;; @Injectable({ providedIn: CarModule, }) export class CarListService { } 老语法：</description></item><item><title>表单</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/09_form/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/09_form/</guid><description>概述 # 在 Angular 中，表单有两种类型，分别为模板驱动表单和响应式表单。
模板驱动表单 # 概述 # 表单的控制逻辑写在组件模板中，适合简单的表单类型。
快速上手 # 引入依赖模块 FormsModule
import { FormsModule } from &amp;#34;@angular/forms&amp;#34; @NgModule({ imports: [FormsModule], }) export class AppModule {} 将 DOM 表单转换为 ngForm
&amp;lt;form #f=&amp;#34;ngForm&amp;#34; (submit)=&amp;#34;onSubmit(f)&amp;#34;&amp;gt;&amp;lt;/form&amp;gt; 声明表单字段为 ngModel
&amp;lt;form #f=&amp;#34;ngForm&amp;#34; (submit)=&amp;#34;onSubmit(f)&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; ngModel /&amp;gt; &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 获取表单字段值
import { NgForm } from &amp;#34;@angular/forms&amp;#34; export class AppComponent { onSubmit(form: NgForm) { console.log(form.value) } } 表单分组
当你的表单的表单项比较多，可以把相关的表单项分组。
&amp;lt;form #f=&amp;#34;ngForm&amp;#34; (submit)=&amp;#34;onSubmit(f)&amp;#34;&amp;gt; &amp;lt;div ngModelGroup=&amp;#34;user&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; ngModel /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div ngModelGroup=&amp;#34;contact&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;phone&amp;#34; ngModel /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 分组后，访问表单数据，例如 username，就是 form.</description></item><item><title>自定义表单控件</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/10_custom_form/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/10_custom_form/</guid><description>自定义表单控件 # 创建自定义表单控件时，通常需要三步：
实现 ControlValueAccessor 接口：使自定义控件能够与 Angular 表单框架配合使用。 实现 Validator 接口：提供自定义的验证逻辑。 注册自定义控件为 Angular 表单控件。 实现 ControlValueAccessor 接口 # ControlValueAccessor 接口允许自定义控件与 Angular 的表单控件（FormControl, ngModel）进行交互。需要实现以下方法：
writeValue(value: any): void：这个方法会将父组件的表单值写入自定义控件。 registerOnChange(fn: any): void：当自定义控件的值发生变化时，调用该方法通知父组件。 registerOnTouched(fn: any): void：当控件被触摸时（比如失去焦点），会调用这个方法通知父组件。通常来说，将 onBlur() 事件会绑定到控件的 blur 事件上，并在 onBlur() 方法中调用它。。 setDisabledState(isDisabled: boolean): void：用于设置控件的禁用状态。可以根据 isDisabled 值来禁用或启用自定义控件。 writeValue 和 setDisabledState 通常在父组件中调用 CustomFormControl.setValue() 和 CustomFormControl.disable() 方法时会执行。父组件初始化控件时也会执行，例如：
this.myCustomCtrl = new FormControl({value: &amp;#39;&amp;#39;, disabled: true}); 实现 ControlValueAccessor 接口示例：
import { Component, forwardRef } from &amp;#39;@angular/core&amp;#39;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from &amp;#39;@angular/forms&amp;#39;; @Component({ selector: &amp;#39;app-custom-input&amp;#39;, template: `&amp;lt;input [value]=&amp;#34;value&amp;#34; (input)=&amp;#34;onInput($event)&amp;#34; /&amp;gt;`, providers: [ { provide: NG_VALUE_ACCESSOR, // 注册到 Angular 表单系统 useExisting: forwardRef(() =&amp;gt; CustomInputComponent), // 指向当前组件 multi: true // 表示可以有多个实现 } ] }) export class CustomInputComponent implements ControlValueAccessor { value: string = &amp;#39;&amp;#39;; onChange: any = () =&amp;gt; {}; onTouched: any = () =&amp;gt; {}; // 实现 ControlValueAccessor 接口 registerOnChange(fn: any): void { this.</description></item><item><title>路由</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/11_router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/11_router/</guid><description>快速上手 # 创建页面组件、Layout 组件以及 Navigation 组件，供路由使用
创建首页页面组件ng g c pages/home 创建关于我们页面组件ng g c pages/about 创建布局组件ng g c pages/layout 创建导航组件ng g c pages/navigation 创建路由规则
// app.module.ts import { Routes } from &amp;#34;@angular/router&amp;#34; const routes: Routes = [ { path: &amp;#34;home&amp;#34;, component: HomeComponent }, { path: &amp;#34;about&amp;#34;, component: AboutComponent } ] 引入路由模块并启动
// app.module.ts import { RouterModule, Routes } from &amp;#34;@angular/router&amp;#34; @NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], }) export class AppModule {} 添加路由插座</description></item><item><title>HttpClient</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/12_http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/12_http/</guid><description>该模块用于发送 Http 请求，用于发送请求的方法都返回 Observable 对象。
快速开始 # 引入 HttpClientModule 模块
// app.module.ts import { httpClientModule } from &amp;#39;@angular/common/http&amp;#39;; imports: [ httpClientModule ] 注入 HttpClient 服务实例对象，用于发送请求
// app.component.ts import { HttpClient } from &amp;#39;@angular/common/http&amp;#39;; export class AppComponent { constructor(private http: HttpClient) {} } 发送请求
import { HttpClient } from &amp;#34;@angular/common/http&amp;#34; export class AppComponent implements OnInit { constructor(private http: HttpClient) {} ngOnInit() { this.getUsers().subscribe(console.log) } getUsers() { return this.http.get(&amp;#34;https://jsonplaceholder.typicode.com/users&amp;#34;) } } 请求方法 # this.</description></item><item><title>其他</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/13_other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/13_other/</guid><description>Angular 操作 DOM # ElementRef # ElementRef 是一个包装器，提供了对原生 DOM 元素的引用，通常是通过 @ViewChild 或 @ContentChild 来访问模板中的元素，但也可以直接注入 ElementRef 来操作宿主元素。
当你直接注入 ElementRef 时，Angular 会自动将组件或指令的宿主元素传递给你。你可以通过 ElementRef 访问宿主元素，并执行一些 DOM 操作：
import { Component, ElementRef, OnInit } from &amp;#39;@angular/core&amp;#39;; @Component({ selector: &amp;#39;app-example&amp;#39;, template: `&amp;lt;p&amp;gt;This is an example component!&amp;lt;/p&amp;gt;` }) export class ExampleComponent implements OnInit { constructor(private elementRef: ElementRef) {} ngOnInit() { // 通过 ElementRef 访问宿主元素 console.log(this.elementRef.nativeElement); // 打印宿主元素 this.elementRef.nativeElement.style.backgroundColor = &amp;#39;lightblue&amp;#39;; // 动态修改背景色 } } 直接注入 ElementRef 虽然可以直接通过 nativeElement 操作 DOM，但更推荐使用 Renderer2 来确保代码的跨平台兼容性、安全性和稳定性。</description></item></channel></rss>