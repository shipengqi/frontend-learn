<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="概述 # 依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的耦合度。
class MailService { constructor(APIKEY) {} } class EmailSender { mailService: MailService constructor() { this.mailService = new MailService(&#34;APIKEY1234567890&#34;) } sendMail(mail) { this.mailService.sendMail(mail) } } const emailSender = new EmailSender() emailSender.sendMail(mail) EmailSender 类运行时要依赖 MailService 类。
以上写法的耦合度太高，代码并不健壮。如果 MailService 类改变了参数的传递方式，在 EmailSender 的构造函数中的写法也要跟着改变。
class EmailSender { mailService: MailService constructor(mailService: MailService) { this.mailService = mailService; } } const mailService = new MailService(&#34;APIKEY1234567890&#34;) const emailSender = new EmailSender(mailService) 在实例化 EmailSender 类时将它的依赖项通过 constructor 构造函数参数的形式注入到类的内部，这种写法就是依赖注入。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="依赖注入"><meta property="og:description" content="概述 # 依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的耦合度。
class MailService { constructor(APIKEY) {} } class EmailSender { mailService: MailService constructor() { this.mailService = new MailService(&#34;APIKEY1234567890&#34;) } sendMail(mail) { this.mailService.sendMail(mail) } } const emailSender = new EmailSender() emailSender.sendMail(mail) EmailSender 类运行时要依赖 MailService 类。
以上写法的耦合度太高，代码并不健壮。如果 MailService 类改变了参数的传递方式，在 EmailSender 的构造函数中的写法也要跟着改变。
class EmailSender { mailService: MailService constructor(mailService: MailService) { this.mailService = mailService; } } const mailService = new MailService(&#34;APIKEY1234567890&#34;) const emailSender = new EmailSender(mailService) 在实例化 EmailSender 类时将它的依赖项通过 constructor 构造函数参数的形式注入到类的内部，这种写法就是依赖注入。"><meta property="og:type" content="article"><meta property="og:url" content="http://shipengqi.github.io/frontend-learn/docs/angular/07_di/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-12-08T16:28:03+08:00"><title>依赖注入 | Frontend Learning</title><link rel=manifest href=/frontend-learn/manifest.json><link rel=icon href=/frontend-learn/favicon.png type=image/x-icon><link rel=stylesheet href=/frontend-learn/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/frontend-learn/flexsearch.min.js></script>
<script defer src=/frontend-learn/en.search.min.037765717c349e52e429233c20732dc8d721ceb6f1132b7c4c982cc2b219d302.js integrity="sha256-A3dlcXw0nlLkKSM8IHMtyNchzrbxEyt8TJgswrIZ0wI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/frontend-learn/><span>Frontend Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/frontend-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><a href=/frontend-learn/docs/html/>HTML 和 CSS</a><ul><li><a href=/frontend-learn/docs/html/01_tags/>HTML 标签</a></li><li><a href=/frontend-learn/docs/html/02_css/>CSS 常用属性</a></li><li><a href=/frontend-learn/docs/html/03_layout/>布局与定位</a></li><li><a href=/frontend-learn/docs/html/04_animation/>过渡和动画</a></li><li><a href=/frontend-learn/docs/html/05_other/>其他属性</a></li><li><a href=/frontend-learn/docs/html/06_selector/>CSS 选择器</a></li><li><a href=/frontend-learn/docs/html/07_responsive/>响应式</a></li><li><a href=/frontend-learn/docs/html/08_svg/>SVG</a></li><li><a href=/frontend-learn/docs/html/09_chrome/>Chrome 开发者工具</a></li></ul></li><li><span>RxJS</span><ul><li><a href=/frontend-learn/docs/rxjs/01_overview/>概念</a></li><li><a href=/frontend-learn/docs/rxjs/02_operators/>操作符</a></li><li><a href=/frontend-learn/docs/rxjs/03_subject/>Subject</a></li><li><a href=/frontend-learn/docs/rxjs/04_practice/>实践</a></li></ul></li><li><span>Angular</span><ul><li><a href=/frontend-learn/docs/angular/01_overview/>概述</a></li><li><a href=/frontend-learn/docs/angular/02_component/>组件模板</a></li><li><a href=/frontend-learn/docs/angular/03_communication/>组件通讯</a></li><li><a href=/frontend-learn/docs/angular/04_lifecycle/>组件生命周期</a></li><li><a href=/frontend-learn/docs/angular/05_directive/>指令</a></li><li><a href=/frontend-learn/docs/angular/06_pipe/>管道</a></li><li><a href=/frontend-learn/docs/angular/07_di/ class=active>依赖注入</a></li><li><a href=/frontend-learn/docs/angular/08_service/>服务</a></li><li><a href=/frontend-learn/docs/angular/09_form/>表单</a></li><li><a href=/frontend-learn/docs/angular/10_custom_form/>自定义表单控件</a></li><li><a href=/frontend-learn/docs/angular/11_router/>路由</a></li><li><a href=/frontend-learn/docs/angular/12_http/>HttpClient</a></li><li><a href=/frontend-learn/docs/angular/13_other/>其他</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/frontend-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>依赖注入</strong>
<label for=toc-control><img src=/frontend-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#概述>概述</a></li><li><a href=#di-框架>DI 框架</a><ul><li><a href=#注入器-injectors>注入器 Injectors</a></li><li><a href=#提供者-provider>提供者 Provider</a></li><li><a href=#injectiontoken>InjectionToken</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=概述>概述
<a class=anchor href=#%e6%a6%82%e8%bf%b0>#</a></h1><p>依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的<strong>耦合度</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MailService</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>APIKEY</span>) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EmailSender</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mailService</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MailService</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mailService</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MailService</span>(<span style=color:#e6db74>&#34;APIKEY1234567890&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sendMail</span>(<span style=color:#a6e22e>mail</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mailService</span>.<span style=color:#a6e22e>sendMail</span>(<span style=color:#a6e22e>mail</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>emailSender</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EmailSender</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>emailSender</span>.<span style=color:#a6e22e>sendMail</span>(<span style=color:#a6e22e>mail</span>)
</span></span></code></pre></div><p><code>EmailSender</code> 类运行时要依赖 <code>MailService</code> 类。</p><p>以上写法的耦合度太高，代码并不健壮。如果 <code>MailService</code> 类改变了参数的传递方式，在 <code>EmailSender</code> 的构造函数中的写法也要跟着改变。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EmailSender</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mailService</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MailService</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>mailService</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MailService</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mailService</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mailService</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MailService</span>(<span style=color:#e6db74>&#34;APIKEY1234567890&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>emailSender</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EmailSender</span>(<span style=color:#a6e22e>mailService</span>)
</span></span></code></pre></div><p>在实例化 <code>EmailSender</code> 类时将它的依赖项通过 <code>constructor</code> 构造函数参数的形式注入到类的内部，这种写法就是<strong>依赖注入</strong>。</p><p>通过依赖注入降了代码之间的耦合度，增加了代码的可维护性。<code>MailService</code> 类中代码的更改再也不会影响 <code>EmailSender</code> 类。</p><h1 id=di-框架>DI 框架
<a class=anchor href=#di-%e6%a1%86%e6%9e%b6>#</a></h1><p>Angular 有自己的 DI 框架，它将实现依赖注入的过程隐藏了，对于开发者来说只需使用很简单的代码就可以使用复杂的依赖注入功能。</p><p>在 Angular 的 DI 框架中有四个核心概念：</p><ol><li><code>Dependency</code>：组件要依赖的实例对象，服务实例对象</li><li><code>Token</code>：获取服务实例对象的唯一标识</li><li><code>Injector</code>：注入器，负责创建维护服务类的实例对象并向组件中注入服务实例对象。</li><li><code>Provider</code>：配置注入器的对象，指定创建服务实例对象的服务类和获取实例对象的标识。</li></ol><h2 id=注入器-injectors>注入器 Injectors
<a class=anchor href=#%e6%b3%a8%e5%85%a5%e5%99%a8-injectors>#</a></h2><p>注入器负责创建服务类实例对象，并将服务类实例对象注入到需要的组件中。</p><ol><li><p>创建注入器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>ReflectiveInjector</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;@angular/core&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 服务类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MailService</span> {}
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建注入器并传入服务类
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 服务实例对象的标识，默认就是类的名字
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>injector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ReflectiveInjector</span>.<span style=color:#a6e22e>resolveAndCreate</span>([<span style=color:#a6e22e>MailService</span>])
</span></span></code></pre></div></li><li><p>获取注入器中的服务类实例对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span></code></pre></div></li><li><p>服务实例对象为单例模式，注入器在创建服务实例后会对其进行缓存</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>mailService1</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>mailService2</span>) <span style=color:#75715e>// true
</span></span></span></code></pre></div></li><li><p>不同的注入器返回不同的服务实例对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>injector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ReflectiveInjector</span>.<span style=color:#a6e22e>resolveAndCreate</span>([<span style=color:#a6e22e>MailService</span>])
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建一个子注入器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>childInjector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>resolveAndCreateChild</span>([<span style=color:#a6e22e>MailService</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>childInjector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>mailService1</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>mailService2</span>) <span style=color:#75715e>// false
</span></span></span></code></pre></div></li><li><p>服务实例的查找类似函数作用域链，当前级别可以找到就使用当前级别，当前级别找不到去父级中查找</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>injector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ReflectiveInjector</span>.<span style=color:#a6e22e>resolveAndCreate</span>([<span style=color:#a6e22e>MailService</span>])
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建一个子注入器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>childInjector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>resolveAndCreateChild</span>([])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 由于子级注入器没有 MailService，就会去父级注入器查找，所以这里拿到的 MailService 是属于父级注入器的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>childInjector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>MailService</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>mailService1</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>mailService2</span>) <span style=color:#75715e>// true
</span></span></span></code></pre></div></li></ol><h2 id=提供者-provider>提供者 Provider
<a class=anchor href=#%e6%8f%90%e4%be%9b%e8%80%85-provider>#</a></h2><ol><li><p>配置注入器的对象，通过 Provider 就可以让注入器知道使用哪个类来创建实例对象，访问这个实例对象的唯一标识是什么。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>injector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ReflectiveInjector</span>.<span style=color:#a6e22e>resolveAndCreate</span>([
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MailService</span>, <span style=color:#a6e22e>useClass</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MailService</span> }
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><ul><li><code>useClass</code>：创建实例对象所使用的类。</li><li><code>provide</code>：<code>Token</code> 访问实例对象的唯一标识</li></ul></li><li><p>访问依赖对象的标识也可以是字符串类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>injector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ReflectiveInjector</span>.<span style=color:#a6e22e>resolveAndCreate</span>([
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;mail&#34;</span>, <span style=color:#a6e22e>useClass</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MailService</span> }
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mailService</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;mail&#34;</span>)
</span></span></code></pre></div></li><li><p><code>useValue</code> 允许将一个静态值与 DI 令牌关联起来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>injector</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ReflectiveInjector</span>.<span style=color:#a6e22e>resolveAndCreate</span>([
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Config&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Object.freeze 冻结对象，不允许外部修改
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>useValue</span><span style=color:#f92672>:</span> Object.<span style=color:#a6e22e>freeze</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>APIKEY</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;API1234567890&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>APISCRET</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;500-400-300&#34;</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Config</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>injector</span>.<span style=color:#a6e22e>get</span>(<span style=color:#e6db74>&#34;Config&#34;</span>)
</span></span></code></pre></div></li><li><p><code>useFactory</code> 允许通过调用工厂函数创建一个依赖对象。通过这种方式，你可以基于 DI 和应用中可用的信息创建一个动态值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heroServiceFactory</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>logger</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>Logger</span>, <span style=color:#a6e22e>userService</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>UserService</span>) =&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HeroService</span>(<span style=color:#a6e22e>logger</span>, <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>isAuthorized</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heroServiceProvider</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>provide</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>HeroService</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>useFactory</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>heroServiceFactory</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>deps</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>Logger</span>, <span style=color:#a6e22e>UserService</span>]
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>deps</code> 属性是一个提供者令牌数组。 <code>Logger</code> 和 <code>UserService</code> 类作为它们自身类提供者的令牌。 注入器会根据指定的顺序将相应的服务注入到匹配的 <code>heroServiceFactory</code> 工厂函数参数中。</p></li></ol><p>将实例对象和外部的引用建立了松耦合关系，外部通过标识获取实例对象，只要标识保持不变，内部代码怎么变都不会影响到外部。</p><h2 id=injectiontoken>InjectionToken
<a class=anchor href=#injectiontoken>#</a></h2><p>可以定义和使用一个 <code>InjectionToken</code> 对象来为非类的依赖选择一个提供者令牌。</p><p>定义了一个类型为 <code>InjectionToken</code> 的 <code>APP_CONFIG</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>InjectionToken</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@angular/core&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>export</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>APP_CONFIG</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>InjectionToken</span>&lt;<span style=color:#f92672>AppConfig</span>&gt;(<span style=color:#e6db74>&#39;app.config&#39;</span>);
</span></span></code></pre></div><p>参数类型是可选的 <code>&lt;AppConfig></code>，<code>'app.config'</code> 是令牌的描述，指明了此令牌的用途。</p><p>接着，在组件中注册这个依赖提供者：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>providers</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>provide</span>: <span style=color:#66d9ef>APP_CONFIG</span>, <span style=color:#a6e22e>useValue</span>: <span style=color:#66d9ef>HERO_DI_CONFIG</span> }]
</span></span></code></pre></div><p>现在，借助参数装饰器 <code>@Inject()</code>，你可以把这个配置对象注入到构造函数中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>@Inject</span>(<span style=color:#a6e22e>APP_CONFIG</span>) <span style=color:#a6e22e>config</span>: <span style=color:#66d9ef>AppConfig</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>title</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/frontend-learn/commit/3794de90b5da39af1a7e27a61a4b2da240d72900 title='Last modified by PengQi Shi | December 8, 2024' target=_blank rel=noopener><img src=/frontend-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 8, 2024</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/frontend-learn/edit/master/content/docs/angular/07_di.md target=_blank rel=noopener><img src=/frontend-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#概述>概述</a></li><li><a href=#di-框架>DI 框架</a><ul><li><a href=#注入器-injectors>注入器 Injectors</a></li><li><a href=#提供者-provider>提供者 Provider</a></li><li><a href=#injectiontoken>InjectionToken</a></li></ul></li></ul></nav></div></aside></main></body></html>