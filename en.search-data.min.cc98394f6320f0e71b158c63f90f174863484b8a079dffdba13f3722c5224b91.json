[{"id":0,"href":"/frontend-learn/docs/html/","title":"HTML 和 CSS","section":"Docs","content":" HTML 和 CSS # HTML 超文本标记语言（HyperText Markup Language）：用来定义网页内容的标记语言。\n超文本：意思就是不止文本，还包括图片、音频、视频等。 标记：标记语言，就是用标记符号（HTML 标签）来标记文本，计算机就可以识别这些标记符号，从而对文本进行处理。 CSS 层叠样式表：用来定义 HTML 的显示样式。\nJavaScript： 脚本语言，用来定义与用户的交互。\n"},{"id":1,"href":"/frontend-learn/docs/html/01_tags/","title":"HTML 标签","section":"HTML 和 CSS","content":" HTML 页面的基本结构 # 一个 HTML 页面的基本结构：\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Demo\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;!-- 设置不同尺寸的 favicon，浏览器会根据分辨率自动加载合适的 favicon --\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon-16x16.ico\u0026#34; sizes=\u0026#34;16x16\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon-32x32.ico\u0026#34; sizes=\u0026#34;32x32\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon-48x48.ico\u0026#34; sizes=\u0026#34;48x48\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;!-- Fallback for older browsers --\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;apple-touch-icon.png\u0026#34;\u0026gt; \u0026lt;!-- 针对苹果设备，苹果设备保存网页到桌面的图标 --\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;site.webmanifest\u0026#34;\u0026gt; \u0026lt;!-- For PWA --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!doctype html\u0026gt;：声明文档类型是 html5。 \u0026lt;html\u0026gt;：根标签，一般只包含 head 和 body 标签。 \u0026lt;head\u0026gt;：标签内容一般不会显示在页面上，用于描述页面的信息。 \u0026lt;body\u0026gt;：页面的主要内容。 \u0026lt;title\u0026gt;：页面标题。 \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;..., .., ..\u0026quot;\u0026gt;：针对搜索引擎的页面关键字。 \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;...\u0026quot;\u0026gt;：针对搜索引擎的页面描述。 \u0026lt;style\u0026gt;：书写 css 样式。 \u0026lt;link\u0026gt;：一般用来加载 css 文件或者 favicon。 \u0026lt;script\u0026gt;：用来加载 javascript 文件。\u0026lt;script\u0026gt; 一般会放在 \u0026lt;body\u0026gt; 标签里的最下面，原因： 当 javascript 文件比较大的时候，会阻塞页面中的其他元素的加载，导致整个页面加载缓慢。 另外 javascript 可能会处理页面中元素，如果 javascript 先加载，但是元素还没有生成，会导致报错。 常用标签 # 常用的标签，后期都是可以使用 CSS 去自定义样式。那为什么要定义这么多标签，而不是使用一个标签再配合 CSS 实现样式，这是因为一个重要的概念，语义化。\n语义化的好处：\n可读性更好。 对搜索引擎友好。 文本类标签 # 文本结构 # h1-h6 标题，块级标签，占据一行 p 段落，块级标签，占据一行 文本修饰 # em: 强调 strong: 加粗 u: 下划线 sup: 上标 sub: 下标 通用 # span 一个通用标签，可以用它来替换所有的文本标签。 列表 # ul 无序列表 ol 有序列表 其他 # br 换行，单标签 hr 横线，单标签 结构化标签 # 结构化标签没有默认的样式。\n常规结构 # header: 页面头部 nav: 导航 main: 主要区域 footer: 页脚 文章结构 # article: 文档内容 section: 文档中的通用区块，通常包含一组相关的内容 aside: 文档中附加区块，通常包含侧边栏、广告等 通用 # div：（Division）块级容器标签 媒体资源标签 # img：图片 svg：矢量图 video：视频 audio：音频 canvas：画布 表单标签 # form 表单标签， action 属性是提交的页面（例如 https://www.baidu.com/s ） method 提交的方法，get 提交的数据会在链接上显示，一般用来搜索，post 提交的数据在 body 里面. input、textarea 输入或选择 select：下拉列表 option：选项 button：按钮 label：标签 链接 # a 链接，\u0026lt;a href=\u0026quot;#element-id\u0026quot;\u0026gt; 可以进行页面内位置的跳转。 实体符号 # HTML 中的预留字符必须被替换为实体符号才可以使用。例如在 HTML 中不能使用 \u0026lt; \u0026gt;，浏览器会误认为它们是标签。\n如果希望正确地显示预留字符，必须在 HTML 源代码中使用实体符号。\nMDN Web Docs (Entity)。\n"},{"id":2,"href":"/frontend-learn/docs/rxjs/01_overview/","title":"概念","section":"RxJS","content":" 概念 # RxJS：Think of RxJS as Lodash for events。也就是说，RxJS 是一个类似 lodash 的工具库，不过处理的对象是 Events。这里的 Events，可以称之为流。\n什么是流？例如，代码中每秒会输出一个数据，或者用户每一次对元素的点击，就像是在时间这个维度上，产生了一个数据集。这个数据集不像数组那样，它不是一开始都存在的，而是随着时间的流逝，一个一个数据被输出出来。这种异步行为产生的数据，就可以被称之为一个流，在 Rxjs 中，称之为 Observalbe（本质其实就是一个数据集合，只是这些数据不一定是一开始就设定好的，而是随着时间而不断产生的）。而 Rxjs，就是为了处理这种流而产生的工具，比如流与流的合并，流的截断，延迟，消抖等等操作。\nimport {interval, map} from \u0026#39;rxjs\u0026#39;; const sub = interval(1000).pipe( map(second =\u0026gt; second + \u0026#39;s\u0026#39;) ).subscribe(res =\u0026gt; { console.log(res); }); // Output: // 0s // 2s // 3s // 4s // 5s // ... 利用 interval 返回一个 Observable 流，每 1 秒产生一个数据，然后交给 map 操作符将内容进行转换，最后交过观察者打印结果。\nObservable 的核心 # 创建 # import { Observable } from \u0026#39;rxjs\u0026#39;; const observable = new Observable(function subscribe(subscriber) { const timer = setInterval(() =\u0026gt; { // 可以多次调用 next 方法向外发送数据 subscriber.next(\u0026#39;hi\u0026#39;); subscriber.next(\u0026#39;hello\u0026#39;); // 当所有数据发送完成以后，可以调用 complete 方法终止数据发送 subscriber.complete(); clearInterval(timer); }, 1000); }); 通常会使用创建操作符, of、from、interval 等来创建。\nimport { of, from, fromEvent, fromPromise, bindCallback, bindNodeCallback } from \u0026#39;rxjs\u0026#39;; // 将一个或多个值转为 Observable of(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // 将数组转为 Observable from([1, 2, 3]); // 将事件转为 Observable fromEvent(document.querySelector(\u0026#39;button\u0026#39;), \u0026#39;click\u0026#39;); // 将 Promise 转为 Observable fromPromise(fetch(\u0026#39;/users\u0026#39;)); // 将回调函数 (最后一个参数是回调函数，比如下面的 cb) 转为 Observable // fs.exists = (path, cb(exists)) var exists = bindCallback(fs.exists); exists(\u0026#39;file.txt\u0026#39;).subscribe(exists =\u0026gt; console.log(\u0026#39;Does file exist?\u0026#39;, exists)); // 将回调函数(最后一个参数得是回调函数，比如下面的 cb) 转为 Observable // fs.rename = (pathA, pathB, cb(err, result)) var rename = bindNodeCallback(fs.rename); rename(\u0026#39;file.txt\u0026#39;, \u0026#39;else.txt\u0026#39;).subscribe(() =\u0026gt; console.log(\u0026#39;Renamed!\u0026#39;)); 订阅 # observable.subscribe((x) =\u0026gt; console.log(x)); 订阅 Observable 可以理解为启动这个 Observable 流，并提供接收数据的回调函数。\n同一个 Observable 可以被多次订阅，并且每个观察这都是独立的。每个 subscribe 会启动一个独立的流，并向观察者传递数据。流与流相互独立，互不干扰。\n执行 # Observable 执行可以传递三种类型的值：\nnext 通知：发送一个值，比如数字、字符串、对象，等等。 error 通知：发送一个错误或异常。 complete 通知：不再发送任何值。 在 Observable 执行中, 可能会发送无穷个 next 通知。如果发送的是 error 或 complete 通知的话，那么之后不会再发送任何通知了。\nimport { Observable } from \u0026#39;rxjs\u0026#39;; const observable = new Observable(function subscribe(subscriber) { try { subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete(); subscriber.next(3); // 不会发送 } catch (err) { subscriber.error(err); // 如果捕获到异常会发送一个错误 } }); 清理 # 因为 Observable 执行可能会是无限的，并且观察者通常希望能在有限的时间内中止执行，它必须要一种方法来停止执行，以避免浪费计算能力或内存资源。\nobservable.subscribe 会返回一个 Subscription 可以用来取消订阅。\nimport { from } from \u0026#39;rxjs\u0026#39;; const observable = from([10, 20, 30]); const subscription = observable.subscribe((x) =\u0026gt; console.log(x)); // Later: subscription.unsubscribe(); 可观察对象的命名约定 # 通常以 $ 符号结尾。\nObserver # Observer 观察者只是一组回调函数的集合，用来消费 Observable 发送的数据。\nconst observer = { next: x =\u0026gt; console.log(\u0026#39;Observer got a next value: \u0026#39; + x), error: err =\u0026gt; console.error(\u0026#39;Observer got an error: \u0026#39; + err), complete: () =\u0026gt; console.log(\u0026#39;Observer got a complete notification\u0026#39;), }; observable.subscribe(observer); Subscription # Subscription 通常是 Observable 的执行。Subscription 有一个重要的方法，即 unsubscribe，用来取消 Observable 执行。\nSubscription 还可以合在一起：\nimport { interval } from \u0026#39;rxjs\u0026#39;; const observable1 = interval(400); const observable2 = interval(300); const subscription = observable1.subscribe(x =\u0026gt; console.log(\u0026#39;first: \u0026#39; + x)); const childSubscription = observable2.subscribe(x =\u0026gt; console.log(\u0026#39;second: \u0026#39; + x)); subscription.add(childSubscription); setTimeout(() =\u0026gt; { // subscription 和 childSubscription 都会取消订阅 subscription.unsubscribe(); }, 1000); Subscriptions 还有一个 remove(otherSubscription) 方法，用来撤销一个已添加的子 Subscription。\n"},{"id":3,"href":"/frontend-learn/docs/angular/01_overview/","title":"概述","section":"Angular","content":" NgModule # Angular 应用是由一个个模块组成的，称作 NgModule。\nNgModule 是一组相关功能的集合，专注于某个应用领域，可以将组件和一组相关代码关联起来，是应用组织代码结构的一种方式。\nNgModule 可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。\nNgModule 是由 NgModule 装饰器函数装饰的类。\nimport { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { NgModule } from \u0026#39;@angular/core\u0026#39;; @NgModule({ imports: [ BrowserModule ] }) export class AppModule { } @NgModule 元数据 # NgModule 是一个带有 @NgModule() 装饰器的类。@NgModule() 元数据对象比较重要的属性：\ndeclarations 属于当前 NgModule 的组件、指令、管道。 exports 导出当前 NgModule 的组件、指令、管道的列表。 imports 导入的 NgModule、组件、指令、管道的列表。 providers 当前 NgModule 所需的服务。 bootstrap 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有 root module 才应该设置这个 bootstrap 属性。 组件 # 组件用来描述用户界面，它由三部分组成，组件类、组件模板、组件样式，它们可以被集成在组件类文件中，也可以是三个不同的文件。\n组件类用来编写和组件直接相关的界面逻辑，在组件类中要关联该组件的组件模板和组件样式。\n组件模板用来编写组件的 HTML 结构，通过数据绑定标记将应用中数据和 DOM 进行关联。\n组件样式用来编写组件的组件的外观，组件样式可以采用 CSS、LESS、SCSS、Stylus\n在 Angular 应用中至少要有一个根组件，用于应用程序的启动。\n组件类是由 Component 装饰器函数装饰的类。\nimport { Component } from \u0026#34;@angular/core\u0026#34; @Component({ selector: \u0026#34;app-root\u0026#34;, templateUrl: \u0026#34;./app.component.html\u0026#34;, styleUrls: [\u0026#34;./app.component.css\u0026#34;] }) export class AppComponent { title = \u0026#34;angular-test\u0026#34; } 服务 # 服务用于放置和特定组件无关并希望跨组件共享的数据或逻辑。\n服务出现的目的在于解耦组件类中的代码，是组件类中的代码干净整洁。\n服务是由 Injectable 装饰器装饰的类。\nimport { Injectable } from \u0026#39;@angular/core\u0026#39;; @Injectable({}) export class AppService { } 服务的实例对象由 Angular 框架中内置的依赖注入系统创建和维护。服务是依赖需要被注入到组件中。\n在组件中需要通过 constructor 构造函数的参数来获取服务的实例对象。\n在组件中获取服务实例对象，写法如下。\nimport { AppService } from \u0026#34;./AppService\u0026#34; export class AppComponent { constructor ( private appService: AppService ) {} } Angular 会根据你指定的服务的类型来传递你想要使用的服务实例对象。\n在 Angular 中服务被设计为单例模式，这也正是为什么服务可以被用来在组件之间共享数据和逻辑的原因。\n"},{"id":4,"href":"/frontend-learn/docs/html/02_css/","title":"CSS 常用属性","section":"HTML 和 CSS","content":" 容器属性 # 盒子模型属性 # 一个元素的组成：内容 + 内边距 + 边框 + 外边距\nwidth 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 box-sizing：盒子模型默认是 box-sizing: content-box。\nborder-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块) # div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。\n块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行内元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行内元素设置宽高是无效的。另外包含 display: inline 的属性也是内级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 一个元素一旦成为了弹性布局或者网格布局的直接子元素，那么该元素之前的模式会失效，例如：\n\u0026lt;div style=\u0026#34;display: flex\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;height: 100px;width: 100px\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 上面的 span 尽管是一个行内元素，但是可以设置宽高。\n背景 # background：复合属性，background: {color} {image} {repeat} {position} {size}。 background-clip：背景的绘制区域。 border-box：默认值，边框区域 padding-box：内边距区域 content-box：内容区域 background-color：背景颜色。设置单色背景时有效。对图片背景，渐变背景无效。 background-image：背景图片。 background-repeat：背景重复，对图片背景有效。 no-repeat：不重复 repeat：重复 repeat-x：只重复水平方向 repeat-y：只重复垂直方向 background-origin：背景的绘制起点，对图片背景有效。 border-box：从边框区域开始绘制 padding-box：从内边距区域开始绘制 content-box：从内容区域开始绘制 background-position：绘制背景图片的位置。left right bottom 或者 x y 坐标。如果不设置这个属性，那么绘制背景会从背景图片的左上角开始绘制。设置该属性，例如 background-position: 10px 10px，会根据 background-origin 的值，再偏移 10px 10px 位置开始绘制。left 就是从背景图片左侧居中的位置开始绘制。right bottom 就是右下角位置开始绘制。 background-size：背景大小。背景图片的大小可以大于或者小于绘制背景的区域，这个时候就可以设置该值俩调整背景图片的显示。 cover：横向或者纵向等比例缩放背景图片，完整的覆盖整个背景绘制区域。多余的部分就不显示了。 contain：横向或者纵向等比例缩放背景图片去放到背景绘制区域。 {width} {height}：背景大小。 background-attachment：背景是否固定，scroll 滚动，fixed 固定。 多层背景 # 背景是可以设置多层的：background: linear-gradient(yellow, orange), url(1.jpg), url(2.jpg), red。\n上面的示例就设置成了一个四层背景。越靠前的背景会覆盖后面的背景。单色背景的优先级是最低的（跟顺序无关），并且只能设置一个。\n遮罩 # 遮罩属性 mask 和背景属性使用方式非常类似，这个是属性可以给元素加一层遮罩。MDN Web Docs (Mask)。\n盒子阴影 # box-shadow：{x 偏移值} {y 偏移值} {模糊度} {扩散} {颜色} {内阴影}，box-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。\n字体属性 # 声明使用的字体：font-family，取决于系统是否安装有对应的字体，例如 微软雅黑，黑体等。 字体样式：font-style，normal 默认的样式。 italic 斜体 字体大小，font-size。 字体颜色，color。 字体的粗细，font-weight，值可以是 100-900 或者 bold/bolder/lighter/normal，取决于系统是否安装有对应的字体。 字体排布，text-algin 值可以是 center/left/right。 字体行高，line-height，设置一行文字的高度。 字体修饰：text-decoration underline 下划 overline 上划线 line-through 删除线 字体阴影：text-shadow，text-shadow: {x 偏移值} {y 偏移值} {模糊度} {颜色}，text-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。 所有的字体属性都会继承父元素的字体属性，所以在 html 元素上设置字体属性，会使所有的元素都会默认继承 html 上的字体属性。\n字体设置 # font-family 设置的字体可以分为两类\n系统已经安装的字体。 远程获取的字体。 font-family 可以设置多个值，用逗号隔开。例如：font-family: \u0026quot;微软雅黑\u0026quot;, \u0026quot;黑体\u0026quot;, \u0026quot;宋体\u0026quot;, \u0026quot;楷体\u0026quot;, \u0026quot;Arial\u0026quot;;。这里会先去匹配第一个字体，如果没有，就会去匹配第二个字体，以此类推。全都没有就会使用默认的字体。一般情况下，会把比较常见的，大部分系统都有的字体放到后面，起到一个保底的作用。\n对于不同的系统，可能默认的字体都不太一样，如果想要简单使用系统的默认字体，就可以使用关键字 system-ui，font-family: system-ui。前提是浏览器支持。\n对于远程获取的字体，尽量避免使用，尤其时中文字体，体积较大，会导致网站加载较慢。\n引入在线字体：\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com.css2?family=Matemasie\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;!-- 注意要放在自己的 css 文件前面 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; @import url(\u0026#39;https://fonts.googleapis.com.css2?family=Matemasie\u0026amp;display=swap\u0026#39;) \u0026lt;/style\u0026gt; \u0026lt;!-- 注意要放在自己的 css 文件前面 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; 对于在线字体最好的方式就是先下载下来，放到自己的项目中再引用。参考下面的字体图标。\n@font-face { /* font-display */ /* 常用的可选值 block 字体文件加载时，显示空白 swap 字体文件加载时，显示备用字体，加载完成后切换 fallback 字体文件加载时，开始的很短的一段时间比如 100ms 会显示空白，如果短时间加载完成就切换，如果加载时间过长就不会再切换 */ } 字体图标 # 字体图标是用特殊的字体来显示图标，代替图片。\n字体图标的优势：\n可以使用字体属性，随时调整大小和颜色。 图标调整大小，不会因为过大而失真，因为字体是矢量图。 字体文件 size 普遍小于图片，可以降低服务器的带宽压力。 使用字体图标的方式：\n首先需要在 iconfont 下载字体图标。\nUnicode # 这个是最原始的方式，兼容性最好，支持 IE6+，以及所有现代浏览器。支持字体属性，但是由于是字体，所以不支持多色。只能使用单色图标。\n注意：新版 iconfont 支持两种方式引用多色图标：SVG symbol 引用方式和彩色字体图标模式。（使用彩色字体图标需要在「编辑项目」中开启「彩色」选项后并重新生成。）\n使用步骤如下：\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 声明字体，src 是字体文件的路径，多个文件是针对不同的浏览器 */ @font-face { font-family: \u0026#39;iconfont\u0026#39;; src: url(\u0026#39;iconfont.woff2?t=1723520893571\u0026#39;) format(\u0026#39;woff2\u0026#39;), url(\u0026#39;iconfont.woff?t=1723520893571\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;iconfont.ttf?t=1723520893571\u0026#39;) format(\u0026#39;truetype\u0026#39;); /* font-display */ /* 可选值 block 字体文件加载时，显示空白 swap 字体文件加载时，显示备用字体，加载完成后切换 fallback 字体文件加载时，开始的很短的一段时间比如 100ms 会显示空白，如果短时间加载完成就切换，如果加载时间过长就不会再切换 */ } /* 定义使用 iconfont 的样式 */ .iconfont { font-family: \u0026#34;iconfont\u0026#34; !important; /* 使用 iconfont 字体 */ font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } \u0026lt;/style\u0026gt; \u0026lt;!-- 挑选相应图标并获取字体编码（例如 \u0026amp;#x33;），应用于页面 --\u0026gt; \u0026lt;span class=\u0026#34;iconfont\u0026#34;\u0026gt;\u0026amp;#x33;\u0026lt;/span\u0026gt; Font Class # 主流方式。Font Class 是 Unicode 使用方式的一种变种，兼容性良好，兼容 IE8+，和所有现代浏览器（IE8 以上才支持伪元素）。\nFont Class 解决了 Unicode 书写不直观，语意不明确的问题。可以很容易分辨这个 icon 是什么。因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\n使用步骤如下：\n\u0026lt;!-- 引入项目下面生成的 fontclass 代码 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./iconfont.css\u0026#34;\u0026gt; \u0026lt;!-- 挑选相应图标并获取类名，应用于页面 --\u0026gt; \u0026lt;span class=\u0026#34;iconfont icon-xxx\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Font Class 就是使用了 :before 伪元素来实现的。\n例如：\n.icon-mtiIcon-yingyongshebei-fangbaocha:before { content: \u0026#34;\\e713\u0026#34;; } Symbol # 未来的主流方式。这种其实是做了一个 svg 的集合。支持多色图标，支持字体属性，但是兼容性较差。浏览器渲染 svg 的性能一般。\n常用单位 # 绝对单位 # px：像素单位。 pt、in：打印单位。 相对单位 # %：百分比。占父元素宽度或高度的百分比。 em：相对于父元素的字体大小。不建议使用。2em 就是父元素 font-size 的两倍。1em 就是 1 倍。 rem：相对于根元素（html 标签）的字体大小。2rem 就是根元素 font-size 的两倍。不仅可以用来设置字体大小，也可以用设置宽高。最终都会换算成 px。 vw：viewport width 视口单位，视口指的是浏览器的显示区域。视口宽度。20vw 就是视口宽度的 20%。 vh：viewport height 视口单位，视口高度。1vh 就等于视口高度的 1%。 vmin、vmax：vmin 是选择视口宽度或者高度中较小的那个。vmax 是选择视口宽度或者高度中较大的那个。例如 30vmax 当浏览器显示区域的高度大于宽度时，那就表示视口高度的 30%。不常用。 svh lvh dvh svw lvw dvw：移动端单位。 颜色 # 关键字 # 常见的颜色关键字：red、green、blue、yellow 等等。\n十六进制 # 十六进制颜色是由 6 个十六进制字符组成的。例如 #FF0000 表示红色。如果两个字符相同，那么可以简写为一个字符。例如 #F00 表示红色。\n其实十六进制颜色后面还可以加两位表示透明度。例如 #FF000080 表示红色，透明度为 0.5。\nRGB/RGBA # RGB 是一种色彩标准，由红（Red）、绿（Green）、蓝（Blue）3 种颜色变化来得到各种颜色。而 RGBA，其实就是在 RGB 基础上增加了一个透明度 Alpha。\nrgb(R, G, B) rgba(R, G, B, A) R，指的是红色值（Red）；G，指的是绿色值（Green）；B，指的是蓝色值（Blue）；A，指的是透明度（Alpha）。\nR、G、B 这三个可以为整数，取值范围是 0~255 或者 0%~100%。参数 A 为透明度，取值范围为 0.0~1.0。\nHSL/HSLA # HSL 是一种色彩标准，由色相（Hue）、饱和度（Saturation）、亮度（Lightness）3 种颜色变化来得到各种颜色。A 为透明度，取值范围为 0.0~1.0。\nhsl(H, S, L) hsla(H, S, L, A) 颜色的透明度和 opacity 的区别 # 十六进制颜色，RGBA，HSLA，opacity 属性都可以设置透明度。颜色透明度和 opacity 的区别是：\n在元素中使用了 opacity，那么其后代元素都会受其影响。 RGBA 等颜色透明度可以为颜色单独设置透明度，不影响整个元素的透明度，也不会影响到元素的其他属性。 示例：\n/* 设置背景颜色的透明度，而不会影响整个元素 */ background-color:rgba(255,0,255,1.0); /* bg 后代元素以及文本内容都会受到影响 */ .bg { background-color:rgb(255, 0, 255); opacity:0.3; } CSS 值的类型 # CSS 值的类型可以分为三类：\n特定关键字：例如颜色关键字，例如 red、green、blue 等。 自定义值：例如 100px、200px 等。 全局值：例如 inherit、initial、unset 等。 inherit：继承父元素的属性。继承可以分为默认继承（指的是子元素没有设置对应属性，就会继承父元素的属性，大部分属性都不会默认继承，默认继承的主要是文字属性）和主动继承。 initial：将元素的属性重置为默认值。 unset：会根据属性是不是可继承的来决定应用 inherit 还是 initial。 变量 # 声明变量，变量名前加 --，变量名大小写敏感：\nbody { --foo: #7F583F; --bar: #F7EFD2; } 上面的示例声明了两个变量：--foo 和 --bar。\n用 -- 表示变量是因为 $ 被 Sass 用掉了，@ 被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用 -- 了。\nvar 函数 # var() 函数用于读取变量。\na { color: var(--foo); text-decoration-color: var(--bar); } var() 函数使用第二个参数，表示变量的默认值（例如 color: var(--foo, #7F583F);）。如果该变量不存在，就会使用这个默认值。\n数值与单位直接写在一起，是无效的：\n.foo { --gap: 20; /* 无效 */ margin-top: var(--gap)px; } /* 必须使用calc()函数 */ .foo { --gap: 20; margin-top: calc(var(--gap) * 1px); } 作用域 # 同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的\u0026quot;层叠\u0026quot;（cascade）规则是一致的。\n\u0026lt;style\u0026gt; :root { --color: blue; } div { --color: green; } #alert { --color: red; } * { color: var(--color); } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;蓝色\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;绿色\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;alert\u0026#34;\u0026gt;红色\u0026lt;/div\u0026gt; 变量的作用域就是它所在的选择器的有效范围。\nbody { --foo: #7F583F; } .content { --bar: #F7EFD2; } 变量 --foo 的作用域是 body 选择器的生效范围，--bar 的作用域是 .content 选择器的生效范围。\n全局的变量通常放在根元素 :root 里面：\n:root { --main-color: #06c; } "},{"id":5,"href":"/frontend-learn/docs/rxjs/02_operators/","title":"操作符","section":"RxJS","content":" 概述 # 操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。并且前面的 Observable 保持不变。\n操作符有两类：\nPipeable 操作符：是指可以使用 observable.pipe(operator) 或更常用的 observable.pipe(operatorFactory()) 语法将操作符管道化的操作符。操作符工厂函数包括 filter(...) 和 mergeMap(...) 等。 创建操作符可以作为独立函数调用，可以创建一个新的 Observable。例如：of(1, 2, 3)。 创建操作符 # range # range(start, length)，调用方法后返回 Observable 对象，被订阅后会发出指定范围的数值。\nimport { range } from \u0026#34;rxjs\u0026#34; range(0, 5).subscribe(n =\u0026gt; console.log(n)) // Output: // 0 // 1 // 2 // 3 // 4 of # 将参数列表作为数据流返回。\nof(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, [], {}, true, 20).subscribe(v =\u0026gt; console.log(v)) // Output: // a // b // [] // {｝ // true // 20 from, fromEvent, fromPromise # // 将数组转为 Observable from([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]).subscribe(v =\u0026gt; console.log(v)) // Output: // a // b // c // 将事件转为 Observable fromEvent(document.querySelector(\u0026#39;button\u0026#39;), \u0026#39;click\u0026#39;); // 将 Promise 转为 Observable function p() { return new Promise(function (resolve) { resolve([100, 200]) }) } fromPromise(p()).subscribe(v =\u0026gt; console.log(v)) // Output: // [100, 200] fromPromise(fetch(\u0026#39;/users\u0026#39;)); interval、timer # interval每隔一段时间发出一个数值，数值递增。\nimport {interval, take} from \u0026#39;rxjs\u0026#39;; const numbers = interval(1000); const takeFourNumbers = numbers.pipe(take(4)); takeFourNumbers.subscribe(x =\u0026gt; console.log(\u0026#39;Next: \u0026#39;, x)); // Output: // Next: 0 // Next: 1 // Next: 2 // Next: 3 timer间隔时间过去以后发出数值，行为终止，或间隔时间发出数值后，继续按第二个参数的时间间隔继续发出值\nimport { timer } from \u0026#34;rxjs\u0026#34; timer(2000).subscribe(n =\u0026gt; console.log(n)) timer(0, 1000).subscribe(n =\u0026gt; console.log(n)) concat # 合并数据流，先让第一个数据流发出值，结束后再让第二个数据流发出值，进行整体合并。\nimport {interval, take, range, concat} from \u0026#39;rxjs\u0026#39;; const timer = interval(1000).pipe(take(4), map(x =\u0026gt; `${x}s`)); const sequence = range(1, 10); const result = concat(timer, sequence); result.subscribe(x =\u0026gt; console.log(x)); // Output: // 0s-\u0026gt; 1s-\u0026gt; 2s -\u0026gt; 3s -\u0026gt; 1 -\u0026gt; 2 ... -\u0026gt; 10 const timer = interval(1000).pipe(take(2)); concat(timer, timer) // concatenating the same Observable! .subscribe({ next: value =\u0026gt; console.log(value), complete: () =\u0026gt; console.log(\u0026#39;...and it is done!\u0026#39;) }); // Logs: // 0 after 1s // 1 after 2s // 0 after 3s // 1 after 4s // \u0026#39;...and it is done!\u0026#39; also after 4s merge # 合并数据流，多个参数一起发出数据流，按照时间线进行交叉合并。\nimport {merge, interval, take, map} from \u0026#34;rxjs\u0026#34;; const timer = interval(1000).pipe(take(3), map(v =\u0026gt; \u0026#39;timer1: \u0026#39; + v + \u0026#39;s\u0026#39;)); const timer2 = interval(1000).pipe(take(3), map(v =\u0026gt; \u0026#39;timer2: \u0026#39; + v + \u0026#39;s\u0026#39;)); merge(timer, timer2).subscribe(console.log); // Output: // timer1: 0s // timer2: 0s // timer1: 1s // timer2: 1s // timer1: 2s // timer2: 2s combineLatest # 将两个 Observable 中最新发出的数据流进行组合成新的数据流，其值由每个输入观测值的最新值计算得出。\nimport { combineLatest, timer } from \u0026#34;rxjs\u0026#34; const firstTimer = timer(0, 1000) // emit 0, 1, 2... after every second, starting from now const secondTimer = timer(500, 1000) // emit 0, 1, 2... after every second, starting 0,5s from now combineLatest(firstTimer, secondTimer).subscribe(console.log) // Output: // [0, 0] after 0.5s // [1, 0] after 1s // [1, 1] after 1.5s // [2, 1] after 2s 传入字典参数：\nimport { of, delay, startWith, combineLatest } from \u0026#39;rxjs\u0026#39;; const observables = { a: of(1).pipe(delay(1000), startWith(0)), b: of(5).pipe(delay(5000), startWith(0)), c: of(10).pipe(delay(10000), startWith(0)) }; const combined = combineLatest(observables); combined.subscribe(value =\u0026gt; console.log(value)); // Output: // { a: 0, b: 0, c: 0 } immediately // { a: 1, b: 0, c: 0 } after 1s // { a: 1, b: 5, c: 0 } after 5s // { a: 1, b: 5, c: 10 } after 10s zip # 将多个 Observable 中的数据流进行组合。其值按顺序从每个输入 Observable 的值中计算得出。\nimport { zip, of } from \u0026#34;rxjs\u0026#34; import { map } from \u0026#34;rxjs/operators\u0026#34; let age = of(27, 25, 29) let name = of(\u0026#34;Foo\u0026#34;, \u0026#34;Bar\u0026#34;, \u0026#34;Beer\u0026#34;) let isDev = of(true, true, false) zip(name, age, isDev) .pipe(map(([name, age, isDev]) =\u0026gt; ({ name, age, isDev }))) .subscribe(console.log) // { name: \u0026#39;Foo\u0026#39;, age: 27, isDev: true } // { name: \u0026#39;Bar\u0026#39;, age: 25, isDev: true } // { name: \u0026#39;Beer\u0026#39;, age: 29, isDev: false } forkJoin # forkJoin 是 RxJS 版本的 Promise.all()，即表示等到所有的 Observable 都完成后，才一次性返回值。\n传入字典参数：\nimport {forkJoin, of, timer} from \u0026#39;rxjs\u0026#39;; const observable = forkJoin({ foo: of(1, 2, 3, 4), bar: Promise.resolve(8), baz: timer(4000) }); observable.subscribe({ next: value =\u0026gt; console.log(value), complete: () =\u0026gt; console.log(\u0026#39;This is how it ends!\u0026#39;), }); // Logs: // { foo: 4, bar: 8, baz: 0 } after 4 seconds // \u0026#39;This is how it ends!\u0026#39; immediately after 传入数组参数：\nconst observable = forkJoin([ of(1, 2, 3, 4), Promise.resolve(8), timer(4000) ]); observable.subscribe({ next: value =\u0026gt; console.log(value), complete: () =\u0026gt; console.log(\u0026#39;This is how it ends!\u0026#39;), }); // Logs: // [4, 8, 0] after 4 seconds // \u0026#39;This is how it ends!\u0026#39; immediately after throwError # 返回可观察对象并向订阅者抛出错误。\nimport { throwError } from \u0026#34;rxjs\u0026#34; throwError(\u0026#34;unknown error\u0026#34;).subscribe({ error: console.log }) race # 接收并同时执行多个可观察对象，只将最快发出的数据流传递给订阅者。\nimport {interval, map, race} from \u0026#39;rxjs\u0026#39;; const obs1 = interval(7000).pipe(map(() =\u0026gt; \u0026#39;slow one\u0026#39;)); const obs2 = interval(3000).pipe(map(() =\u0026gt; \u0026#39;fast one\u0026#39;)); const obs3 = interval(5000).pipe(map(() =\u0026gt; \u0026#39;medium one\u0026#39;)); race(obs1, obs2, obs3) .subscribe(winner =\u0026gt; console.log(winner)); // Outputs // a series of \u0026#39;fast one\u0026#39; Pipeable 操作符 # 转换操作符 # map # map：对数据流进行转换，基于原有值进行转换。\nimport { interval } from \u0026#34;rxjs\u0026#34; import { map } from \u0026#34;rxjs/operators\u0026#34; interval(1000) .pipe(map(n =\u0026gt; n * 2)) .subscribe(n =\u0026gt; console.log(n)) reduce、scan # reduce: 用于将源 Observable 发出的所有的值累计成一个单一的结果。它类似于的数组 reduce 方法，但它是处理流的每个值，而不是数组。\nimport { of } from \u0026#39;rxjs\u0026#39;; import { reduce } from \u0026#39;rxjs/operators\u0026#39;; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4, 5); // 使用 reduce 操作符计算数字的总和 const sum$ = source$.pipe( reduce((acc, value) =\u0026gt; acc + value, 0) ); // 订阅并打印输出 sum$.subscribe(result =\u0026gt; console.log(result)); // 15 reduce(accumulator, [seed]) 接受两个参数：\naccumulator 是一个函数，接受两个参数： acc（累计值）：上一次迭代的结果，或者是初始值（如果提供了 seed）。 value：当前发出的值。 该函数需要返回新的累计值。 seed：可选。acc 的初始值。如果未提供，acc 会默认是流中的第一个值，从第二个值开始累计。 当 reduce 接收到源 Observable 的每个值时，会使用 accumulator 函数对当前值和累计值进行计算。 等到源 Observable 完成发射所有值时，reduce 会将最终的累计值作为结果发射出来。\nscan：类似 reduce，进行累计操作，但执行时机不同，数据源每次发出数据流 scan 都会执行。reduce 是发送出最终计算的结果，而 scan 是发出每次计算的结果。\nimport { of } from \u0026#39;rxjs\u0026#39;; import { scan } from \u0026#39;rxjs/operators\u0026#39;; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4, 5); // 使用 scan 操作符逐步计算总和 const sum$ = source$.pipe( scan((acc, value) =\u0026gt; acc + value, 0) ); // 订阅并打印输出 sum$.subscribe(result =\u0026gt; console.log(result)); // 1 // 3 // 6 // 10 // 15 groupBy # 用于将源 Observable 发出的数据根据某个条件分组，并返回一个 GroupedObservable。groupBy 根据给定的键（通常是某个属性值）将数据分组（例如按用户 ID、地区、日期等对流中的数据进行分组），每个分组会返回一个新的 Observable，这些新的 Observable 会在后续操作符中被处理。\nimport { of } from \u0026#39;rxjs\u0026#39;; import { groupBy, mergeMap, map } from \u0026#39;rxjs/operators\u0026#39;; const source$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9); source$.pipe( groupBy(value =\u0026gt; value % 2 === 0 ? \u0026#39;even\u0026#39; : \u0026#39;odd\u0026#39;), // 按奇偶分组 mergeMap(group =\u0026gt; group.pipe( map(value =\u0026gt; `${group.key}: ${value}`) // 为每个组的元素加上标识 )) ).subscribe(console.log); // odd: 1 // odd: 3 // odd: 5 // odd: 7 // odd: 9 // even: 2 // even: 4 // even: 6 // even: 8 按对象属性分组：\nimport { of } from \u0026#39;rxjs\u0026#39;; import { groupBy, mergeMap, map } from \u0026#39;rxjs/operators\u0026#39;; const source$ = of( { name: \u0026#39;Apple\u0026#39;, category: \u0026#39;Fruit\u0026#39; }, { name: \u0026#39;Carrot\u0026#39;, category: \u0026#39;Vegetable\u0026#39; }, { name: \u0026#39;Banana\u0026#39;, category: \u0026#39;Fruit\u0026#39; }, { name: \u0026#39;Broccoli\u0026#39;, category: \u0026#39;Vegetable\u0026#39; } ); source$.pipe( groupBy(item =\u0026gt; item.category), // 按类别分组 mergeMap(group =\u0026gt; group.pipe( map(item =\u0026gt; `${group.key}: ${item.name}`) // 对每个组的项进行处理 )) ).subscribe(console.log); // Fruit: Apple // Fruit: Banana // Vegetable: Carrot // Vegetable: Broccoli 过滤操作符 # filter # 对数据流进行过滤。\nimport {range} from \u0026#34;rxjs\u0026#34; import {filter} from \u0026#34;rxjs/operators\u0026#34; range(1, 10).pipe(filter((n) =\u0026gt; n \u0026gt; 5)) .subscribe((even) =\u0026gt; console.log(even)); // Output: // 6 // 7 // 8 // 9 // 10 first # 获取数据流中的第一个值或者查找数据流中第一个符合条件的值，类似数组中的 find 方法。获取到值以后终止行为。\nimport {interval} from \u0026#34;rxjs\u0026#34; import {first} from \u0026#34;rxjs/operators\u0026#34; interval(1000) .pipe(first()) .subscribe(n =\u0026gt; console.log(n)) interval(1000) .pipe(first(n =\u0026gt; n === 3)) .subscribe(n =\u0026gt; console.log(n)) last # 获取数据流中的最后一个。不可以用于不会终止的流。\nimport {range} from \u0026#34;rxjs\u0026#34; import {last} from \u0026#34;rxjs/operators\u0026#34; range(1, 10).pipe(last()).subscribe(console.log) // 10 如果数据源不变成完成状态，则没有最后一个。\nimport {interval} from \u0026#34;rxjs\u0026#34; import {last} from \u0026#34;rxjs/operators\u0026#34; interval(1000).pipe(last()).subscribe(console.log) // 不会有输出，程序会 hang 住 take、takeWhile、takeUtil、takeLast # take：获取数据流中的前几个\nimport { range } from \u0026#34;rxjs\u0026#34; import { take } from \u0026#34;rxjs/operators\u0026#34; range(1, 10).pipe(take(3)).subscribe(console.log) // 1 // 2 // 3 takeWhile：只要数据源发出的值满足 takeWhile 中的条件，就发出该值，一旦不满足，就结束发射。\nimport {range} from \u0026#34;rxjs\u0026#34; import {takeWhile} from \u0026#34;rxjs/operators\u0026#34; range(1, 10) .pipe(takeWhile(n =\u0026gt; n \u0026lt; 5)) .subscribe(console.log) // 1 // 2 // 3 // 4 takeUntil：接收一个可观察对象，当接收的可观察对象发出值时，终止主数据源。\nimport {interval, timer} from \u0026#34;rxjs\u0026#34; import {takeUntil} from \u0026#34;rxjs/operators\u0026#34; interval(1000) .pipe(takeUntil(timer(5000))) .subscribe(console.log) // 0 // 1 // 2 // 3 takeLast：获取数据流中最后的一个值，takeLast 会将值缓存在内存中，等到流结束时取最后的值。\n它不可以用于不会终止的流，在无尽的流上使用 takeLast 永远不会发出数据。\nrange(1, 100).pipe(takeLast(3)).subscribe(x =\u0026gt; console.log(x)); skip、skipWhile、skipUntil、skipLast # skip：跳过前几个数据流。\nimport {range} from \u0026#34;rxjs\u0026#34; import {skip} from \u0026#34;rxjs/operators\u0026#34; range(1, 10).pipe(skip(8)).subscribe(console.log) // 9 // 10 skipWhile：只要数据源发出的值满足 skipWhile 中的条件，就跳过该值。\nimport {range} from \u0026#34;rxjs\u0026#34; import {skipWhile} from \u0026#34;rxjs/operators\u0026#34; range(1, 10) .pipe(skipWhile(n =\u0026gt; n \u0026lt; 5)) .subscribe(console.log) // 5 // 6 // 7 // 8 // 9 // 10 skipUntil：接收一个可观察对象，并跳过主数据源发出的值，直到接收的可观察对象发出值，主数据源的值才能发出。\nimport {timer, interval} from \u0026#34;rxjs\u0026#34; import {skipUntil} from \u0026#34;rxjs/operators\u0026#34; interval(500) .pipe(skipUntil(timer(2000))) .subscribe(console.log) // 3 // 4 // 5 // ... skipLast：跳过后面几个值，它的实现和 takeLast 类似，当数据发送完成后跳过最后的值发出其他的值。不可以用于不会终止的流。\nof(1, 2, 3, 4, 5).pipe(skipLast(2)).subscribe(x =\u0026gt; console.log(x)); // 1 // 2 // 3 elementAt # elementAt 类似数组的下标索引，获取源 Observable 中指定索引位置的元素。\nelementAt(index, [defaultValue]) 接受两个参数：\nindex: 要获取的元素的索引。 defaultValue（可选）：如果索引超出范围，可以指定一个默认值。在没有提供默认值时，默认行为是发出一个错误通知。 import { of } from \u0026#39;rxjs\u0026#39;; import { elementAt } from \u0026#39;rxjs/operators\u0026#39;; // 定义一个源 Observable 发出一些数字 const source$ = of(10, 20, 30, 40, 50); // 使用 elementAt 获取索引为 2 的元素（即第三个元素，值为 30） const element$ = source$.pipe( elementAt(2) ); // 订阅并打印输出 element$.subscribe({ next: value =\u0026gt; console.log(value), error: err =\u0026gt; console.error(err) }); // 30 ignoreElements # 忽略源 Observable 发出的所有值，只传递异常和结束信息，可以用于不关注数据只关注异常的场景。\nimport { of } from \u0026#39;rxjs\u0026#39;; import { ignoreElements } from \u0026#39;rxjs/operators\u0026#39;; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4, 5); // 使用 ignoreElements 操作符 const ignored$ = source$.pipe( ignoreElements() ); // 订阅并打印输出 ignored$.subscribe({ next: value =\u0026gt; console.log(\u0026#39;Next:\u0026#39;, value), // 不会打印任何值 error: err =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, err), // 如果有错误会打印 complete: () =\u0026gt; console.log(\u0026#39;Completed!\u0026#39;) // 会打印 \u0026#34;Completed!\u0026#34; }); // Completed! debounceTime # 常用于处理输入框等需要等待用户停止输入的场景。debounceTime 会延迟发出值，直到观察源 Observable 发出新的值后经过指定的时间，只有在这段时间内没有其他值发出时，它才会发出最新的值。\nimport { fromEvent } from \u0026#34;rxjs\u0026#34; import { debounceTime } from \u0026#34;rxjs/operators\u0026#34; fromEvent(document, \u0026#34;click\u0026#34;) .pipe(debounceTime(1000)) .subscribe(x =\u0026gt; console.log(x)) distinctUntilChanged # 用于过滤重复值。它会比较相邻的值，如果当前的值与上一个值不同，则允许这个值通过，否则会被忽略。\nimport { of } from \u0026#34;rxjs\u0026#34; import { distinctUntilChanged } from \u0026#34;rxjs/operators\u0026#34; of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4) .pipe(distinctUntilChanged()) .subscribe(x =\u0026gt; console.log(x)) // 1, 2, 1, 2, 3, 4 自定义的比较函数 # import { of } from \u0026#39;rxjs\u0026#39;; import { distinctUntilChanged } from \u0026#39;rxjs/operators\u0026#39;; const source$ = of( { id: 1, name: \u0026#39;John\u0026#39; }, { id: 1, name: \u0026#39;John\u0026#39; }, { id: 2, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Alice\u0026#39; }, { id: 3, name: \u0026#39;Bob\u0026#39; } ); source$.pipe( distinctUntilChanged((prev, curr) =\u0026gt; prev.id === curr.id) // 自定义比较逻辑，比较 id 字段 ).subscribe(value =\u0026gt; { console.log(value); }); throttleTime # 节流，它能够控制源 Observable 发出的值的频率。throttleTime 会在指定的时间间隔内只允许第一次发出的值通过，其他值会被丢弃，直到这个时间间隔过去，才允许下一个值通过。\nimport { interval } from \u0026#39;rxjs\u0026#39;; import { throttleTime } from \u0026#39;rxjs/operators\u0026#39;; const source$ = interval(100); // 每 100ms 发出一个数值 source$.pipe( throttleTime(500) // 只允许每 500ms 发出一个值 ).subscribe(value =\u0026gt; { console.log(value); }); // 0 // 5 // 10 // 15 // ... throttleTime 与 debounceTime 的区别 # throttleTime：每个时间窗口内发出第一个值，之后的值会被丢弃，直到时间窗口结束。 debounceTime：在时间间隔结束之前，所有的值都会被丢弃，只有最后一个值会被发出。 连接操作符 # startWith # 创建一个新的 Observable 对象并将参数值发送出去，然后再发送源 Observable 对象发出的值。\n在异步编程中提供默认值的时候非常有用。将 startWith 发出的值当做默认值。\nimport {interval} from \u0026#34;rxjs\u0026#34; import {map, startWith} from \u0026#34;rxjs/operators\u0026#34; interval(1000) .pipe( map(n =\u0026gt; n + 100), startWith(505) ) .subscribe(n =\u0026gt; console.log(n)) // 505 // 100 // 101 // 102 // ... withLatestFrom # withLatestFrom 适用于：\n你需要从另一个流（可能是一个状态流）获取最新的数据，并将其与源 Observable 的当前数据结合处理。 用于处理那些只关心最新状态的情况，而不需要每次都处理整个流的每个值。 将点击事件与最新的计数结合：\nimport { fromEvent, interval } from \u0026#39;rxjs\u0026#39;; import { withLatestFrom, map } from \u0026#39;rxjs/operators\u0026#39;; const button = document.getElementById(\u0026#39;button\u0026#39;); const counter$ = interval(1000); // 每 1000 毫秒发出一个递增的计数值 fromEvent(button, \u0026#39;click\u0026#39;).pipe( withLatestFrom(counter$), // 将点击事件与当前计数值结合 map(([clickEvent, counterValue]) =\u0026gt; `Button clicked! Current counter: ${counterValue}`) ).subscribe(console.log); // Button clicked! Current counter: 2 // Button clicked! Current counter: 3 // Button clicked! Current counter: 4 // ... 工具操作符 # tap # tap 用来查看 Observable 流中的数据，同时不会对数据流产生任何影响。通常用来打印日志。\nimport {of, tap, map} from \u0026#39;rxjs\u0026#39;; of(Math.random()).pipe( tap(console.log), map(n =\u0026gt; n \u0026gt; 0.5 ? \u0026#39;big\u0026#39; : \u0026#39;small\u0026#39;) ).subscribe(console.log); import { of } from \u0026#39;rxjs\u0026#39;; import { tap, map } from \u0026#39;rxjs/operators\u0026#39;; const source = of(1, 2, 3, 4, 5); const example = source .pipe( map(val =\u0026gt; val + 10), tap({ next: val =\u0026gt; { console.log(\u0026#39;on next\u0026#39;, val); }, error: error =\u0026gt; { console.log(\u0026#39;on error\u0026#39;, error.message); }, complete: () =\u0026gt; console.log(\u0026#39;on complete\u0026#39;) }) ) .subscribe(val =\u0026gt; console.log(val)); // 输出： // on next 11 // 11 // on next 12 // 12 // on next 13 // 13 // on next 14 // 14 // on next 15 // 15 // on complete delay、delayWhen # delay：对 Observable 发出的值延迟指定的时间，只执行一次。\nimport {interval, take} from \u0026#34;rxjs\u0026#34; import {delay} from \u0026#34;rxjs/operators\u0026#34; const start = new Date(); interval(500) .pipe( take(5), delay(3000) ) .subscribe((v) =\u0026gt; { console.log(\u0026#39;val\u0026#39;, v); console.log(new Date() - start); }) // 3500ms 之后发出值，接下来每 500ms 发出一个值 delayWhen：将源 Observable 发出的值延迟一段时间，这个延迟时间由另一个 Observable 来决定。源 Observable 发出多少值，传入的回调函数就会执行多少次。\nimport { of, timer } from \u0026#39;rxjs\u0026#39;; import { delayWhen } from \u0026#39;rxjs/operators\u0026#39;; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4); const delayed$ = source$.pipe( delayWhen(value =\u0026gt; { // 根据每个值决定延迟的时间 // 比如这里是每个值的延迟时间都基于 1000ms + 当前数字 * 500ms return timer(1000 + value * 500); }) ); // 订阅并打印输出 delayed$.subscribe(console.log); every # every 操作符用于判断源 Observable 发出的每个值是否都符合某个条件。返回布尔值。类似数组的 every 方法。\nimport { range } from \u0026#34;rxjs\u0026#34; import { every, map } from \u0026#34;rxjs/operators\u0026#34; range(1, 9) .pipe( every(n =\u0026gt; n \u0026gt; 5) ) .subscribe(console.log) // false，因为源 Observable 发出的值只有 6，7，8，9 大于 5 range(1, 9) .pipe( every(n =\u0026gt; n \u0026gt; 0) ) .subscribe(console.log) // true 错误处理 # catchError # catchError 用于捕获 Observable 流中的错误，并返回一个新的 Observable 来替代原来的错误流。这个操作符允许你处理错误并继续执行流，而不是直接终止整个 Observable。\nimport { of, throwError } from \u0026#39;rxjs\u0026#39;; import { catchError } from \u0026#39;rxjs/operators\u0026#39;; // 模拟一个会抛出错误的 Observable const source$ = throwError(() =\u0026gt; new Error(\u0026#39;Something went wrong!\u0026#39;)); // 使用 catchError 捕获错误并返回替代的 Observable const result$ = source$.pipe( catchError(err =\u0026gt; { console.error(\u0026#39;Caught error:\u0026#39;, err.message); return of(\u0026#39;Fallback value\u0026#39;); // 重新抛出一个新的错误 // return throwError(() =\u0026gt; new Error(\u0026#39;Re-thrown error\u0026#39;)); }) ); // 订阅并打印输出 result$.subscribe({ next: value =\u0026gt; console.log(value), error: err =\u0026gt; console.error(\u0026#39;Final error:\u0026#39;, err), complete: () =\u0026gt; console.log(\u0026#39;Completed!\u0026#39;) }); // Caught error: Something went wrong! // Fallback value // Completed! retry # retry 操作符用于自动重新订阅源 Observable，并重试失败的操作。当源 Observable 发出错误通知时，retry 会尝试重新发起新的订阅，直到达到指定的重试次数为止。如果重试次数超过了指定次数，则会将错误传递给观察者。\nimport { of, throwError } from \u0026#39;rxjs\u0026#39;; import { retry } from \u0026#39;rxjs/operators\u0026#39;; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u0026gt; new Error(\u0026#39;Something went wrong!\u0026#39;)); // 使用 retry 操作符，最多重试 3 次 const retried$ = source$.pipe( retry(3) // 重试 3 次 ); // 订阅并打印输出 retried$.subscribe({ next: value =\u0026gt; console.log(value), error: err =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, err.message), // 在尝试了 3 次后，错误通知会被最终发出 complete: () =\u0026gt; console.log(\u0026#39;Completed!\u0026#39;) }); // Error: Something went wrong! 如果 count 参数未指定，retry 会无限次重试，直到成功或手动取消订阅。\n重试指定条件的错误：\nretryWhen 操作符已被弃用，使用 retry({ delay: () =\u0026gt; notify$ }) 来替代 retryWhen(() =\u0026gt; notify$)。\n通过传递一个带有 delay 选项的对象给 retry，来控制每次重试之间的延迟时间。\ndelay：可以是一个数字，表示延迟时间。 delay：可以是一个函数 delay: () =\u0026gt; notify$，返回一个 Observable。每次重试之前会等待 notify$ 发出的值。 import { of, throwError, timer } from \u0026#39;rxjs\u0026#39;; import { retry } from \u0026#39;rxjs/operators\u0026#39;; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u0026gt; new Error(\u0026#39;Network Error\u0026#39;)); // 定义一个控制延迟的 Observable const notify$ = timer(1000); // 每次重试之前等待 1 秒 // 使用 retry 操作符并指定 delay 属性 const retried$ = source$.pipe( retry({ count: 3, delay: () =\u0026gt; notify$ // 每次重试之间延迟 1 秒 }) ); // 订阅并打印输出 retried$.subscribe({ next: value =\u0026gt; console.log(value), error: err =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, err.message), complete: () =\u0026gt; console.log(\u0026#39;Completed!\u0026#39;) }); // Error: Network Error 动态延迟，指数退避：\nimport { of, throwError, timer } from \u0026#39;rxjs\u0026#39;; import { retry } from \u0026#39;rxjs/operators\u0026#39;; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u0026gt; new Error(\u0026#39;Network Error\u0026#39;)); // 动态计算每次重试的延迟：指数退避（Exponential Backoff） const retryDelay = (attempt: number) =\u0026gt; timer(Math.pow(2, attempt) * 1000); // 每次重试间隔 2^attempt 秒 // 使用 retry 操作符并指定延迟策略 const retried$ = source$.pipe( retry({ count: 3, delay: (error, attempt) =\u0026gt; retryDelay(attempt) // 基于尝试次数来计算延迟 }) ); // 订阅并打印输出 retried$.subscribe({ next: value =\u0026gt; console.log(value), error: err =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, err.message), complete: () =\u0026gt; console.log(\u0026#39;Completed!\u0026#39;) }); // Error: Network Error 根据不同错误类型重试：\nimport { of, throwError, timer } from \u0026#39;rxjs\u0026#39;; import { retry, delay } from \u0026#39;rxjs/operators\u0026#39;; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u0026gt; new Error(\u0026#39;Network Error\u0026#39;)); // 条件重试 const retryDelay = (err: any) =\u0026gt; { if (err.message === \u0026#39;Network Error\u0026#39;) { // 如果是网络错误，延迟 1 秒 console.log(\u0026#39;Network Error: Retrying...\u0026#39;); return of(err).pipe(delay(1000)); } else if (err.message === \u0026#39;Timeout Error\u0026#39;) { // 如果是超时错误，延迟 2 秒 console.log(\u0026#39;Timeout Error: Retrying...\u0026#39;); return of(err).pipe(delay(2000)); } else { // 其他错误直接抛出 return throwError(() =\u0026gt; err); } } // 使用 retry 操作符并指定 delay 属性 const retried$ = source$.pipe( retry({ count: 3, delay: (error, attempt) =\u0026gt; retryDelay(error) }) ); // 订阅并打印输出 retried$.subscribe({ next: value =\u0026gt; console.log(value), error: err =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, err.message), complete: () =\u0026gt; console.log(\u0026#39;Completed!\u0026#39;) }); 高阶操作符 # 所谓的高阶操作符（Higher Order Observable）就是指一个 Observable 发送出的值还是一个 Observable。\nconcatAll、concatMap # concatAll：用于将一个包含多个内部 Observables 的高阶 Observable（即 Observable 的 Observable）“展平”（flatten）为一个单一的 Observable，并按顺序依次合并这些内部 Observables。\nconcatAll 确保它按顺序执行每个内部 Observable，前一个 Observable 完成后才会处理下一个。 import { of } from \u0026#39;rxjs\u0026#39;; import { concatAll } from \u0026#39;rxjs/operators\u0026#39;; // 创建多个内部 Observables const source$ = of( of(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;), of(\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;), of(\u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;) ); // 使用 concatAll 将其展平为一个流 const result$ = source$.pipe(concatAll()); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // A // B // C // D // E // F // G 处理异步：\nimport { of, timer } from \u0026#39;rxjs\u0026#39;; import { concatAll, map } from \u0026#39;rxjs/operators\u0026#39;; // 模拟异步操作（例如：HTTP 请求） const simulateHttpRequest = (id) =\u0026gt; { return timer(1000 * id).pipe(map(() =\u0026gt; `Request ${id} completed`)); }; // 创建一个包含多个 HTTP 请求的 Observable const source$ = of(1, 2, 3).pipe( map(id =\u0026gt; simulateHttpRequest(id)) // 为每个请求返回一个内部 Observable ); // 使用 concatAll 依次处理这些 HTTP 请求 const result$ = source$.pipe(concatAll()); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // Request 1 completed // Request 2 completed // Request 3 completed concatMap：用于将源 Observable 发出的每个值映射为一个内部 Observable，并按顺序依次处理这些内部 Observables。\n每次只会处理一个内部 Observable，前一个 Observable 完成后才会处理下一个。 保证了顺序，不会并发执行内部 Observables。 import { of, timer } from \u0026#39;rxjs\u0026#39;; import { concatMap, map } from \u0026#39;rxjs/operators\u0026#39;; // 模拟异步操作（例如 HTTP 请求） const simulateHttpRequest = (id) =\u0026gt; { return timer(1000 * id).pipe(map(() =\u0026gt; `Request ${id} completed`)); }; // 创建一个 Observable 发出请求 ID const source$ = of(1, 2, 3); // 使用 concatMap 按顺序执行 HTTP 请求 const result$ = source$.pipe( concatMap(id =\u0026gt; simulateHttpRequest(id)) ); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // Request 1 completed // Request 2 completed // Request 3 completed mergeAll、mergeMap # mergeAll：用于将高阶 Observable（即一个发出多个内部 Observable 的 Observable）展平（flatten），并将所有内部 Observable 合并为一个单一的输出流。\nmergeAll 会立即订阅所有内部 Observable，然后并发地发出它们的值，而不会按顺序等待每个内部 Observable 完成。 mergeAll(concurrent: number = Infinity) 有一个可选参数 concurrent 可以用来控制并发数量。\nimport { of } from \u0026#39;rxjs\u0026#39;; import { mergeAll } from \u0026#39;rxjs/operators\u0026#39;; // 创建一个包含多个内部 Observables 的高阶 Observable const source$ = of( of(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;), of(\u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;), of(\u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;) ); // 使用 mergeAll 将这些内部 Observables 合并为一个单一的流 const result$ = source$.pipe(mergeAll()); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // A // B // C // D // E // F // G mergeMap：允许将源 Observable 发出的每一个值映射为一个内部 Observable（或称为“内部流”），并将这些内部 Observable 合并到一个单一的输出流中。\n不同于 concatMap，mergeMap 会并发地处理多个内部 Observable，并不会等待前一个内部 Observable 完成后再处理下一个。 mergeMap(project: (value: T) =\u0026gt; ObservableInput, concurrent: number = Infinity)，接受两个参数\nproject：一个函数，接收源 Observable 发出的每个值，并返回一个内部 Observable（或其他类型的值）。这个内部 Observable 会被合并到输出流中。 concurrent（可选）：指定最多可以同时订阅多少个内部 Observable，默认为 Infinity，表示无限制并发。 import { of } from \u0026#39;rxjs\u0026#39;; import { mergeMap, delay } from \u0026#39;rxjs/operators\u0026#39;; // 模拟异步操作 const simulateAsyncTask = (value) =\u0026gt; { return of(`Task ${value} completed`).pipe(delay(1000 * value)); // 延时模拟异步操作 }; // 创建一个源 Observable const source$ = of(1, 2, 3); // 使用 mergeMap 来并发处理多个异步任务 // 任务 Task 1, Task 2, 和 Task 3 会同时开始处理 const result$ = source$.pipe( mergeMap(value =\u0026gt; simulateAsyncTask(value)) ); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // Task 1 completed // Task 2 completed // Task 3 completed 限制并发数量：\nimport { of } from \u0026#39;rxjs\u0026#39;; import { mergeMap, delay } from \u0026#39;rxjs/operators\u0026#39;; // 模拟异步操作 const simulateAsyncTask = (value) =\u0026gt; { return of(`Task ${value} completed`).pipe(delay(1000 * value)); // 延时模拟异步操作 }; // 创建一个源 Observable const source$ = of(1, 2, 3, 4, 5); // 使用 mergeMap 并限制并发数为 2 const result$ = source$.pipe( mergeMap(value =\u0026gt; simulateAsyncTask(value), 2) // 这里限制并发数为 2 ); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // Task 1 completed // Task 2 completed // Task 3 completed // Task 4 completed // Task 5 completed switchMap # 用于将源 Observable 发出的每个值映射为一个新的 Observable，并且在接收到新的值时，取消订阅当前的内部 Observable，并订阅新的内部 Observable。\n这意味着只有最后一个内部 Observable 的值会被发出，其它之前的内部 Observable 会被自动取消订阅。\nimport { fromEvent, fromPromise } from \u0026#39;rxjs\u0026#39;; import { switchMap, debounceTime, map } from \u0026#39;rxjs/operators\u0026#39;; // 模拟网络请求 const fakeApiRequest = (query) =\u0026gt; { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; resolve(`Result for: ${query}`), 1000); }); }; // 获取搜索框元素 const searchInput = document.getElementById(\u0026#39;search\u0026#39;); // 用户输入事件流 const search$ = fromEvent(searchInput, \u0026#39;input\u0026#39;).pipe( map(event =\u0026gt; event.target.value), // 提取输入的值 debounceTime(300), // 防抖，避免每次输入都发出请求 switchMap(query =\u0026gt; { if (query) { return fromPromise(fakeApiRequest(query)); // 返回一个新的 Observable } else { return of(\u0026#39;\u0026#39;); // 如果没有输入，返回一个空字符串 } }) ); // 订阅并打印搜索结果 search$.subscribe(result =\u0026gt; console.log(result)); fakeApiRequest(query) 模拟一个异步请求，switchMap 会发出该请求，并在新的输入发生时取消之前的请求。\nexhaustAll, exhaustMap # exhaustMap：映射源 Observable 发出的每个值为一个内部 Observable，并且忽略在内部 Observable 完成之前发出的所有新值。\nexhaustMap 会等待当前的内部 Observable 完成。 在当前的内部 Observable 执行期间，任何新的源值都会被忽略。 只有在内部 Observable 完成后，才会处理源 Observable 中的下一个值。 这种行为通常用于限制并发任务的数量，尤其是在处理需要等待的异步操作时，例如避免用户频繁点击按钮触发多个请求。\nimport { fromEvent } from \u0026#39;rxjs\u0026#39;; import { exhaustMap, map, debounceTime } from \u0026#39;rxjs/operators\u0026#39;; // 模拟异步搜索请求 const simulateSearchRequest = (query) =\u0026gt; { console.log(`Searching for: ${query}`); return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve(`Search results for: ${query}`); }, 1500); // 模拟请求延时 }); }; // 获取搜索框元素 const searchInput = document.getElementById(\u0026#39;searchBox\u0026#39;); // 用户输入事件流 const search$ = fromEvent(searchInput, \u0026#39;input\u0026#39;).pipe( debounceTime(500), // 防抖，避免每次输入都发出请求 map(event =\u0026gt; event.target.value), // 提取输入的值 exhaustMap(query =\u0026gt; { if (query) { return from(simulateSearchRequest(query)); // 返回一个新的 Observable } else { return of(\u0026#39;\u0026#39;); // 如果没有输入，返回空字符串 } }) ); // 订阅并打印搜索结果 search$.subscribe(result =\u0026gt; console.log(result)); exhaustMap 会确保每次用户输入时只处理最后一次的请求，而忽略在请求进行中产生的其他输入。\nexhaustAll：类似于 exhaustMap，但它的用途稍有不同。exhaustAll 用于将源 Observable 发出的每个值（这些值本身通常是 Observable）转换为内部 Observable，并且在当前内部 Observable 完成之前，会忽略所有新的值，直到当前内部 Observable 完成。\nexhaustAll 监听源 Observable 中发出的每个值，这些值通常是 Observable。 当源 Observable 发出一个新的 Observable 时，exhaustAll 会订阅该内部 Observable。 如果当前的内部 Observable 还没有完成，exhaustAll 会忽略源 Observable 发出的所有后续值，直到当前的内部 Observable 完成。 一旦当前的内部 Observable 完成，exhaustAll 会继续处理源 Observable 中的下一个值（如果存在）。 import { of, interval } from \u0026#39;rxjs\u0026#39;; import { exhaustAll, map, take } from \u0026#39;rxjs/operators\u0026#39;; // 模拟内部 Observable（例如 HTTP 请求） const simulateAsyncTask = (id) =\u0026gt; { return of(`Request ${id} completed`).pipe( // 模拟任务延迟 map(val =\u0026gt; val), take(1) // 模拟每个请求只会发出一个值，然后完成 ); }; // 创建一个源 Observable，发出多个 Observable const source$ = of( simulateAsyncTask(1), simulateAsyncTask(2), simulateAsyncTask(3), simulateAsyncTask(4) ); // 使用 exhaustAll 来处理内部 Observable const result$ = source$.pipe( exhaustAll() // 忽略当前任务未完成时的其他任务 ); // 订阅并打印输出 result$.subscribe(value =\u0026gt; console.log(value)); // Request 1 completed // Request 2 completed // Request 3 completed // Request 4 completed "},{"id":6,"href":"/frontend-learn/docs/angular/02_component/","title":"组件模板","section":"Angular","content":" 数据绑定 # 数据绑定就是将组件类中的数据显示在组件模板中，当组件类中的数据发生变化时会自动被同步到组件模板中（数据驱动 DOM ）。\n在 Angular 中使用差值表达式进行数据绑定，即 {{ }}。\n\u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getInfo()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{a == b ? \u0026#39;相等\u0026#39;: \u0026#39;不等\u0026#39;}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{\u0026#39;Hello Angular\u0026#39;}}\u0026lt;/h2\u0026gt; \u0026lt;p [innerHTML]=\u0026#34;htmlSnippet\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 对数据中的代码进行转义 --\u0026gt; 属性绑定 # 普通属性 # 属性绑定分为两种情况，绑定 DOM 对象属性和绑定 HTML 标记属性。\n使用 [属性名称] 为元素绑定 DOM 对象属性。\n\u0026lt;img [src]=\u0026#34;imgUrl\u0026#34;/\u0026gt; 使用 [attr.属性名称] 为元素绑定 HTML 标记属性\n\u0026lt;td [attr.colspan]=\u0026#34;colSpan\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; 在大多数情况下，DOM 对象属性和 HTML 标记属性是对应的关系，所以使用第一种情况。但是某些属性只有 HTML 标记存在，DOM 对象中不存在，此时需要使用第二种情况，比如 colspan 属性，在 DOM 对象中就没有，或者自定义 HTML 属性也需要使用第二种情况。\nclass 属性 # \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; [class.active]=\u0026#34;isActive\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;div [ngClass]=\u0026#34;{\u0026#39;active\u0026#39;: true, \u0026#39;error\u0026#39;: true}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ngClass 可以绑定多个类名。\nstyle 属性 # \u0026lt;button [style.backgroundColor]=\u0026#34;isActive ? \u0026#39;blue\u0026#39;: \u0026#39;red\u0026#39;\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;button [ngStyle]=\u0026#34;{\u0026#39;backgroundColor\u0026#39;: \u0026#39;red\u0026#39;}\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; ngClass 可以绑定多个样式属性。\n事件绑定 # \u0026lt;button (click)=\u0026#34;onSave($event)\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;!-- 当按下回车键抬起的时候执行函数 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; (keyup.enter)=\u0026#34;onKeyUp()\u0026#34;/\u0026gt; 事件对象是一个固定的名字就是 $event。\n获取原生 DOM 对象 # 在组件模板中获取 # 在模板中，可以用 # 来声明一个模板变量。模板变量，可以在组件模板中的任何地方引用。\n\u0026lt;input type=\u0026#34;text\u0026#34; (keyup.enter)=\u0026#34;onKeyUp(username.value)\u0026#34; #username/\u0026gt; 在组件类中获取 # 使用 ViewChild 装饰器获取一个元素\n\u0026lt;p #paragraph\u0026gt;home works!\u0026lt;/p\u0026gt; import {AfterViewInit, ElementRef, ViewChild} from \u0026#34;@angular/core\u0026#34; export class HomeComponent implements AfterViewInit { @ViewChild(\u0026#34;paragraph\u0026#34;) paragraph: ElementRef\u0026lt;HTMLParagraphElement\u0026gt; | undefined ngAfterViewInit() { console.log(this.paragraph?.nativeElement) } } 使用 ViewChildren 获取一组元素\n\u0026lt;ul\u0026gt; \u0026lt;li #items\u0026gt;a\u0026lt;/li\u0026gt; \u0026lt;li #items\u0026gt;b\u0026lt;/li\u0026gt; \u0026lt;li #items\u0026gt;c\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; import {AfterViewInit, QueryList, ViewChildren} from \u0026#34;@angular/core\u0026#34; @Component({ selector: \u0026#34;app-home\u0026#34;, templateUrl: \u0026#34;./home.component.html\u0026#34;, styles: [] }) export class HomeComponent implements AfterViewInit { @ViewChildren(\u0026#34;items\u0026#34;) items: QueryList\u0026lt;HTMLLIElement\u0026gt; | undefined ngAfterViewInit() { console.log(this.items?.toArray()) // items 中的元素无法直接使用，需要先使用 toArray 转换成一个数组 } } ContentChild, ContentChildren # ContentChildren 属性装饰器用来从通过 Content Projection 方式设置的视图中获取 ng-content 里面匹配的多个元素。 ContentChild 类似 ContentChildren，不过返回的是一个元素。 ContentChild 和 ViewChild 的区别：\nContentChild 用来从通过 Content Projection 方式 (ng-content) 设置的视图中获取匹配的元素。 ViewChild 匹配的元素在组件的模板中定义的内容，它是组件的一部分。 内容投影 # \u0026lt;!-- app.component.html --\u0026gt; \u0026lt;bootstrap-panel\u0026gt; \u0026lt;div class=\u0026#34;heading\u0026#34;\u0026gt; Heading \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; Body \u0026lt;/div\u0026gt; \u0026lt;/bootstrap-panel\u0026gt; \u0026lt;!-- panel.component.html --\u0026gt; \u0026lt;div class=\u0026#34;panel panel-default\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;panel-heading\u0026#34;\u0026gt; \u0026lt;ng-content select=\u0026#34;.heading\u0026#34;\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt; \u0026lt;ng-content select=\u0026#34;.body\u0026#34;\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 如果只有一个 ng-content，不需要 select 属性。直接 \u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt; 就可以。\nng-content 在浏览器中会被 \u0026lt;div class=\u0026quot;heading\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 替代，如果不想要这个额外的 div，可以使用 ng-container 替代这个 div。\n\u0026lt;!-- app.component.html --\u0026gt; \u0026lt;bootstrap-panel\u0026gt; \u0026lt;ng-container class=\u0026#34;heading\u0026#34;\u0026gt; Heading \u0026lt;/ng-container\u0026gt; \u0026lt;ng-container class=\u0026#34;body\u0026#34;\u0026gt; Body \u0026lt;/ng-container\u0026gt; \u0026lt;/bootstrap-panel\u0026gt; 双向数据绑定 # 数据在组件类和组件模板中双向同步。\nAngular 将双向数据绑定功能放在了 @angular/forms 模块中，所以要实现双向数据绑定需要依赖该模块。\nimport {FormsModule} from \u0026#34;@angular/forms\u0026#34; @NgModule({ imports: [FormsModule], }) export class AppModule { } \u0026lt;input type=\u0026#34;text\u0026#34; [(ngModel)]=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;button (click)=\u0026#34;change()\u0026#34;\u0026gt;在组件类中更改 username\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;username: {{ username }}\u0026lt;/div\u0026gt; export class AppComponent { username: string = \u0026#34;\u0026#34; change() { this.username = \u0026#34;hello Angular\u0026#34; } } 数据绑定容错处理 # 当绑定的对象数据层级比较深，并且对象中的某些属性是可选的。如果不做容错处理，当访问的属性不存在时，就会报错。\n// app.component.ts export class AppComponent { task = { person: { name: \u0026#39;张三\u0026#39; } } } \u0026lt;!-- 方式一 --\u0026gt; \u0026lt;span *ngIf=\u0026#34;task.person\u0026#34;\u0026gt;{{ task.person.name }}\u0026lt;/span\u0026gt; \u0026lt;!-- 方式二 --\u0026gt; \u0026lt;span\u0026gt;{{ task.person?.name }}\u0026lt;/span\u0026gt; 全局样式 # /* 第一种方式 在 styles.css 文件中 */ @import \u0026#34;~bootstrap/dist/css/bootstrap.css\u0026#34;; /* ~ 相对node_modules文件夹 */ \u0026lt;!-- 第二种方式 在 index.html 文件中 --\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;/\u0026gt; // 第三种方式 在 angular.json 文件中 \u0026#34;styles\u0026#34; : [ \u0026#34;./node_modules/bootstrap/dist/css/bootstrap.min.css\u0026#34;, \u0026#34;src/styles.css\u0026#34; ] 变化检测 # Angular 的 变更检测（Change Detection）是 Angular 用来检查组件及其视图是否需要更新的一种机制。每当组件的状态变化时，Angular 会遍历组件树并检查哪些组件需要更新视图。变更检测是 Angular 中的核心功能之一，它决定了应用的响应性和性能。\n变更检测的触发时机 # 变更检测是由 Angular 的 变更检测机制触发的，主要触发时机包括：\n用户事件：如按钮点击、输入框文本变化等，都会触发变更检测。 异步操作：如 HTTP 请求返回数据，或者 setTimeout()、Promise 解决等，都可能触发变更检测。 手动触发：通过 ChangeDetectorRef.detectChanges() 或 ChangeDetectorRef.markForCheck()，手动通知 Angular 检查某个组件或视图。 变更检测策略 # ChangeDetectionStrategy 是一个控制组件变更检测机制的策略，它决定了 Angular 如何检查组件的变化。默认情况下，Angular 使用 ChangeDetectionStrategy.Default，即每次检测时会检查所有组件。使用不同的变更检测策略可以提高性能，尤其是在大型应用中。\n常见的 ChangeDetectionStrategy 有两种：\nChangeDetectionStrategy.Default：Angular 会在每次检测周期中检查所有的组件，包括它的子组件，直到变化被检测到并更新视图。在应用复杂度较高时可能导致性能问题。\nChangeDetectionStrategy.OnPush：使用 OnPush 策略时，只会在以下几种情况之一时检查组件的变化：\n输入属性（@Input()）的值发生变化。 事件处理器被触发（如点击、输入等）。 手动调用 ChangeDetectorRef.detectChanges() 或 ChangeDetectorRef.markForCheck()。 当组件依赖于外部输入数据，且数据变化不频繁时，使用 OnPush 可以优化性能。\nComponent 装饰器 # @Component({ // 指定组件的 CSS 选择器 // 选择器会告诉 Angular：当在模板 HTML 中找到相应的标签时，就把该组件实例化在那里。 selector: \u0026#39;app-component-overview\u0026#39;, // 定义 HTML 模板 // 在单独的文件中定义 HTML 模板 templateUrl: \u0026#39;./component-overview.component.html\u0026#39;, // HTML 模板也可以在组件中定义 // template: \u0026#39;\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt;\u0026#39;, // 多行 // template: ` // \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; // \u0026lt;p\u0026gt;This template definition spans multiple lines.\u0026lt;/p\u0026gt; // ` // 声明组件的样式 // 在单独的文件中定义组件模板的样式 styleUrls: [\u0026#39;./component-overview.component.css\u0026#39;] // 组件模板的样式也可以在组件中定义 // styles 属性接受一个包含 CSS 规则的字符串数组 // styles: [\u0026#39;h1 { font-weight: normal; }\u0026#39;] // styles 属性接受一个包含 CSS 规则的字符串 // styles: `` }) preserveWhitespaces # preserveWhitespaces 值为 false 时，从编译后的模板中移除可能多余的空白字符，为 true 时则保留，空白字符就是指那些能在 JavaScript 正则表达式中匹配 \\s 的字符。默认为 false。\ninterpolation # Angular 默认模板插值器 {{}}。interpolation 属性可以用来指定插值器的符号。\n@Component({ template: ` \u0026lt;div\u0026gt; ((data)) \u0026lt;/div\u0026gt; `, // \u0026#34;((\u0026#34;, \u0026#34;))\u0026#34; 代替 \u0026#34;{{\u0026#34;, \u0026#34;}}\u0026#34; interpolation: [\u0026#34;((\u0026#34;,\u0026#34;))\u0026#34;] }) export class AppComponent {} encapsulation # 主要作用是控制样式的作用域和隔离性。在 Angular 中，组件的样式默认情况下是局部的，只有在该组件的模板中生效，但也可以通过配置不同的封装策略来改变这一行为。\nencapsulation 主要有三种取值：\nViewEncapsulation.Emulated（默认值）模拟浏览器原生的 Shadow DOM 来封装组件样式。Angular 会将组件的样式加上一些属性选择器（通常是基于组件的 ViewEncapsulation 设置），使得样式只作用于当前组件的模板。 ViewEncapsulation.None：使用此模式时，组件的样式将不受任何封装限制，样式会全局生效，任何在该组件中定义的样式都会作用于整个应用。 ViewEncapsulation.ShadowDom：此模式使用浏览器的原生 Shadow DOM 实现样式封装。组件的样式仅会应用于该组件的 Shadow DOM 内部，而不会影响外部或其他组件。 viewProviders # 用于指定一个组件视图范围内的依赖注入（DI）提供者。它的作用是定义只在该组件的视图中可用的依赖，而不会影响到组件的父组件或其他地方。\n与 providers 的区别 # providers 定义的是整个组件（包括视图和子视图）可以访问的服务，而 viewProviders 只在当前组件的视图中有效，作用范围较小。\nexportAs # exportAs 是组件或指令的一个元数据属性，用于指定一个别名，使组件或指令可以通过模板中的 #templateReferenceVariable （模板引用变量）进行访问。\nimport { Directive } from \u0026#39;@angular/core\u0026#39;; @Directive({ selector: \u0026#39;[appHighlight]\u0026#39;, exportAs: \u0026#39;highlight\u0026#39; }) export class HighlightDirective { isHighlighted = false; toggleHighlight() { this.isHighlighted = !this.isHighlighted; } } 在模板中使用：\n\u0026lt;div appHighlight #highlight=\u0026#34;highlight\u0026#34;\u0026gt; Hover me to toggle highlight \u0026lt;/div\u0026gt; \u0026lt;button (click)=\u0026#34;highlight.toggleHighlight()\u0026#34;\u0026gt;Toggle Highlight\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;Highlight Status: {{ highlight.isHighlighted }}\u0026lt;/p\u0026gt; host # host 是组件或指令的一个元数据属性，用于设置宿主元素的行为和样式。它允许你在组件或指令的宿主元素上添加事件监听器、属性、类名和样式等。\nimport { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: `\u0026lt;p\u0026gt;Host Element Example\u0026lt;/p\u0026gt;`, host: { \u0026#39;[class.custom-class]\u0026#39;: \u0026#39;true\u0026#39;, // 添加自定义类 \u0026#39;[attr.aria-label]\u0026#39;: \u0026#39;\u0026#34;Custom Label\u0026#34;\u0026#39;, // 设置属性 \u0026#39;(click)\u0026#39;: \u0026#39;onClick()\u0026#39;, // 绑定 click 事件 \u0026#39;[style.background-color]\u0026#39;: \u0026#39;\u0026#34;lightblue\u0026#34;\u0026#39;, // 设置背景颜色 \u0026#39;[style.padding]\u0026#39;: \u0026#39;\u0026#34;10px\u0026#34;\u0026#39; // 设置内边距 } }) export class ExampleComponent { onClick() { console.log(\u0026#39;Host element clicked!\u0026#39;); } } HostBinding 和 HostListener # @HostBinding、@HostListener 装饰器的功能和 host 属性类似，只不过使用方式不同。\n@HostBinding 用于将组件或指令的属性、样式、类等绑定到宿主元素。 @HostListener() 可以监听宿主元素上的事件。 官网的说明：\nHostBinding：用于把一个 DOM 属性标记为绑定到宿主的属性，并提供配置元数据。 Angular 在变更检测期间会自动检查宿主属性绑定，如果这个绑定变化了，它就会更新该指令所在的宿主元素。 HostListener：用于声明要监听的 DOM 事件，并提供在该事件发生时要运行的处理器方法。 import { Component, HostBinding } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: `\u0026lt;p\u0026gt;HostBinding Example\u0026lt;/p\u0026gt;` }) export class ExampleComponent { @HostBinding(\u0026#39;class.active\u0026#39;) isActive = true; // 绑定宿主元素的类 @HostBinding(\u0026#39;style.backgroundColor\u0026#39;) backgroundColor = \u0026#39;lightblue\u0026#39;; // 绑定背景色 @HostListener(\u0026#39;click\u0026#39;) onClick() { console.log(\u0026#39;Host element clicked!\u0026#39;); } @HostListener(\u0026#39;window:resize\u0026#39;, [\u0026#39;$event\u0026#39;]) onResize(event: Event) { console.log(\u0026#39;Window resized\u0026#39;, event); } } 使用 @HostBinding 和 @HostListener 可以提供更灵活的宿主元素交互，适用于需要动态响应事件或更改宿主元素样式和属性的场景。 使用 host 属性则更适合为宿主元素配置一些初始行为，如设置类、属性或事件监听器，但这些行为一旦定义就不会再变化。 "},{"id":7,"href":"/frontend-learn/docs/rxjs/03_subject/","title":"Subject","section":"RxJS","content":" 概述 # RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，这意味着 Subject 确保每个观察者之间共享 Observable 的值。\n而普通的 Observable 是单播的，它会为每一个观察者创建一次新的、独立的执行。当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。\n在 RxJS 中有四种 Subject 分别是：Subject，BehaviorSubject，AsyncSubject，ReplaySubject；这四种 Subject 都是特殊的 Observable。\nSubject 既是 Observable 也是 Observer。\nSubject # Subject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，它会把订阅者添加到观察者列表中，每当有接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next 方法，把值一一送出。\nimport { Subject } from \u0026#39;rxjs\u0026#39;; const subject$ = new Subject\u0026lt;number\u0026gt;(); subject$.next(1); subject$.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`), }); subject$.next(2); subject$.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`), }); subject$.next(3); // Output: // observerA: 2 // observerA: 3 // observerB: 3 创建了一个 Subject 发出了一个值 1，但由于此时并没有订阅者，所以这个值不会被订阅到 创建了 observerA 又发出一个值 2，这时候 observerA 会接收到这个值 又创建一个 observerB 最后发出一个值 3，这时候已经订阅的都会接收到这个值 BehaviorSubject # BehaviorSubject，它有一个当前值的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到最后发出的值。\n在定义一个 BehaviorSubject 时需要有初始值。\nimport { BehaviorSubject } from \u0026#39;rxjs\u0026#39;; const behavior$ = new BehaviorSubject(0); // 0 is the initial value behavior$.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`), }); behavior$.next(1); behavior$.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`), }); behavior$.next(2); // Output: // observerA: 0 // observerA: 1 // observerB: 1 // observerA: 2 // observerB: 2 创建了一个 BehaviorSubject 的实例 behavior$，初始值为 0。 然后订阅了这个 behavior$，由于 BehaviorSubject 的特点是把最新的值发布给订阅者，observerA 会得到初始值 0，所以会输出 observerA: 0 behavior$ 发出一个新的值 1，这时候 observerA 将会收到新的值，输出 observerA: 1 增加一个订阅者 observerB，这时候它会得到最新的值 1，所以输出 observerB: 1， 最后再一次发出一个新的值 2，这个时候有两个订阅者 observerA 和 observerB，它们都会接收到新的值 2，所以会输出 observerA: 2 和 observerB: 2 ReplaySubject # ReplaySubject 有点像 BehaviorSubject，区别是不仅是当前值，之前的旧值也可以发送给新的订阅者。ReplaySubject 会记录多个值，并重放给新的订阅者。\n它的第一个参数 bufferSize 指定了缓存的大小，默认为 Infinity，即缓存所有发出的值。还可以向其传递第二个参数 windowTime，指定缓存的时间限制，默认为 Infinity，即不限制值的失效时间。\nimport { ReplaySubject } from \u0026#39;rxjs\u0026#39;; const replay$ = new ReplaySubject(2); // buffer 2 values for new subscribers replay$.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`), }); replay$.next(1); replay$.next(2); replay$.next(3); replay$.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`), }); replay$.next(4); // Output: // observerA: 1 // observerA: 2 // observerA: 3 // observerB: 2 // observerB: 3 // observerA: 4 // observerB: 4 创建了一个 ReplaySubject 的实例 replay$，并设置缓存为 2. 创建了一个订阅者 observerA 调用三次的 next 方法，把值发布给订阅者。这时订阅者 observerA 会输出三次 创建一个新的订阅者 observerB，由于 ReplaySubject 缓存了两个值，因此它将直接向订阅者 observerB 发出这两个值，订阅者 observerB 打印这两个值。 发出另外一个值 4，这时候 observerA 和 observerB 都接收到值的改变，分别打印这个值。 指定一个以毫秒为单位的窗口时间，示例：\nimport { ReplaySubject } from \u0026#39;rxjs\u0026#39;; const replay$ = new ReplaySubject(2, 100 /* windowTime 100ms */); replay$.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`), }); let i = 1; setInterval(() =\u0026gt; replay$.next(i++), 200); setTimeout(() =\u0026gt; { replay$.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`), }); }, 1000); // Output: // observerA: 0 // observerA: 1 // observerA: 2 // observerA: 3 // observerA: 4 // observerB: 4 // observerA: 5 // observerB: 5 // ... 创建 ReplaySubject并设置缓存为 2，缓存时间不超过 100ms 创建一个 observerA 每 200ms 发出一个新的值。observerA 会接收到发出的所有值 创建一个 observerB，由于是在 1000ms 后进行订阅。这意味着在开始订阅之前，replay$ 已经发出了 5 个值。在创建 ReplaySubject 时，指定最多存储 2 个值，并且不能超过 100ms。这意味着在 1000ms 后，observerB 开始订阅时，由于 replay$ 是 200ms 发出一个值，因此 observerB 只会接收到 1 个值。 AsyncSubject # 只有当 Observable 执行完成时(执行 complete())，它才会将执行的最后一个值发送给观察者。 类似 last() 操作符。\nimport { AsyncSubject } from \u0026#39;rxjs\u0026#39;; const async$ = new AsyncSubject(); async$.subscribe({ next: (v) =\u0026gt; console.log(`observerA: ${v}`), }); async$.next(1); async$.next(2); async$.subscribe({ next: (v) =\u0026gt; console.log(`observerB: ${v}`), }); async$.next(3); async$.complete(); // Logs: // observerA: 3 // observerB: 3 创建 AsyncSubject 的实例 创建一个 observerA async$ 发出 2 个值，但是 observerA 不会有输出。 创建一个 observerB 发出新的值，但是 observerA 和 observerB 都不会有输出。 执行 complate 完成，这时候将最后一个值发送给所有订阅者 Void subject # 有时，subject 的值并不重要，重要的是有一个事件被触发了。\n可以声明一个 void subject，表示这个值是不相关的。只有事件本身才是重要的。\nimport { Subject } from \u0026#39;rxjs\u0026#39;; const subject = new Subject(); // Shorthand for Subject\u0026lt;void\u0026gt; subject.subscribe({ next: () =\u0026gt; console.log(\u0026#39;One second has passed\u0026#39;), }); setTimeout(() =\u0026gt; subject.next(), 1000); "},{"id":8,"href":"/frontend-learn/docs/html/03_layout/","title":"布局与定位","section":"HTML 和 CSS","content":" 浮动布局 # 浮动布局的好处：\n可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。\n元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。\n例如下面的 html，三个 \u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 如果不想有空格，可以像下面这样，把换行和空格去掉：\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上面的方式，不好看，可以使用浮动解决：\n.child { float: left } 第一个子元素 \u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。\n清除浮动 # 浮动会导致父元素的高度塌陷。\n比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。\n因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。\n解决方式：\n设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：\n.parent { } .parent:after{ content: \u0026#34;\u0026#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。\n弹性布局 # 弹性布局可以更方便的布局，但是对浏览器要求较高。\n概念：\n弹性容器：设置了 display: flex; 的元素即为弹性容器。 弹性子元素（项目）：弹性容器里的直接子元素。 display: flex：如果一个元素的设置了这个属性（弹性容器），那么他的直接子元素（孙子元素就不是弹性布局），就会按着弹性布局的方式来布局。\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 如果 parent 不是弹性布局，那么三个 child 都是块元素，每个元素会占据一整行。但是 parent 添加了 display: flex; 属性以后，三个子元素会在一行并排显示，不会有间距。\n直接子元素是弹性布局，但是parent 元素本身还是块级布局。\n弹性主轴和侧轴 # 弹性布局有一个主轴和一个侧轴：\n主轴：默认是水平向右，可以修改为水平向左或竖直向上，竖直向下。 侧轴（交叉轴）：默认是竖直向下，可以修改为竖直向上或水平向左，水平向右， 弹性布局的子元素默认是在主轴上一行或者一竖，不会换行，默认情况下（flex-wrap: nowrap）如果一行子元素的宽度或者高度超过了父元素，所有的子元素就会等比例缩小。\n设置主轴的方向：\nflex-derection: row：默认是 row。 row：水平向右。 row-reverse：水平向左。 column：竖直向下。 column-reverse：竖直向上。 设置主轴的排布：\njustify-content: flex-start：默认是 flex-start。 flex-start：靠近主轴的起点。 flex-end：靠近主轴的终点。 center：主轴居中。 space-between：平均分布，和主轴的起点和终点没有间距。 space-around：平均分布，和主轴的起点和终点有间距，两边的间距是中间的一半。 space-evenly：平均分布，间距一致。 弹性布局，设置水平居中只需要 justify-content:center 就可以实现，如果不是弹性布局，可以用下面的方式：\ndisplay: block; /* 设置为块级元素 */ margin: 0 auto; /* auto 设置水平居中，必须是块元素 */ 设置侧轴的排布：\nalign-items: stretch：默认是 stretch。 stretch：拉伸，如果子元素没有设置高度或宽度，那么子元素会被拉伸到和父元素一样的高度或宽度。 flex-start：靠近侧轴的起点。 flex-end：靠近侧轴的终点。 center：侧轴居中。单行的侧轴没有平均分布。 换行：\nflex-wrap: nowrap：默认是 nowrap。 nowrap：不换行。 wrap：换行，如果侧轴排布是 stretch，换行以后是两行，那么两行会被拉伸，各占一半。 多行存在的时候，侧轴分布：\nalign-content: flex-start： flex-start：多行都向侧轴的起点靠拢。 flex-end：多行都向侧轴的终点靠拢。 center：多行居中。 space-around：平均分布，和侧轴的起点和终点有间距，两边的间距是中间的一半。 space-between：平均分布，和侧轴的起点和终点没有间距。 space-evenly：平均分布，间距一致。 弹性子元素会存在多个，如果要单独设置一个子元素侧轴的分布，可以给弹性子元素添加属性：\nalign-self: flex-start： flex-start：靠近侧轴的起点。 flex-end：靠近侧轴的终点。 center：侧轴居中。 主轴是不能单独设置一个子元素的分布的。\n弹性子元素的排序 # 如果要设置弹性子元素的排序，可以给每个子元素添加属性：\norder: {num} 子元素会沿主轴方向从小到大排序。 示例：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } .c1 { order: 3; background: skyblue; } .c2 { order: 2; background: green; } .c3 { order: 1; background: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child c1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 弹性子元素剩余空间配置 # 给子元素添加属性 flex: {num}，占据剩余份额的份数。flex: 1 就表示占据剩余空间的 1 份。\n示例：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; background: gray; } .child { width: 100px; height: 100px; } /* 剩余空间被分为 3 份，c1 占 1/3，c2 占 2/3 */ .c1 { flex: 1; background: skyblue; } .c2 { flex: 2; background: green; } .c3 { order: 1; background: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child c1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 上面的示例，每个子元素的宽度为 100px，那么剩余空间就是 300px。c1 会占据剩余空间的 100px，c2 占 200px。\nflex-grow、flex-shrink、flex-basis # flex 是一个复合属性（flex: {flex-grow} {flex-shrink} {flex-basiss}），它有三个属性：flex-grow、flex-shrink、flex-basis ，分别是用来设置弹性子元素的拉伸、收缩和基准值。\nflex-grow：默认值 0。和 flex: {num} 的作用是一样的。 flex-shrink：默认值 1。和 flex: {num} 的作用是相反的，当子元素的大小超过了主轴或者侧轴，那么设置了 flex-shrink 的子元素就会自动收缩。如果设置了换行，那么这个属性就没有用了。 flex-basis：默认值 auto。设置主轴方向的元素的尺寸。如果主轴是横向的，那设置的就是宽度，如果是纵向的，那设置的就是高度。 inline-flex # display: inline-flex 和 display: flex 的唯一区别就是会把元素本身变为行内元素，元素内部的子元素仍然是弹性子元素。\n网格布局 # 弹性布局是基于轴线的布局，可以看作是一维布局，网格布局将容器划分成行和列，产生单元格，可以看作是二维布局。\n概念：\n网格容器：设置了 display: grid; 的元素即为网格容器。 项目：网格容器里的直接子元素。 grid-template-columns：设置网格容器的列宽和列的数量，例如 grid-template-columns: 100px 200px 100px; 表示网格容器有三列，列宽分别是 100px、200px、100px。 grid-template-rows：设置网格容器的行高和行的数量，例如 grid-template-rows: 100px 200px; 表示网格容器有两行，行高分别是 100px、200px。 网格布局，是看不到网格线的，开发过程中，可以在浏览器中查看元素，选择 grid 标签，如下图：\n划分网格 # fr、auto、minmax # fr、auto、minmax 是网格布局的三个关键字，用来设置网格容器的列宽和行高。都是具有一定收缩性和扩展性的。\n优先级：minmax() \u0026gt; fr \u0026gt; auto。\nfr 和 auto 最小值都是 0，过多内部存在子元素，那么最小值就是子元素的宽或者高。\nfr # fr：单位（fraction），有点类似于弹性布局的 flex-grow，fr 的作用也是把整个容器内剩余的空间做均分，然后按照 fr 来分配。例如 grid-template-columns: 60px 1fr; 表示网格容器有两列，第一列的宽度是 60px，第二列的宽度是剩余的宽度。所有列都用 fr 来表示，例如 grid-template-columns: 1fr 1fr; 表示网格容器有两列，宽度各占一半。fr 可以快速的把整个网格空间利用起来，例如实现一个九宫格 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;\nauto # auto 是用来设置宽高的默认值，但是在网格容器中，有一些特别的用处。\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .child3 { height: 30px; width: 100px; background-color: salmon; } .grid-container { height: 600px; width: 600px; background-color: black; display: grid; grid-template-columns: 60px 60px auto; grid-template-rows: 100px 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;grid-container\u0026#34;\u0026gt; \u0026lt;div\u0026gt;111\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;222\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child3\u0026#34;\u0026gt;333\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 上面的示例，效果如下图：\nchild3 元素的宽度是 100px，但是这个元素所在的单元格的宽度是 auto，auto 忽略了子元素的宽度，占满了剩余空间。但是如果新增一例 1fr：\n.grid-container { /* ... */ grid-template-columns: 60px 60px auto 1fr; grid-template-rows: 100px 200px; } auto 会自动收缩，正好等于子元素的宽度，如下图：\n如果有多个 auto，例如 grid-template-columns: 60px 60px auto auto; 包含了两列 auto，这两列会把剩余空间平分，如下图：\n但是一旦有了一列 fr，例如 grid-template-columns: 60px 60px auto auto 1fr;，所有的 auto 都会自动收缩。\nminmax() # minmax({min}, {max})：用来设置一个范围，例如 grid-template-columns: minmax(100px, 200px); 表示网格容器的第一列的宽度在 100px 到 200px 之间。\n注意 min 值不要设置的比 max 大，例如 minmax(200px, 100px) 或者 minmax(1fr, 100px)。\nminmax() 的优先级是高于 auto 的，它会在最大的范围中去压缩 auto 的空间。\nrepeat # repeat({重复次数}, {尺寸})：用来设置重复的列或者行，例如 grid-template-columns: repeat(3, 100px); 表示网格容器有三列，列宽都是 100px。\nauto-fill # auto-fill：会按照尺寸去尽可能的生成最多的列或者行，例如：\n.grid-container { height: 600px; width: 650px; background-color: black; display: grid; grid-template-columns: repeat(auto-fill, 100px); grid-template-rows: 100px 200px; } 上面的示例，repeat(auto-fill, 100px) 根据当前容器的剩余空间 650px 最多就只能生成 6 列。\nauto-fit # auto-fit：也是按照尺寸去尽可能的生成最多的列或者行，但是和 auto-fill 不同的是，它最终生成的列，如果没有元素，那么它会收缩为 0。\n如果 auto-fit 的尺寸设置为 minmax，例如 grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));，那么会生成的列是会把剩余空间均分的。 但如果 auto-fill 的尺寸设置为 minmax，例如 grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));，那么会按照 min 也就是 100px 去生成列。\ngap # gap：设置网格容器的行间距和列间距。\n统一设置间距，例如 grid-gap: 10px; 表示网格容器的行间距和列间距都是 10px。 分别设置行和列的间距，例如 grid-gap: 10px 20px; 表示网格容器的行间距是 10px，列间距是 20px。也可以分开设置，例如 row-gap: 10px; column-gap: 20px;： row-gap：行间距。 column-gap：列间距。 网格排布 # 网格布局的排列顺序默认是先行后列，例如下面的一个九宫格的示例：\n\u0026lt;style\u0026gt; .grid-container { height: 300px; width: 600px; background-color: black; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 16px; font-size: 4rem; color: white; } .child { padding: 8px; } .child1 { background-color: #0055bb; } .child2 { background-color: #66bbff; } .child3 { background-color: #8440f1; } .child4 { background-color: #b88dff; } .child5 { background-color: #ff6666; } .child6 { background-color: #ffdd66; } .child7 { background-color: green; } .child8 { background-color: greenyellow; } .child9 { background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;grid-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child child1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child5\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child7\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child8\u0026#34;\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child9\u0026#34;\u0026gt;9\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 显示效果：\n元素先从第一行开始，从左到右排列。\n使用 grid-auto-flow: column 设置为先列后行。\ngrid-auto-flow 属性除了设置成 row 和 column，还可以设成 row dense 和 column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。\n例如 row dense，表示\u0026quot;先行后列\u0026quot;，并且尽可能紧密填满，尽量不出现空格。\n网格元素的尺寸 # 网格中的子元素如果没有设置尺寸，那么默认会拉伸到所在网格的大小。\n网格中子元素的大小和网格的大小是没有关系的：\n如果网格的宽或者高是一个可变的值，例如 1fr，子元素的宽高大于 1fr 的时候会把网格撑开。 如果网格的宽或者高是一个固定的值，例如 200px，子元素的宽高大于 200px 的时候，子元素会忽略网格的大小。 order # 网格子元素和弹性子元素一样也可以设置 order 属性来排序。网格子元素的 order 属性默认是 0.\n按网格线设置元素位置 # 网格边缘上的数字就是网格线的编号。列和行的网格线都是从 1 开始编号。下图中的负数，是反向编号，方便从后开始查找网格线。\n每个网格都是由四根网格线包围的，例如上图中的元素 1，它是有行的 1 号、2 号，列的 1 号、2 号网格线包围的。可以通过指定元素上下左右的 4 根网格线来设置元素在网格中的位置。\n例如上图，如果要把 7 号元素放到 2 号元素的位置：\n.child7 { background-color: green; grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; } 也可以占据多格，例如：\n.child7 { background-color: green; grid-column-start: 2; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3; } grid-column-start: 2; 和 grid-column-end: 4; 可以简写成 grid-column: 2 / 4; grid-row-start: 1; 和 grid-row-end: 3; 可以简写成 grid-row: 1 / 3; 自定义网格线名称 # 网格线虽然后编号，但是不容易记住，可以在定义列和行时自定义网格的名称。\ngrid-template-columns: [line1 aaa] 100px [line2] 200px [line3] 300px [line4]， 第一列 100px 左边的网格线（编号 1）命名 line1 和 aaa。 第二列 200px 左边的网格线（编号 2）命名为 line2。 第三列 300px 左边的网格线（编号 3）命名为 line3，右边的网格线（编号 4）命名为 line4。 grid-template-rows: [line5] 100px [line6] 100px 100px 网格线可以定义多个名字，用空格分隔，如 [line1 aaa]。 不需要定义所有的网格线名称，只定义需要用到的即可。如 [line5] 100px [line6] 100px 100px。 定义了名称的网格线，编号仍然是可以使用的。 grid-template-areas # 网格布局是可以预先将网格划分区域的，一个区域由一个或多个单元格组成。grid-template-areas 属性用于定义区域。\n.grid-container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: \u0026#39;a a b\u0026#39; \u0026#39;c c b\u0026#39; \u0026#39;d e f\u0026#39;; } 面代码先划分出一个九宫格，然后定义了每个单元格所属的区域。\n如果某些单元格不需要利用，则使用 . 表示：\n.grid-container { grid-template-areas: \u0026#39;a a b\u0026#39; \u0026#39;c c b\u0026#39; \u0026#39;. . .\u0026#39;; } .child1 { background-color: #0055bb; grid-area: a; } .child2 { background-color: #66bbff; grid-area: b; } .child3 { background-color: #8440f1; grid-area: c; } 注意：\n划分区域的方式的缺点就是每一个单元格都要去设置区域，不用的单元格也要用 . 表示，如果单元格很多，就比较麻烦。 网格线划分优先级要高于区域划分。 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为 区域名-start，终止网格线自动命名为 区域名-end。 隐形网格 # 加入网格容器划分了九个单元格，但是我们在网格容器中放置了超过 10 个或者更多的子元素，这时，浏览器会自动生成多余的网格，以便放置子元素。这种自动生成的网格就叫做隐形网格。\ngrid-auto-columns 和 grid-auto-rows 属性就是用来设置，浏览器自动创建的多余网格的列宽和行高。如果不指定这两个属性，浏览器根据单元格内容的大小，决定新增网格的列宽和行高。\n用法和 grid-template-columns、grid-template-rows 是一样的。\n网格单元中子元素的位置 # 在单元格中的子元素，如果没有设置宽高，那么会自动撑满整个单元格，如果设置了宽高，那么可以使用 justify-items 和 align-items 来设置子元素在单元格中的位置。justify-items 和 align-items 都是容器属性。\njustify-items：水平方向，可选值 start，end，center，strech。默认值是 strech。 align-items：垂直方向，可选值 start，end，center，strech。默认值是 strech。 容器设置了这两个属性后，所有单元格内的元素都会按照这个位置来排布。\n如果想要单独设置某个单元格的子元素，可以使用 justify-self 和 align-self。使用方法和 justify-items、align-items 一样。\nplace-self: {align-self} {justify-self} 是 justify-self 和 align-self 的复合属性。\n网格在容器中的位置 # justify-content、align-content 用来设置整个网格在容器中的排布，分别表示水平方向和垂直方向的排布。当整个网格没有撑满容器时，就可以使用这两个属性，可选值：\nstart：网格在起始边缘对齐。 end：网格在结束边缘对齐。 center：网格居中对齐。 strech：网格单元大小保持不变，网格单元的间隔拉伸，填满容器。 space-around：平均分布，每个网格单元的两侧的间隔相等。 space-between：平均分布，网格单元的之间的间隔相等，第一个单元贴近起始边缘，最后一个贴近结束边缘。 space-evenly：平均分布，间距一致。 inline-grid # display: inline-grid 和 display: grid 的唯一区别就是会把元素本身变为行内元素，元素内部的子元素仍然是网格元素。\n定位 # 可以设置元素具体在某个位置上。元素默认就是 static，也就是没有定位。\nrelative、absolute、fixed 这三个属性值有一个共同点，都是相对于某个基点的定位，只是基点不同。\n文档流 # 文档流（Normal Flow）简单说就是 HTML 元素的一种排布规则，元素默认是从上到下、从左到右依次排列（盒模型）。不同的布局模式，例如弹性布局或者网格布局，会有不同的排布规则。 不管是哪种文档流，本质都是对内部元素进行空间分配，元素与元素之间不产生重叠。\n脱离文档流 # 脱离文档流是指，元素会被文档流忽略，不分配空间。脱离文档流的元素可以理解为漂浮在文档流的上方。当一个元素脱离文档流后，文档流中的其他元素将忽略该元素并填补其原先的空间。\n脱离文档流的方法有浮动 float，绝对定位 position:absolute 和固定定位 position:fixed。\nstatic # static 表示浏览器会按照源码的顺序，决定每个元素的位置，每个块级元素占据自己的区块，元素与元素之间不产生重叠，这个位置就是元素的默认位置。\nstatic 定位的元素位置，是浏览器自主决定的，所以这时 left/right/top/bottom 这四个属性是无效的。\n相对定位 # position: relative：相对于默认位置（即 static 时的位置）进行偏移，虽然元素根据 left/right/top/bottom 这四个属性进行了偏移，但是在文档流中占据的位置是不变的。\ndiv { position: relative; top: 20px; } 上面的示例，div 元素从默认位置向下偏移 20px（即距离顶部 20px）。\n绝对定位 # position: absolute：相对于最接进自身并且设置了非 static 定位的父元素或者祖先元素（不是 static 的元素）。配合 left/right/top/bottom 属性使用。\n设置了绝对定位的元素，会脱离文档流，不会占据空间。正常的元素会顶上去。\n设置了绝对定位的元素的位置如何确定？\n没有设置定位偏移属性（left/right/top/bottom）的情况 要根据父元素的文档流模式来确定位置，例如 flex 布局：\n弹性容器设置了 justify-content: start;：\n弹性容器设置了 justify-content: end;：\n弹性容器设置了 justify-content: center;：\n设置了定位偏移属性的情况 元素的定位基点是设置了非 static 定位的最近的父元素或者祖先元素，如果没有非 static 定位的祖先元素，那么会以浏览器显示区域边界来进行定位。\n元素设置 position: absolute;bottom: 20px;left: 20px;：\n固定定位 # position: fixed：固定在浏览器窗口中的某个位置，相对于浏览器窗口定位。配合 left/right/top/bottom 属性使用。\n设置了固定定位的元素，会脱离文档流，不会占据空间。\n设置了固定定位的元素的位置如何确定？\n没有设置定位偏移属性（top、bottom、left、right）的情况下，和绝对定位的表现是一样的。 设置了定位偏移属性的情况下，元素的定位基点是浏览器的显示区域边界。无论页面如何滚动，元素的位置是固定不变的。 粘性定位 # sticky 的定位基点是设置了 overflow:scroll 的最近的祖先元素。如果没有就以浏览器显示区域边界来进行定位。\nsticky 定位不会脱离文档流。\nsticky 会产生动态效果，很像 relative 和 fixed 的结合。比如，网页的搜索工具栏，初始加载时，在自己的默认位置（relative 定位），页面向下滚动时，工具栏可以在距离浏览器相对应的位置固定住，始终停留在页面头部（fixed 定位）。等到页面重新向上滚动回到原位，工具栏也会回到默认位置。必须配合 left/right/top/bottom 属性使用。\n当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 sticky 元素的距离达到生效门槛，relative 定位自动切换为 fixed 定位；等到父元素完全脱离视口时（即完全不可见），fixed 定位自动切换回 relative 定位。sticky 元素这个时候也是不可见的。\n层 # 堆叠上下文 # 堆叠上下文就是一个独立的渲染层，里面的元素会按照自己的堆叠顺序进行渲染。\n页面的 \u0026lt;html\u0026gt; 元素是一个默认就有堆叠上下文的，所以被叫做根堆叠上下文。在根堆叠上下文中，元素是可以产生自己的堆叠上下文的。\n如何让一个元素产生堆叠上下文：\n默认情况下，元素的 position 不是 static，z-index 不是 auto，那么该元素就会产生堆叠上下文。 弹性（Flex）元素或者网格（Grid）元素，只要设置了 z-index 不是 auto，那么该元素就会产生堆叠上下文。 堆叠顺序 # 同一个堆叠上下文中，z-index 越大，元素的堆叠顺序越靠上。 同一个堆叠上下文中，z-index 相同，那么元素的堆叠顺序就按照元素在 DOM 中的先后顺序。 设置 z-index 只在元素所在的堆叠上下文中有效。一个堆叠上下文中子元素，无论设置的 z-index 是多少，都不会影响其他堆叠上下文的堆叠顺序。如下图：\n元素 A 产生了堆叠上下文，并且 z-index 为 1，元素 B 是 A 的子元素，z-index 为 20。但是元素 B 的是无法覆盖的元素 C 的。\n也就是说，任意元素的堆叠顺序是会被自己的祖先元素的堆叠上下文限制的，只有那些不存在祖先元素有堆叠上下文的元素，才能参与到根堆叠上下文的堆叠顺序中。所以碰到 z-index 层级高却无法覆盖层级低的元素，就要先去检查一下祖先元素是否有堆叠上下文，然后再设置 z-index。\n上图中，非 static 元素是介于 0 和 1 之间的，只要元素设置了 position 并且不是 static，那么元素就会跳到红色层级。\n"},{"id":9,"href":"/frontend-learn/docs/angular/03_communication/","title":"组件通讯","section":"Angular","content":" 向组件内部传递数据 # Input 装饰器 # \u0026lt;app-favorite [isFavorite]=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/app-favorite\u0026gt; // favorite.component.ts import { Input } from \u0026#39;@angular/core\u0026#39;; export class FavoriteComponent { @Input() isFavorite: boolean = false; } 注意：在属性的外面加 [] 表示绑定动态值，对于布尔类型，不加 [] 表示绑定普通值，例如 true 在组件内接收后是字符串 \u0026quot;true\u0026quot;。\n\u0026lt;app-favorite [is-Favorite]=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/app-favorite\u0026gt; import { Input } from \u0026#39;@angular/core\u0026#39;; export class FavoriteComponent { @Input(\u0026#34;is-Favorite\u0026#34;) isFavorite: boolean = false } 向组件外部传递数据 # Output 装饰器 # \u0026lt;!-- 子组件模板 --\u0026gt; \u0026lt;button (click)=\u0026#34;onClick()\u0026#34;\u0026gt;click\u0026lt;/button\u0026gt; // 子组件类 import { EventEmitter, Output } from \u0026#34;@angular/core\u0026#34; export class FavoriteComponent { @Output() change = new EventEmitter() onClick() { this.change.emit({ name: \u0026#34;张三\u0026#34; }) } } \u0026lt;!-- 父组件模板 --\u0026gt; \u0026lt;app-favorite (change)=\u0026#34;onChange($event)\u0026#34;\u0026gt;\u0026lt;/app-favorite\u0026gt; // 父组件类 export class AppComponent { onChange(event: { name: string }) { console.log(event) } } 父组件与子组件通过本地变量互动 # 父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法：\n子组件 CountdownTimerComponent：\n@Component({ selector: \u0026#39;app-countdown-timer\u0026#39;, template: \u0026#39;\u0026lt;p\u0026gt;{{message}}\u0026lt;/p\u0026gt;\u0026#39; }) export class CountdownTimerComponent implements OnDestroy { intervalId = 0; message = \u0026#39;\u0026#39;; seconds = 11; ngOnDestroy() { this.clearTimer(); } start() { this.countDown(); } stop() { this.clearTimer(); this.message = `Holding at T-${this.seconds} seconds`; } private clearTimer() { clearInterval(this.intervalId); } private countDown() { // ... } } 父组件 CountdownLocalVarParentComponent：\n@Component({ selector: \u0026#39;app-countdown-parent-lv\u0026#39;, template: ` \u0026lt;h3\u0026gt;Countdown to Liftoff (via local variable)\u0026lt;/h3\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;timer.start()\u0026#34;\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;timer.stop()\u0026#34;\u0026gt;Stop\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;seconds\u0026#34;\u0026gt;{{timer.seconds}}\u0026lt;/div\u0026gt; \u0026lt;app-countdown-timer #timer\u0026gt;\u0026lt;/app-countdown-timer\u0026gt; `, styleUrls: [\u0026#39;../assets/demo.css\u0026#39;] }) export class CountdownLocalVarParentComponent { } 父组件不能通过数据绑定使用子组件的 start 和 stop 方法，也不能访问子组件的 seconds 属性。把本地变量(#timer)放到(\u0026lt;countdown-timer\u0026gt;)标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，可以在父组件的模板中访问子组件的属性和方法。\n"},{"id":10,"href":"/frontend-learn/docs/rxjs/04_practice/","title":"实践","section":"RxJS","content":" 优雅的资源释放 # 对于无限值必须要取消订阅，反之可以不需要。例如监听 DOM 元素的事件：\nObservable.fromEvent(node, \u0026#39;input\u0026#39;) .subscribe(value =\u0026gt; { console.log(value); }); 因为如果不取消订阅，事件所关联的方法会一直被占用，导致内存泄露。\n传统方式 # @Component({ selector: \u0026#39;app-demo\u0026#39;, template: ` \u0026lt;div\u0026gt;Hello, world!\u0026lt;/div\u0026gt; ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = new Subject\u0026lt;void\u0026gt;(); private timer; constructor() { this.timer = interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } 上面的在组件中定义了一个私有变量 _destroy$，是一个 Subject 对象，用于在组件销毁时发出信号以释放资源。通过 takeUntil(this._destroy$) 操作符来限制 Observable 的生命周期，在 _destroy$ 发出信号时停止发出值。\n这种方式虽然使用了 takeUntil 来限制 Observable 的生命周期，但是仍然需要在 ngOnDestroy 钩子中手动调用 _destroy$.next() 和 _destroy$.complete() 来确保释放资源。容易遗漏而引发错误。\n继承方式 # @Directive() export class BaseComponent implements OnDestroy { // protected, not private protected readonly _destroy$ = new Subject\u0026lt;void\u0026gt;(); ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } @Component({ selector: \u0026#39;app-demo\u0026#39;, template: ` \u0026lt;div\u0026gt;Hello, world!\u0026lt;/div\u0026gt; ` }) export class GeneralComponent extends BaseComponent { constructor() { super(); interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } } 继承方式可以减少了在每个组件中手动管理资源释放的重复性工作。但是导致了派生组件与基类紧密耦合。一个派生类只能继承自一个基类。如果要在不同的组件中共享不同的基础逻辑，就会受到继承单一基类的限制。而且继承方式导致代码的可读性和可维护性下降。\nDestroyRef 机制 # function destroyRefFactory() { const destroy$ = new Subject\u0026lt;void\u0026gt;(); const destroyRef = inject(DestroyRef); destroyRef.onDestroy(() =\u0026gt; { destroy$.next(); destroy$.complete(); }) return destroy$; } @Component({ selector: \u0026#39;app-demo\u0026#39;, template: ` \u0026lt;div\u0026gt;Hello, world!\u0026lt;/div\u0026gt; ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = destroyRefFactory(); constructor() { interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log) } } 基于 DestroyRef 机制，不需要在组件中手动释放资源。而且不仅限于单一订阅场景，它在多个订阅场景中同样适用。\n自定义操作符 # 基于 DestroyRef 机制的实现方式简洁灵活，但是仍然需要在组件中声明 _destroy$。通过自定义操作符可以将释放资源的逻辑封装在操作符内部，让代码更加整洁，使资源释放与业务逻辑解耦。\nfunction takeUntilDestroyed\u0026lt;T\u0026gt;(destroyRef?: DestroyRef): MonoTypeOperatorFunction\u0026lt;T\u0026gt; { if (!destroyRef) { destroyRef = inject(DestroyRef); } const destroy$ = new Observable\u0026lt;void\u0026gt;(observer =\u0026gt; { return destroyRef!.onDestroy(() =\u0026gt; { observer.next(); observer.complete(); }); }) return \u0026lt;T\u0026gt;(source: Observable\u0026lt;T\u0026gt;) =\u0026gt; { return source.pipe(takeUntil(destroy$)) } } @Component({ selector: \u0026#39;app-demo\u0026#39;, template: ` \u0026lt;div\u0026gt;Hello, world!\u0026lt;/div\u0026gt; ` }) export class GeneralComponent implements OnDestroy { constructor() { interval(1000).pipe(takeUntilDestroyed()).subscribe(console.log) } } @angular/core/rxjs-interop 中已经提供了 takeUntilDestroyed 操作符。\n"},{"id":11,"href":"/frontend-learn/docs/angular/04_lifecycle/","title":"组件生命周期","section":"Angular","content":" 概述 # 生命周期钩子执行顺序：\nngOnChanges：当组件的输入属性（@Input）发生变化时会调用。 ngOnInit：当组件初始化时被调用。这通常在 Angular 初始化组件并绑定所有输入属性后触发。 ngDoCheck：在每次 Angular 检查组件变化时被调用。它比 ngOnChanges 更加底层，允许自定义检测逻辑。 ngAfterContentInit：当组件的内容投影（\u0026lt;ng-content\u0026gt;）初始化完成后触发。这个钩子在 Angular 投影内容进入组件后调用一次。 ngAfterContentChecked：当 Angular 完成对组件内容投影的变更检测后调用。 ngAfterViewInit：当组件的视图（包括子组件的视图）初始化完成后调用。也就是说，它在视图的所有子组件和模板内容都加载完毕后触发。 ngAfterViewChecked：每次视图（包括子视图）变更检测之后调用。它会在 Angular 每次更新视图之后触发。 ngOnDestroy：当组件销毁之前调用。可以用来执行清理工作，如取消订阅、清理定时器等。 挂载阶段 # 挂载阶段的生命周期函数只在挂载阶段执行一次，数据更新时不再执行。\nconstructor\nAngular 在实例化组件类时执行, 可以用来接收 Angular 注入的服务实例对象。\nexport class ChildComponent { constructor (private test: TestService) { console.log(this.test) // \u0026#34;test\u0026#34; } } ngOnInit\nngOnInit 会在组件的输入属性被绑定之后被调用，适合在组件加载时执行需要的初始化工作。\n\u0026lt;app-child name=\u0026#34;张三\u0026#34;\u0026gt;\u0026lt;/app-child\u0026gt; export class ChildComponent implements OnInit { @Input(\u0026#34;name\u0026#34;) name: string = \u0026#34;\u0026#34; ngOnInit() { console.log(this.name) // \u0026#34;张三\u0026#34; } } ngAfterContentInit\n组件的内容投影（\u0026lt;ng-content\u0026gt;）初始化完成后触发。这个钩子在 Angular 投影内容进入组件后调用一次。适用于当你需要在内容投影完成后执行某些操作时。\n\u0026lt;app-child\u0026gt; \u0026lt;div #box\u0026gt;Hello Angular\u0026lt;/div\u0026gt; \u0026lt;/app-child\u0026gt; export class ChildComponent implements AfterContentInit { @ContentChild(\u0026#34;box\u0026#34;) box: ElementRef\u0026lt;HTMLDivElement\u0026gt; | undefined ngAfterContentInit() { console.log(this.box) // \u0026lt;div\u0026gt;Hello Angular\u0026lt;/div\u0026gt; } } ngAfterViewInit\n当组件的视图（包括子组件的视图）初始化完成后调用。也就是说，它在视图的所有子组件和模板内容都加载完毕后触发。适用于你需要在组件视图完全初始化之后执行某些操作的场景。\n\u0026lt;!-- app-child 组件模板 --\u0026gt; \u0026lt;p #p\u0026gt;app-child works\u0026lt;/p\u0026gt; export class ChildComponent implements AfterViewInit { @ViewChild(\u0026#34;p\u0026#34;) p: ElementRef\u0026lt;HTMLParagraphElement\u0026gt; | undefined ngAfterViewInit () { console.log(this.p) // \u0026lt;p\u0026gt;app-child works\u0026lt;/p\u0026gt; } } 更新阶段 # ngOnChanges\n当输入属性值发生变化时执行，初始设置时也会执行一次，顺序优于 ngOnInit。 不论多少输入属性同时变化，钩子函数只会执行一次，变化的值会同时存储在参数中。 参数接收一个 SimpleChanges 对象，包含了所有已变更的输入属性的当前值和上一个值。 对于基本数据类型来说, 只要值发生变化就可以被检测到。 对于引用数据类型来说, 可以检测从一个对象变成另一个对象（引用地址发生了改变）, 但是检测不到同一个对象中属性值的变化，但是不影响组件模板更新数据。 基本数据类型值变化：\n\u0026lt;app-child [name]=\u0026#34;name\u0026#34; [age]=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/app-child\u0026gt; \u0026lt;button (click)=\u0026#34;change()\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt; export class AppComponent { name: string = \u0026#34;张三\u0026#34;; age: number = 20 change() { this.name = \u0026#34;李四\u0026#34; this.age = 30 } } export class ChildComponent implements OnChanges { @Input(\u0026#34;name\u0026#34;) name: string = \u0026#34;\u0026#34; @Input(\u0026#34;age\u0026#34;) age: number = 0 ngOnChanges(changes: SimpleChanges) { console.log(\u0026#34;基本数据类型值变化可以被检测到\u0026#34;) if (changes[\u0026#39;name\u0026#39;]) { const currentValue = changes[\u0026#39;name\u0026#39;].currentValue; const previousValue = changes[\u0026#39;name\u0026#39;].previousValue; const firstChange = changes[\u0026#39;name\u0026#39;].firstChange; console.log(`Name changed from ${previousValue} to ${currentValue}`); if (firstChange) { console.log(\u0026#39;This is the first change\u0026#39;); } } } } 引用数据类型变化：\n\u0026lt;app-child [person]=\u0026#34;person\u0026#34;\u0026gt;\u0026lt;/app-child\u0026gt; \u0026lt;button (click)=\u0026#34;change()\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt; export class AppComponent { person = { name: \u0026#34;张三\u0026#34;, age: 20 } change() { this.person = { name: \u0026#34;李四\u0026#34;, age: 30 } } } export class ChildComponent implements OnChanges { @Input(\u0026#34;person\u0026#34;) person = { name: \u0026#34;\u0026#34;, age: 0 } ngOnChanges(changes: SimpleChanges) { console.log(\u0026#34;对于引用数据类型, 只能检测到引用地址发生变化, 对象属性变化不能被检测到\u0026#34;) } } ngDoCheck：在每次 Angular 检查组件变化时被调用。它比 ngOnChanges 更加底层，允许自定义检测逻辑。主要用于调试，只要输入属性发生变化，不论是基本数据类型还是引用数据类型还是引用数据类型中的属性变化，都会执行。\nngAfterContentChecked：当 Angular 完成对组件内容投影的变更检测后调用。适用于检测投影内容的变化。\nngAfterViewChecked：每次视图（包括子视图）变更检测之后调用。它会在 Angular 每次更新视图之后触发。用于在视图检查之后执行一些操作，如处理视图上的 DOM 操作。\n卸载阶段 # ngOnDestroy\n当组件被销毁之前调用, 用于清理操作。\nexport class HomeComponent implements OnDestroy { ngOnDestroy() { console.log(\u0026#34;组件被卸载\u0026#34;) } } "},{"id":12,"href":"/frontend-learn/docs/html/04_animation/","title":"过渡和动画","section":"HTML 和 CSS","content":" 概述 # 页面中元素的变化，按照变化发起的逻辑可以分为触发型和自动型。\n让元素发生变化，有三种方式：\nCSS：适合简单的变化效果， CSS+JS：稍微复杂的变化效果，需要配合一下交互的 JS：类似在 canvas 元素上进行 2D 或者 3D 图像绘制的 元素变化的主要的属性：\n位置 尺寸 缩放，和尺寸类似，但是会带动元素整体，包裹内部元素进行缩放。 旋转 透明度 投影 颜色 边框 过渡效果 # 将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。\n过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。\n示例：\ntransition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：\ntransition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡缓动曲线。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义，贝塞尔曲线。可以使用一下工具来得到换动曲线： 浏览器开发者工具的 cubic-bezier 工具。 cubic-bezier easings steps，步数 transition-delay：过渡延迟时间。 steps # steps(count, start|end) 是一个特殊的时间函数，它和其他关键字 linear 等最大的区别就是，它不是一个连贯的变化，是一步一步的硬切换。\n例如 steps(3, start|end)，设置了 3 步，也就是会有 4 个状态，如下图：\n第一步切换由初始状态到过程状态1。 第二步由过程状态1到过程状态2。 第二步由过程状态2到目标状态。 整个变化过程分为了三个时间段，start 和 end 表示的转台切换是在时间段的开始还是时间段的结束。\n例如 steps(3, start)，就表示时间段一开始，就切换状态，以上图为例，第一个时间段一开始，直接从初始状态就切换到了过程状态1，然后等第一段时间走完，第二段时间开始，过程状态1直接切换到过程状态2，依次类推。\n如果是 steps(3, end)，就表示时间段结束，才切换状态，以上图为例，第一个时间段走完，才从初始状态切换到过程状态1，然后等第二段时间走完，过程状态1切换到过程状态2，依次类推。\nstep-start 等价于 steps(1, start)。 step-end 等价于 steps(1, end)。 steps 在动画效果中用的更多一点。\n动画效果 # 动画要先用 @keyframes 去定义好变化的过程，再去应用到某个元素。\n@keyframes {动画名称} 用来设置关键帧，动画的中间过程会被补全。\n只有两个状态时，使用 from 和 to，from 是动画开始时的状态，to 是动画结束时的状态。 多个状态时，使用百分比，0% 是动画开始时的状态，100% 是动画结束时的状态。更多中间状态用 10%，20%，25% 等。 定义好变化的过程，再用 animation 去应用到某个元素：animation 是一个复合属性，默认值 none 0 ease 0 1 normal none running。\nanimation 也可以分开设置：\nanimation-name：定义动画名称，要和 @keyframes 定义的名称一致。 animation-duration：动画时间。animation-duration 属性是必须的，否则时长为 0，就不会播放动画了。 animation-delay：延迟时间。 animation-timing-function：动画速度，默认是 ease。 ease 先慢后快。 linear 线性。 steps() 步数。 cubic-bezier() 自定义。可以在浏览器的 cubic-bezier 工具中修改。 animation-iteration-count 迭代次数，infinite 表示无限。 infinite 无限次。 n 表示 n 次。 animation-direction：方向，默认是 normal，alternate 表示往返动画。 normal 默认值，正常播放。 reverse 反向播放。 alternate 往返动画。 alternate-reverse 反向往返动画。 animation-fill-mode：最后填充模式，也就是动画结束时，要应用到元素的样式。默认值是 none。 none 不填充。动画播放完以后回到原始的样式。 forwards 应用动画结束时最后一帧的样式。 backwards 应用动画结束时第一帧的样式。 both 遵循 forwards 和 backwards 的规则，从而在两个方向上扩展动画属性。 animation-play-state：动画状态，默认值是 running。 running 正在播放。 paused 暂停。 示例：\n#div1 { /*3 次动画*/ animation-name: demo1; animation-duration: 2s; animation-timing-function: ease-in-out; /*animation: demo1 2s infinite alternate; 无限次的往返动画*/ } @keyframes demo1 { from { transform: translateX(0px); } to { transform: translateX(500px); } } @keyframes demo2 { 0% { transform: translateX(0px); background: red; } 20% { transform: translateX(500px); background: blue; } 70% { transform: translateX(500px); background: green; /* 时间函数是可以设置在单独的一段中，只会影响这一段的变化 */ animation-timing-function: linear; } 100% { transform: translateX(500px); background: yellow; } } 过渡和动画的区别 # 过渡的优点在于简单易用，但是它有几个很大的局限：\n需要事件触发，所以没法在网页加载时自动发生。 是一次性的，不能重复发生，除非一再触发。 只能定义两个状态，开始状态和结束状态，不能定义中间状态。 一条过渡规则，只能定义一个属性的变化，不能涉及多个属性。 动画通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果，可以解决过渡的不足。\n转换 # 2D 转换 # 2D 转换有 2 个轴, x，y。\n平移：transform: translate(x, y)，x 和 y 可以分开设置（transform: translateX(200px) transform: translateY(100px)） 旋转：transform: rotate(x)，transform: rotate(30deg) 顺时针旋转 30 度，负数就是逆时针旋转。 3D 转换 # 3D 转换实现 3D 立体效果，有 3 个轴, x，y，z。\n透视点：眼睛与屏幕之间的距离。perspective （perspective: 1000px）意思是距离屏幕 1000 像素点的距离（一般在 \u0026lt;body\u0026gt; 上设置透视点）。 透视点的位置默认是屏幕的正中央。 平移：transform: translate3d(x, y, z)，也可以分开设置，3D 比 2D 多了一个 translateZ(100px)。 旋转：transform: rotate3d(x, y,z, 30deg) 绕着 x，y，z 确定的轴旋转 30 度，rotateX(45deg) 绕着 X 轴旋转 45 度。rotateY() 绕着 Y 轴旋转。rotateZ() 绕着 Z 轴旋转。 放大和缩小： 放大：transform: scale(3) 放大 3 倍，transform: scale(0.5, 2) 表示水平缩小到 0.5 倍、垂直放大 2 倍。也可以分别设置 transform: scaleX(3) 水平放大 3 倍。scaleY 垂直缩放。 倾斜：transform: skew(15deg, 0deg) 基于 X 轴倾斜 15 度，Y 轴 0 度。值可以为负数。 transform-style: preserve-3d：可以渲染出一些在三维空间中的效果。 transform-origin：设置元素变换的中心点。 transform-box：变换中心点可设置的区域。 perspective-origin：可以修改透视点的位置，例如 perspective-origin: left buttom 将透视点的位置改为左下。 "},{"id":13,"href":"/frontend-learn/docs/html/05_other/","title":"其他属性","section":"HTML 和 CSS","content":" 渐变 # 线性渐变 # 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)\n示例：\n/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 # 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。\n/* 基本的径向渐变 */ /* 默认情况下，渐变的中心点是 50% 50% 的位置 */ /* 椭圆 */ radial-gradient(red, blue); 滤镜属性 # 滤镜属性有两个，可以用来实现毛玻璃的效果：\nfilter：为元素本身设置滤镜效果，包括元素背后的区域。 backdrop-filter：只为元素背后的区域设置滤镜效果。 滤镜属性支持的值：\nblur() 设置元素的模糊度，默认是 0px。 例如：filter: blur(20px), blur() 中的值越大越模糊。 contrast() 对比度，正常是 100% 可以写数字，例如：filter: contrast(1000%) 和 filter: contrast(10) 是一个意思。 grayscale() 灰度，正常是 0%，也可以写数字。例如：filter: grayscale(100%)。 hue-rotate() 色相旋转，正常是 0deg 可以写数字，例如：filter: hue-rotate(45deg)。 drop-shadow 投影效果，例如：filter: drop-shadow(16px 16px 20px blue)。 sepia() 褐色，正常是 0% 可以写数字。例如：filter: sepia(100%) 。 brightness() 亮度，正常亮度 100% 可以写数字，例如：filter: brightness(100%) 。如果需要过度曝光的效果可以 brightness(500%)。 saturate() 饱和度，正常是 100% 可以写数字，例如：filter: saturate(1000%)。 invert() 色相反转，底片效果，正常是 0 可以写数字，filter: invert(100%)。 多个属性组合：filter: blur(20px) brightness(100%)。\n滤镜属性是比较耗费性能的。\n滚动属性 # overflow 属性用于在内容超出容器时，如何处理内容的显示。\n容器必须有一个确定的高度或者宽度，overflow 才会生效。\noverflow 也可以分别设置 X 轴 overflow-x 和 Y 轴 overflow-y。\ndiv { overflow: hidden; /* overflow-x: hidden; overflow-y: hidden; */ } div { overflow: auto hidden; /* overflow-x: auto; overflow-y: hidden; */ } 常用的值：\nvisible：默认值，不会出现滚动条，溢出内容会直接显示在容器外部。 hidden：不会出现滚动条，溢出内容会被裁剪，超出容器的部分不可见。 scroll：显示滚动条，超出容器的内容，可以滚动滚动条来显示。 auto：和 scroll 基本一样。在内容有溢出时才显示滚动条，没有溢出则不显示滚动条。 overlay：和 auto 差不多，不同的是 auto 显示的滚动条会在容器内占据一个位置，会导致内容发生位移。overlay 则是会覆盖在容器右侧，不会占据位置 background-attachment # 滚动条的样式 # 主要涉及以下几个伪元素属性，-webkit 表示只对 webkit 内核浏览器有效。\n::-webkit-scrollbar：设置滚动条的整体样式，可以设置尺寸等。必须要设置宽高，否则不生效。 ::-webkit-scrollbar-button：滚动条两端的按钮（上下箭头）。不设置则不出现。 ::-webkit-scrollbar-thumb：滚动条上的滚动滑块。必须要设置，否则不会出现滑块。 ::-webkit-scrollbar-track：滚动条轨道。不设置则不出现轨道。 ::-webkit-scrollbar-track-piece：滚动条没有滑块的轨道部分。 ::-webkit-scrollbar-corner：当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。 示例：\n/* 滚动条所在容器 */ .scroll-container { margin: 10px; width: 200px; height: 250px; overflow: overlay; background-color: #fff; } /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/ .scroll-container::-webkit-scrollbar { width:16px; height:16px; background-color:#F5F5F5; } /*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; } 伪类属性 # 滚动条的样式还可以搭配一些伪类属性来进行优化：\n:horizontal：适用于任何水平方向上的滚动条。 :vertical：适用于任何垂直方向的滚动条。\n/*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; \u0026amp;:horizontal { background-color: blue; } } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; \u0026amp;:vertical { background-color: red; } } 换行与溢出 # 相关属性：\nwhite-space：文本是否换行，空白符（换行符、空格、制表符等）的处理。 word-break，overflow-wrap：断句/断单词的换行处理，主要针对 non-CJK (CJK 指中文/日文/韩文) 的文本。 text-overflow：文字溢出的处理。 white-space # normal：默认值，文本中的连续空白符会被合并。根据填充的盒子宽度来决定换行。 nowrap：不换行，文本中的连续空白符会被合并。 pre：文本之间的空白符会被保留。只有遇到换行符或者 \u0026lt;br\u0026gt; 时才会换行。其行为方式类似 HTML 中的 \u0026lt;pre\u0026gt; 标签。 pre-wrap：换行，并且文本之间的空白符会被保留。遇到换行符或者 \u0026lt;br\u0026gt; 时换行，或者根据填充的盒子宽度来决定换行。 word-break # normal：默认值。 break-all：最常用的值，可在任意字符间断行，效果就是换行位置都会被填满，如果需要单词保持完整性，那就不要使用。 overflow-wrap # 和 word-break 一样也是用来截断单词的，不一样的是 overflow-wrap 侧重于处理超出元素宽度的单词。\nnormal：默认值。换行符将出现在空格和连字符处。 break-word：最常用的值。如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 text-overflow # 指定当文本溢出时，应该如何显示。可以设置溢出后，文本被剪切、显示省略号 (...) 或显示自定义字符串（不是所有浏览器都支持）。\nclip：剪切文本。 ellipsis：显示省略符号 ... 来代表被修剪的文本。 string：使用给定的字符串来代表被修剪的文本。 text-overflow 需要配合以下两个属性使用：\nwhite-space: nowrap; 不换行 overflow: hidden 不显示滚动条。 文本的水平对齐和垂直对齐 # 水平对齐 # text-align：默认值 left。 left：左对齐。 right：右对齐。 center：居中对齐。 justify：两端对齐。 start：如果内容方向是从左到右的话，左对齐。反之则右对齐。 end：如果内容方向是从左到右的话，右对齐，反之则左对齐。 只有块级元素内的文字或者行内元素才生效。\n垂直对齐 # 垂直对齐，是设置文字在一行内的空间中的垂直对齐。\nvertical-align：默认值 baseline。 baseline：默认值，基线对齐。 top：整行的顶部对齐。 middle：垂直居中。 bottom：整行的底部对齐。 text-top：与父元素的字体的顶部对齐。 text-bottom：与父元素的字体的底部对齐。 只有表格元素或者行内元素才生效。\nclientHeight、offsetHeight、scrollHeight # 每个元素都具有以和元素高度、滚动、位置相关的属性。这些属性通常用于计算元素的实际高度，尤其在涉及到滚动的情况下。\nclientWidth、clientHeight、clientLeft、clientTop # clientWidth：只读属性，表示元素的内部宽度，单位 px，包括 padding 但不包括 border margin 和垂直滚动条的宽度。对于 inline 的元素这个属性一直是 0。 clientHeight：只读属性，表示元素内容的高度，单位 px，包括 padding 但不包括 border margin 和水平滚动条的高度。对于 inline 的元素这个属性一直是 0。 clientLeft：只读属性，表示元素左边框的宽度，单位 px，不包括左外边距和左内边距。 clientTop：只读属性，表示元素顶部边框的宽度，单位 px，不包括顶部外边距或内边距。\noffsetWidth、offsetHeight、offsetLeft、offsetTop # offsetWidth：只读属性，表示元素的布局宽度，单位 px，包括 padding border margin 和垂直滚动条的宽度。 offsetHeight：只读属性，表示元素内容的高度，单位 px，包括 padding border margin 和水平滚动条的高度。 offsetLeft：只读属性，表示元素左上角相对于 offsetParent 左边界的偏移，单位 px，如果元素被隐藏则是 0。 offsetTop：只读属性，表示元素相对于 offsetParent 元素的顶部内边距的距离，单位 px，如果元素被隐藏则是 0。\nscrollWidth、scrollHeight、scrollLeft、scrollTop # scrollWidth：只读属性，表示元素内容的总宽度，包括由于溢出而被隐藏的部分。没有水平滚动条的情况下，scrollWidth 值与元素视图填充所有内容所需要的最小值 clientWidth 相同。 scrollHeight：只读属性，表示元素内容的总高度，包括由于溢出而被隐藏的部分。没有垂直滚动条的情况下，scrollHeight 的值与元素视图填充所有内容所需要的最小值 clientHeight 相同。 scrollLeft：可读可写，代表在有滚动条时，滚动条向右（向左）滚动的距离也就是元素左边（右边）被遮住部分的宽度。在没有滚动条时 scrollLeft = 0。 scrollTop：可读可写，代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时 scrollTop = 0。\n应用 # 判断是否有垂直滚动条 # 如果 scrollHeight = clientHeight 则表示没有垂直滚动条。\n判断是否有水平滚动条 # 如果 scrollWidth = clientWidth 则表示没有水平滚动条。\n判断滚动区域是否滚动到底 # scrollTop + clientHeight \u0026gt;= scrollHeigh，scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的，因此确定滚动区域是否滚动到底的唯一方法是查看滚动量是否足够接近某个阈值：\nMath.abs(element.scrollHeight - element.clientHeight - element.scrollTop) \u0026lt; 1 tabindex # tabindex 全局属性，表示元素是否可以被聚焦，以及是否能用 Tab 键选中。MDN Web Docs (tabindex)。\n支持聚焦的元素 # \u0026lt;button\u0026gt; 有 herf 属性的 \u0026lt;a\u0026gt; 有 herf 属性的 \u0026lt;link\u0026gt; type 不是 hidden 的 \u0026lt;input\u0026gt; \u0026lt;select\u0026gt; \u0026lt;textarea\u0026gt; 默认情况下，在使用 Tab 键聚焦元素时，聚焦顺序等于元素在源当前 DOM 中的先后顺序。\ntabindex 的值 # tabindex=负值 (例如 tabindex=\u0026quot;-1\u0026quot;)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用 JS 做页面小组件内部键盘导航的时候非常有用。 tabindex=\u0026quot;0\u0026quot;，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的 DOM 结构来决定的。 tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序是 tabindex 的数值越大顺序越靠后。如果多个元素拥有相同的 tabindex，它们的相对顺序按照他们在当前 DOM 中的先后顺序决定。tabindex=0 的顺序会被放到最后。 例如：1,1,2,2,2,2,3,4,5,0,0,0 ...。tabindex 是非法值、或者没有 tabindex 值的元素，也是放到最后。 div 默认情况下是不会被聚焦的，就可以添加属性 tabindex，让 div 元素可以被聚焦。如果在 div 上设置了 tabindex 属性，它的子元素内容不能使用箭头键来滚动，除非在内容上也设置 tabindex。\nuser-select # user-select：设置文本是否可以被选中。默认值 auto。 auto：可以被选中。 none：不能被选中。 "},{"id":14,"href":"/frontend-learn/docs/angular/05_directive/","title":"指令","section":"Angular","content":" 概述 # 指令是 Angular 提供的操作 DOM 的途径。指令分为属性指令和结构指令。\n属性指令：修改现有元素的外观或行为，selector 使用 [] 包裹。\n结构指令：增加、删除 DOM 节点以修改布局，使用 * 作为指令前缀。\n内置指令 # *ngIf # 根据条件渲染 DOM 节点或移除 DOM 节点。\n\u0026lt;div *ngIf=\u0026#34;data.length == 0\u0026#34;\u0026gt;没有更多数据\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;data.length \u0026gt; 0; then dataList else noData\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;ng-template #dataList\u0026gt;课程列表\u0026lt;/ng-template\u0026gt; \u0026lt;ng-template #noData\u0026gt;没有更多数据\u0026lt;/ng-template\u0026gt; [hidden] # 根据条件显示 DOM 节点或隐藏 DOM 节点。\n\u0026lt;div [hidden]=\u0026#34;data.length == 0\u0026#34;\u0026gt;课程列表\u0026lt;/div\u0026gt; \u0026lt;div [hidden]=\u0026#34;data.length \u0026gt; 0\u0026#34;\u0026gt;没有更多数据\u0026lt;/div\u0026gt; *ngFor # 遍历数据生成HTML结构\ninterface List { id: number name: string age: number } list: List[] = [ { id: 1, name: \u0026#34;张三\u0026#34;, age: 20 }, { id: 2, name: \u0026#34;李四\u0026#34;, age: 30 } ] \u0026lt;li *ngFor=\u0026#34; let item of list; let i = index; // 下标 let isEven = even; // 是否是第偶数个元素 let isOdd = odd; // 是否是第奇数个元素 let isFirst = first; // 是否是第一个元素 let isLast = last; // 是否是最后一个元素 \u0026#34; \u0026gt; \u0026lt;/li\u0026gt; trackBy # 在 Angular 中遍历数组时，会用到 ngFor 指令，如果数组中的数据改变了（新数组替换旧数组），Angular 会删除与数据关联的所有 DOM 元素，然后再次创建它们。这意味着将有很多 DOM 操作。\n使用 *ngFor 的 trackBy 属性，Angular 可以仅更改和重新渲染那些已更改的条目，而不是重新加载整个条目列表。\ntrackByItems(index: number, item: Item): number { return item.id; // 只需要返回一个唯一标识就好了 } \u0026lt;div *ngFor=\u0026#34;let item of items; trackBy: trackByItems\u0026#34;\u0026gt; ({{ item.id }}) {{ item.name }} \u0026lt;/div\u0026gt; 使用 trackBy 的好处是自定义返回跟踪结果，以比对上次的跟踪结果，如果不一样，那么就刷新变化的页面实例（减少不必要的 Dom 刷新而带来性能的提升）。\n自定义指令 # 需求：为元素设置默认背景颜色，鼠标移入时的背景颜色以及移出时的背景颜色。\n\u0026lt;div [appHover]=\u0026#34;{ bgColor: \u0026#39;skyblue\u0026#39; }\u0026#34;\u0026gt;Hello Angular\u0026lt;/div\u0026gt; import { AfterViewInit, Directive, ElementRef, HostListener, Input } from \u0026#34;@angular/core\u0026#34; // 接收参的数类型 interface Options { bgColor?: string } @Directive({ selector: \u0026#34;[appHover]\u0026#34; }) export class HoverDirective implements AfterViewInit { // 接收参数 @Input(\u0026#34;appHover\u0026#34;) appHover: Options = {} // 要操作的 DOM 节点 element: HTMLElement // 获取要操作的 DOM 节点 constructor(private elementRef: ElementRef) { this.element = this.elementRef.nativeElement } // 组件模板初始完成后设置元素的背景颜色 ngAfterViewInit() { this.element.style.backgroundColor = this.appHover.bgColor || \u0026#34;skyblue\u0026#34; } // 为元素添加鼠标移入事件 @HostListener(\u0026#34;mouseenter\u0026#34;) enter() { this.element.style.backgroundColor = \u0026#34;pink\u0026#34; } // 为元素添加鼠标移出事件 @HostListener(\u0026#34;mouseleave\u0026#34;) leave() { this.element.style.backgroundColor = \u0026#34;skyblue\u0026#34; } } "},{"id":15,"href":"/frontend-learn/docs/html/06_selector/","title":"CSS 选择器","section":"HTML 和 CSS","content":" 概述 # 通用选择器，* 匹配任何元素。 标签选择器，匹配所有对应标签的元素。 类名选择器，匹配所有 class 属性中包含对应类名的元素。 ID 选择器，匹配 id 属性等于指定值的元素。 属性选择器 [attr]：存在某个属性，无论该属性有没有值 [attr=value]：属性等于特定值 [attr~=value]：属性具有多个空格分隔的值中的一个。例如一个元素具有属性 class=\u0026quot;btn btn-primary\u0026quot;，那么可以被 [class~=\u0026quot;btn\u0026quot;] 所匹配。 [attr|=value]：属性值是特定值或以 {值}- 开始。例如选择器 [title|=\u0026quot;hello\u0026quot;]： 一个元素具有属性 title=\u0026quot;hello\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello-1\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello1\u0026quot;，不可以匹配 [attr^=value]：属性值以特定值开始。例如选择器 [title^=\u0026quot;hello\u0026quot;]： 一个元素具有属性 title=\u0026quot;hello\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello-1\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello1\u0026quot;，可以匹配 [attr$=value]：属性值以特定值结束。例如选择器 [title$=\u0026quot;abc\u0026quot;]： 一个元素具有属性 title=\u0026quot;hello\u0026quot;，不可以匹配 一个元素具有属性 title=\u0026quot;hello-abc\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;helloabc\u0026quot;，可以匹配 [attr*=value]：属性值包含特定值。例如选择器 [title*=\u0026quot;abc\u0026quot;]： 一个元素具有属性 title=\u0026quot;heabcllo\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello-abc\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;helloabc\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;abchello\u0026quot;，可以匹配 组合选择器 # 例如 h1.test[title*=\u0026quot;abc\u0026quot;]，这是一个组合选择器，表示含有 class=test 和符合 [title*=\u0026quot;abc\u0026quot;] 的 h1 标签。\n组合选择器的顺序是可以随意的，但是标签选择器因为没有特定的前缀符号，所以只能放在第一个，例如 .testh1 会被认为是 class=testh1。\n关系选择器 # 选择器 含义 示例 A B 后代选择器 div p { color: #f00; }、#nav li { display: inline; } A \u0026gt; B 直接子元素选择器 div \u0026gt; p { color: #f00; } A + B 相邻兄弟选择器，两个挨着的同级元素 div + p { color: #f00; } A ~ B 通用兄弟选择器，只要是同级的元素，不需要紧挨着 div ~ p { color: #f00; } 多元素选择器 # A,B 多元素选择器，同时匹配所有 A 元素或 B 元素，, 分隔。\n伪类选择器 # 伪类可以简单理解为是一种状态，条件，可以通过伪类选择器再配合一些其他选择器来选中页面当中已经存在的元素。\n常用的伪类选择器：\n链接伪类 link：普通的、未被访问的链接。 visited：用户已访问的链接。 用户行为伪类 :hover：鼠标指针位于其上。 :active：用户正在点击的元素。 :focus：元素获得焦点。 输入表单伪类 :enabled：用户可以编辑的元素。 :disabled：用户无法编辑的元素。 :checked：复选框或单选框被选中。 位置/结构伪类 :first-child：选择其父元素的第一个子元素。 :last-child：选择其父元素的最后一个子元素。 :only-child：选择其父元素的唯一子元素。也就是说这个父元素中只有一个子元素。 :only-of-type：选择其父元素中唯一的某个特定类型的元素。 :first-of-type：选择其父元素中第一个的某个特定类型的元素。与 :first-child 不同，:first-of-type 不关心元素是否是第一个子元素，关注的是是否为第一个该类型的子元素。 :last-of-type：选择其父元素中最后一个的某个特定类型的元素。 :nth-child：选择其父元素中第 n 个子元素。n 可以是一个数字，也可以是一个公式（例如 2n+1）。 :nth-last-child：选择其父元素中倒数第 n 个子元素。 :nth-of-type：选择其父元素中第 n 个特定类型的子元素。 :nth-last-of-type：选择其父元素中倒数第 n 个特定类型的子元素。 其他伪类 :root：根元素。 :empty：没有子元素的元素。 MDN Web Docs (Pseudo-classes)。\n状态伪类 # 状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的。\n状态伪类的顺序很重要，顺序错误可能会导致没有效果。\n例如为链接的不同状态设置样式时，必须按照以下次序规则：\na:hover 必须位于 a:link 和 a:visited 之后，a:active 必须位于 a:hover 之后。\n\u0026lt;!-- 设置四种状态的背景颜色 --\u0026gt; a:link { background-color:#B2FF99; } a:visited { background-color:#FFFF85; } a:hover { background-color:#FF704D; } a:active { background-color:#FF704D; } 结构化伪类 # 结构化伪类是 CSS3 新增的选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，可以减少 class 和 id 属性的定义，使文档结构更简洁。\n例如 :first-child 用来选择父元素的第一个子元素。\n/* 第一个子元素是 p 元素 */ p:first-child { color:blue; } /* 匹配的 p 元素中的第一个 i 元素 */ p \u0026gt; i:first-child { color:blue; } /* 第一个子元素是 p 元素的任意元素中的所有 i 元素 */ p:first-child i { color:blue; } 伪元素选择器 # 伪元素用于创建一些不在 DOM 树中的元素，‌并为其添加样式。‌虽然用户可以看到这些元素，但是这些文本实际上不在 DOM 树中。\n常用的伪元素选择器：\n::before，::after：在一个元素前或后插入一些内容，文字，图片等，‌并添加样式。 ::first-line，::first-letter：可以理解为把元素内的第一行文字或者第一个文字变成一个虚拟元素，‌并添加样式。 ::selection：为选中效果设置样式。 ::placeholder 最新的标准伪元素前面都是 ::，: 不再推荐使用。\nMDN Web Docs (Pseudo-elements)。\n伪元素不能被 JS 获取操控的。\n::before、::after # 可以在元素的内容前面或者后面插入新内容。content 属性是必须设置的，否则不会显示在页面中。可以设置为空字符串。\n/* 在每个 h1 元素前面插入一幅图片 */ h1::before { content:url(smiley.gif); } /* 在每个 h1 元素后面插入一幅图片 */ h1::after { content:url(smiley.gif); } /* 在每个 h1 元素后面插入字符 */ h1::after { content: \u0026#39;222\u0026#39;; } /* 可以为空，但是 content 必须在 */ h1::after { content: \u0026#39;\u0026#39;; } 默认情况下，::before、::after 伪元素都是行内元素，这是宽高是无效的，如果需要设置宽高，可以把元素改为块元素：\nh1::after { content: \u0026#39;222\u0026#39;; display: block; /*display: inline-block;*/ width: 100px; height: 100px; } 优先级 # 特指性等级 # 选择器 特指性等级 通用选择器，关系选择器（+、\u0026gt;、~），否定伪类（:not()） 0 标签选择器和伪元素 1 Class 选择器，属性选择器，伪类 2 ID 选择器 3 内联样式 4 !important 5 特指性等级数值越大，优先级越高。!important 是最高优先级。内联样式仅次于 !important。\n值计算 # 每一段 CSS 语句的选择器都可以对应一个具体的数值，数值越大优先级越高。\n一个 0 级选择器优先级数值 +0。 一个 1 级选择器优先级数值 +1。 一个 2 级选择器优先级数值 +10。 一个 3 级选择器优先级数值 +100。 示例：\n选择器 计算值 * 0 button 1 ul \u0026gt; li 1+0+1 a:not([target=\u0026quot;_blank\u0026quot;]) 1+0+10 #list .item p 100+10+1 "},{"id":16,"href":"/frontend-learn/docs/angular/06_pipe/","title":"管道","section":"Angular","content":" 概述 # 管道的作用是转换组件模板数据。要在 HTML 模板中指定值的转换方式，使用管道操作符 |。\n内置管道 # date 日期格式化 currency 货币格式化 uppercase 转大写 lowercase 转小写 json 格式化 json 数据 {{ date | date: \u0026#34;yyyy-MM-dd\u0026#34; }} {{ num | currency: \u0026#34;￥\u0026#34; }} // ￥{num} 自定义管道 # 需求：指定字符串不能超过规定的长度\n// summary.pipe.ts import { Pipe, PipeTransform } from \u0026#39;@angular/core\u0026#39;; @Pipe({ name: \u0026#39;summary\u0026#39; }); export class SummaryPipe implements PipeTransform { transform (value: string, limit?: number) { if (!value) return null; let actualLimit = (limit) ? limit : 50; return value.substr(0, actualLimit) + \u0026#39;...\u0026#39;; } } // app.module.ts import { SummaryPipe } from \u0026#39;./summary.pipe\u0026#39; @NgModule({ declarations: [ SummaryPipe ] }); 使用管道：\n\u0026lt;div\u0026gt; {{ \u0026#39;test\u0026#39; | summary: 100 }} \u0026lt;/div\u0026gt; 管道传参，使用 : 分隔，如果有多个参数，每个参数之间用 : 分隔（| summary: 100: 200）。\n"},{"id":17,"href":"/frontend-learn/docs/angular/07_di/","title":"依赖注入","section":"Angular","content":" 概述 # 依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的耦合度。\nclass MailService { constructor(APIKEY) {} } class EmailSender { mailService: MailService constructor() { this.mailService = new MailService(\u0026#34;APIKEY1234567890\u0026#34;) } sendMail(mail) { this.mailService.sendMail(mail) } } const emailSender = new EmailSender() emailSender.sendMail(mail) EmailSender 类运行时要依赖 MailService 类。\n以上写法的耦合度太高，代码并不健壮。如果 MailService 类改变了参数的传递方式，在 EmailSender 的构造函数中的写法也要跟着改变。\nclass EmailSender { mailService: MailService constructor(mailService: MailService) { this.mailService = mailService; } } const mailService = new MailService(\u0026#34;APIKEY1234567890\u0026#34;) const emailSender = new EmailSender(mailService) 在实例化 EmailSender 类时将它的依赖项通过 constructor 构造函数参数的形式注入到类的内部，这种写法就是依赖注入。\n通过依赖注入降了代码之间的耦合度，增加了代码的可维护性。MailService 类中代码的更改再也不会影响 EmailSender 类。\nDI 框架 # Angular 有自己的 DI 框架，它将实现依赖注入的过程隐藏了，对于开发者来说只需使用很简单的代码就可以使用复杂的依赖注入功能。\n在 Angular 的 DI 框架中有四个核心概念：\nDependency：组件要依赖的实例对象，服务实例对象 Token：获取服务实例对象的唯一标识 Injector：注入器，负责创建维护服务类的实例对象并向组件中注入服务实例对象。 Provider：配置注入器的对象，指定创建服务实例对象的服务类和获取实例对象的标识。 注入器 Injectors # 注入器负责创建服务类实例对象，并将服务类实例对象注入到需要的组件中。\n创建注入器\nimport { ReflectiveInjector } from \u0026#34;@angular/core\u0026#34; // 服务类 class MailService {} // 创建注入器并传入服务类 // 服务实例对象的标识，默认就是类的名字 const injector = ReflectiveInjector.resolveAndCreate([MailService]) 获取注入器中的服务类实例对象\nconst mailService = injector.get(MailService) 服务实例对象为单例模式，注入器在创建服务实例后会对其进行缓存\nconst mailService1 = injector.get(MailService) const mailService2 = injector.get(MailService) console.log(mailService1 === mailService2) // true 不同的注入器返回不同的服务实例对象\nconst injector = ReflectiveInjector.resolveAndCreate([MailService]) // 创建一个子注入器 const childInjector = injector.resolveAndCreateChild([MailService]) const mailService1 = injector.get(MailService) const mailService2 = childInjector.get(MailService) console.log(mailService1 === mailService2) // false 服务实例的查找类似函数作用域链，当前级别可以找到就使用当前级别，当前级别找不到去父级中查找\nconst injector = ReflectiveInjector.resolveAndCreate([MailService]) // 创建一个子注入器 const childInjector = injector.resolveAndCreateChild([]) const mailService1 = injector.get(MailService) // 由于子级注入器没有 MailService，就会去父级注入器查找，所以这里拿到的 MailService 是属于父级注入器的 const mailService2 = childInjector.get(MailService) console.log(mailService1 === mailService2) // true 提供者 Provider # 配置注入器的对象，通过 Provider 就可以让注入器知道使用哪个类来创建实例对象，访问这个实例对象的唯一标识是什么。\nconst injector = ReflectiveInjector.resolveAndCreate([ { provide: MailService, useClass: MailService } ]) useClass：创建实例对象所使用的类。 provide：Token 访问实例对象的唯一标识 访问依赖对象的标识也可以是字符串类型\nconst injector = ReflectiveInjector.resolveAndCreate([ { provide: \u0026#34;mail\u0026#34;, useClass: MailService } ]) const mailService = injector.get(\u0026#34;mail\u0026#34;) useValue 允许将一个静态值与 DI 令牌关联起来。\nconst injector = ReflectiveInjector.resolveAndCreate([ { provide: \u0026#34;Config\u0026#34;, // Object.freeze 冻结对象，不允许外部修改 useValue: Object.freeze({ APIKEY: \u0026#34;API1234567890\u0026#34;, APISCRET: \u0026#34;500-400-300\u0026#34; }) } ]) const Config = injector.get(\u0026#34;Config\u0026#34;) useFactory 允许通过调用工厂函数创建一个依赖对象。通过这种方式，你可以基于 DI 和应用中可用的信息创建一个动态值。\nconst heroServiceFactory = (logger: Logger, userService: UserService) =\u0026gt; new HeroService(logger, userService.user.isAuthorized); export const heroServiceProvider = { provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService] }; deps 属性是一个提供者令牌数组。 Logger 和 UserService 类作为它们自身类提供者的令牌。 注入器会根据指定的顺序将相应的服务注入到匹配的 heroServiceFactory 工厂函数参数中。\n将实例对象和外部的引用建立了松耦合关系，外部通过标识获取实例对象，只要标识保持不变，内部代码怎么变都不会影响到外部。\nInjectionToken # 可以定义和使用一个 InjectionToken 对象来为非类的依赖选择一个提供者令牌。\n定义了一个类型为 InjectionToken 的 APP_CONFIG：\nimport { InjectionToken } from \u0026#39;@angular/core\u0026#39;; export const APP_CONFIG = new InjectionToken\u0026lt;AppConfig\u0026gt;(\u0026#39;app.config\u0026#39;); 参数类型是可选的 \u0026lt;AppConfig\u0026gt;，'app.config' 是令牌的描述，指明了此令牌的用途。\n接着，在组件中注册这个依赖提供者：\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }] 现在，借助参数装饰器 @Inject()，你可以把这个配置对象注入到构造函数中：\nconstructor(@Inject(APP_CONFIG) config: AppConfig) { this.title = config.title; } "},{"id":18,"href":"/frontend-learn/docs/html/07_responsive/","title":"响应式","section":"HTML 和 CSS","content":" 概述 # 响应式的目的就是让页面在不同的设备，不同的尺寸上能够正常的合理的显示页面内容。\n使用固定尺寸的方式开发页面，就会碰到尺寸不同导致页面显示不完整等问题：\n电脑端浏览器的显示尺寸是可变的。 不同电脑的显示尺寸不同。 移动端设备屏幕小，尺寸多，浏览器的显示尺寸是固定的。 设备的交互方式不同，例如在电脑浏览器中的 :hover 在移动端是不存在的。 响应式的处理核心是基于浏览器的显示区域的宽度，然后来调整页面中元素的布局和尺寸。\n响应式处理，变化的主要是三个方面：\n元素尺寸 文字、图片 布局结构 交互方式 利用单位实现元素的逐步变化 # 实现元素尺寸的逐步变化，最常用的单位就是 % 和 vh、vw 等视窗单位。如果想要元素跟随父元素的尺寸逐步变化，那么可以使用 % 来实现。如果想要元素跟随视窗的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。\nvh 和 vw 相对于浏览器整个显示区域的尺寸，但是对于移动端设备，这个尺寸是包括地址栏和功能栏的。例如，一个元素设置了 100vh 的高度，在移动端浏览器中，元素的一部分是会被地址栏工具栏覆盖的。这个时候就可以使用移动端专用的视窗单位：\nlvh、lvw：l 表示 large。 svh、svw：s 表示 small。 dvh、dvw：d 表示 dynamic。 详细的使用方式：CSS 新 Viewport 视口单位 svh、lvh 和 dvh\n文字大小的逐步变化 # 文字大小的尺寸设置一般是用 px，em 和 rem，这三种单位都可以算是固定单位。因为 em 是相对于父元素的字体大小。rem 是相对于根元素（html 标签）的字体大小。也就是说如果父元素或者根元素的字体大小不变，那么利用 em 或 rem 设置尺寸的元素的内部元素的文字大小肯定也不会变化。\n如果想要文字的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。\n通常，文字是不需要根据页面尺寸变化而变化的。\nFlex 布局和 Grid 布局中元素的逐步变化 # Flex 布局和 Grid 布局中的子元素都是可以缩放的。\nFlex 布局子元素的逐步变化主要是利用两个属性：\nflex-grow：默认值 0。占据剩余空间的份数。flex-grow: 1 就表示占据剩余空间的 1 份。 flex-shrink：默认值 1。当子元素的大小超过了主轴或者侧轴，那么设置了 flex-shrink 的子元素就会自动收缩。如果设置了换行，那么这个属性就没有用了。 Grid 布局子元素的逐步变化主要时在划分网格时，grid-template-columns 和 grid-template-rows 值的设定使用 fr、%、auto 等单位。\n媒体查询 # 媒体查询是 CSS3 中新增的特性，用于根据不同的设备类型，设置不同的样式。\n媒体查询最常用的媒体特征：\nmin-width：大于等于指定宽度。 max-width：小于等于指定宽度。 语法：\n@media not|only mediatype and (mediafeature and|or|not mediafeature) { CSS-Code; } mediatype 媒体类型：\nall：所有设备。 print：用于打印机和打印预览。 screen：用于电脑屏幕，平板电脑，智能手机等。。 speech：应用于屏幕阅读器等发声设备。 only 是为了兼容旧版本的浏览器，如果不写，默认就是 only。\n媒体查询 Level4 已经支持符号 \u0026lt;=，不支持 =\u0026gt;，这种语法更直观，但是由于比较新，老版本的浏览器可能不兼容：\n/* 等同于 @media (max-width: 480px) */ @media (width \u0026lt;= 480px) { } /* 等同于 @media (min-width: 640px) and (max-width: 1200px) */ @media (640px \u0026lt;= width \u0026lt;= 1200px) { h1 { color: #66bbff; } } mediafeature 媒体特征，必须使用 () 包裹起来。\n示例：\n/* 屏幕小于等于 640px 时，改变 h1 的颜色*/ @media screen and (max-width: 640px) { h1 { color: #0055bb; } } /* 屏幕大于等于 1200px 时，改变 h1 的颜色*/ @media screen and (min-width: 1200px) { h1 { color: #264D73; } } /* 屏幕大于等于 640px 并且小于等于 1200px 时，改变 h1 的颜色*/ /* 640px \u0026lt;= width \u0026lt;= 1200px */ @media screen and (min-width: 640px) and (max-width: 1200px) { h1 { color: #66bbff; } } 当多个媒体查询同时匹配时，会按照从上到下的顺序进行匹配。也就是说最后的才会生效。\n移动优先和桌面优先 # 媒体查询设置的 max-width 或者 min-max 这个宽度的分界点，称为断点（breakpoint）。\n常用的断点：\n宽度 480px 一般是手机设备。 宽度 768px 主流平板设备的基本宽度。 宽度 1024px 主要是大尺寸平板设备，或者比较老的笔记本。 宽度 1280px 笔记本电脑。 宽度 1440px 台式机显示器。 一般选择三个断点就够了，通常是 480px、1024px、1440px。\n常用的断点设置的模式有两种，一种是移动优先，一种是桌面优先。\n移动优先 # 移动优先，基础 CSS 样式是为移动端设备编写的，然后使用媒体查询 min-width，逐步的为更大的设备添加样式。\n例如：\n.container { display: grid; grid-template-columns: 1fr; grid-template-rows: 100px; grid-auto-rows: 100px; width: 100%; gap: 10px; } @media (min-width: 480px) { .container { grid-template-columns: 1fr 1fr; } } @media (min-width: 1024px) { .container { grid-template-columns: 1fr 1fr 1fr; } } @media (min-width: 1440px) { .container { grid-template-columns: 1fr 1fr 1fr 1fr; } } 桌面优先 # 桌面优先，基础 CSS 样式是为桌面电脑编写的，然后使用媒体查询 max-width，逐步的为更小的设备添加样式。\n例如：\n.container { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 100px; grid-auto-rows: 100px; width: 100%; gap: 10px; } @media (max-width: 1440px) { .container { grid-template-columns: 1fr 1fr 1fr; } } @media (max-width: 1024px) { .container { grid-template-columns: 1fr 1fr; } } @media (max-width: 480px) { .container { grid-template-columns: 1fr; } } 媒体查询的引入方式 # 通常会把媒体查询的样式 @media 放到单独的 CSS 文件中（queries.css），然后在需要使用媒体查询的地方，使用导入 CSS 文件。\n还可以在 style 标签上使用 media 属性引入媒体查询的 CSS 文件，例如：\n\u0026lt;style media=\u0026#34;(min-device-width: 300px) and (max-device-width: 500px)\u0026#34;\u0026gt; .box { width: 100px; height: 100px; background-color: cadetblue; } \u0026lt;/style\u0026gt; 还有一种方式是在 link 标签上使用 media 属性引入媒体查询的 CSS 文件，例如：\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style1.css\u0026#34; media=\u0026#34;(min-device-width: 300px) and (max-device-width: 500px)\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; 最后，使用 @import 属性引入媒体查询的 CSS 文件，例如：\n@import url=\u0026#34;./queries.css\u0026#34; screen and (max-width: 500px); 容器查询 # 容器查询是一种 CSS 特性，主要根据元素所在的容器父元素的大小来设置样式，而不是整个视窗。\n容器查询包含 container-type、container-name 和 container 三个属性。container 是 container-type 和 container-name 的简写属性。\n例如，定义一个容器：\n.parent { background-color: blueviolet; height: 300px; width: 50vw; container-type: size; } .child { background-color: aqua; width: 100%; height: 100px; } @container (min-width: 320px) { .child { background-color: red; } } 上面的示例，@container 是如何知道要查询哪个容器？\n就是声明了 container-type 这个属性，就意味着告诉浏览器，在该元素上创建一个容器上下文，之后可能要查询此容器。\ncontainer-type 属性有三个可选值：\nnormal：默认值。 size：表示容器查询时，既可以查询高度，也可以查询宽度（@container (max-height: 800px) and (max-width: 800px)） inline-size：表示容器查询时，只能查询文字书向的尺寸，通常元素内部的文字都是水平方向书写的，也就是查询宽度。可以使用 writing-mode 修改文字的书写方向。 container-name 用来指定当前容器所对应的容器查询的名称。例如：\n.parent { background-color: blueviolet; height: 300px; width: 50vw; container-type: size; container-name: my-container; } /* 指定查询名称为 my-container 的容器 */ @container my-container (max-width: 800px) {} 这两个属性组合起来，例如：\n.parent { container: size / my-container; /* * 等价于 * container-type: size; * container-name: my-container; */ } 容器查询的单位 # cqw：容器查询宽度（Container Query Width）占比。1cqw 等于容器宽度的 1%。例如容器宽度是 1000px，则此时 1cqw 对应的计算值就是 10px。 cqh：容器查询高度（Container Query Height）占比。1cqh 等于容器高度的 1%。 cqi：表示容器查询文字书写方向的尺寸（Container Query Inline-Size）占比。这个是逻辑属性单位，默认情况下等同于 cqw。 cqb：容器查询垂直于文字书写方向尺寸（Container Query Block-Size）占比。同上，默认情况下等同于 cqh。 cqmin：容器查询较小尺寸的（Container Query Min）占比。取 cqw 和 cqh 中较小的一个。 cqmax：表示容器查询较大尺寸的（Container Query Min）占比。取 cqw 和 cqh 中较大的一个。 图片的处理 # 图片在做响应式处理时，是比较特殊的。图片一般分两类，矢量图（svg）和位图（jpg、png、gif 等）。矢量图不管放大还是缩小都不会影响显示的。但是位图随着放大超过自身的分辨率，是会变的模糊的。\n所以对于位图，一般会使用 @media 媒体查询来处理。对于不同显示尺寸，准备不同分辨率的图片。\n为什么不准备一个高分辨率的图片，而是准备多个分辨率的图片？\n对于显示尺寸较小的设备，加载大分辨率的图片，图片可能几兆甚至十几兆，这会导致页面加载速度变慢，并且客户端访问时会去服务器下载，耗费大量的服务器带宽。\n如何准备不同分辨率的图片 # 如果一个图片在页面上展示的尺寸是 400px*300px，那么根据屏幕的 DPR 来计算实际需要的图片的分辨率。\n如果屏幕的 DPR 是 1，那么需要的图片分辨率就是 400px*300px。如果屏幕的 DPR 是 2，那么需要的图片分辨率就是 800px*600px。\n需要展示的尺寸（逻辑像素）* 屏幕 DPR =\u0026gt; 需要的图片原始分辨率 图片响应式处理 # 图片响应式处理主要有四种方式\nimg 标签 # \u0026lt;img\u0026gt; 标签引入了 srcset 属性，srcset 属性用来指定多张图片，适应不同像素密度的屏幕。\n示例：\n\u0026lt;img src=\u0026#34;small-640.jpg\u0026#34; srcset=\u0026#34; small-640.jpg 640w, medium-1280.jpg 1280w, large-1920.jpg 1920w\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; 上面的示例 srcset 属性给出了三个图片 URL，适应三种不同的像素密度。图片 URL 空格后面的是像素密度描述符或者宽度描述符（如 640w，w 表示 width。）。\n像素密度描述符，格式是像素密度倍数（DPR） + 字母x。1x 表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度（DPR），选择需要加载的图片。\n如果 srcset 属性中的图片都不满足条件，那么就加载 src 属性指定的默认图片。\n像素密度的适配，是根据整个屏幕的宽度来计算的，这样可能会导致实际使用的图片分辨率会比需要的分辨率大很多。例如：\n\u0026lt;img src=\u0026#34;small-640.jpg\u0026#34; srcset=\u0026#34; small-640.jpg 640w, medium-1280.jpg 1280w, large-1920.jpg 1920w\u0026#34; style=\u0026#34;width: 50%\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; 图片设置了宽度为 50%，实际使用的图片分辨率会大很多。这时就需要使用 sizes 属性。\nsizes 属性列出不同设备的图片显示宽度.\nsizes 属性的值是一个逗号 , 分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图片的显示宽度。\n\u0026lt;img srcset=\u0026#34;foo-160.jpg 160w, foo-320.jpg 320w, foo-640.jpg 640w, foo-1280.jpg 1280w\u0026#34; sizes=\u0026#34;(max-width: 440px) 100vw, (max-width: 900px) 33vw, 254px\u0026#34; src=\u0026#34;foo-1280.jpg\u0026#34;\u0026gt; sizes 属性给出了三种屏幕条件，以及对应的图片显示宽度。宽度不超过 440px 的设备，图片显示宽度为 100%；宽度 441px 到 900px 的设备，图片显示宽度为 33%；宽度 900px 以上的设备，图片显示宽度为 254px。\n浏览器根据当前设备的宽度，从 sizes 属性获得图片的显示宽度，然后从 srcset 属性找出最接近该宽度的图片，进行加载。\n例如当前设备的屏幕宽度是 480px，浏览器从 sizes 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。srcset 属性里面，正好有宽度等于 160px 的图片，于是加载 foo-160.jpg。\npicture、source、img 标签组合 # 如果要同时考虑屏幕尺寸和像素密度的适配，就要用到 \u0026lt;picture\u0026gt; 标签。\n\u0026lt;picture\u0026gt; \u0026lt;source srcset=\u0026#34;homepage-person@desktop.png, homepage-person@desktop-2x.png 2x\u0026#34; media=\u0026#34;(min-width: 990px)\u0026#34;\u0026gt; \u0026lt;source srcset=\u0026#34;homepage-person@tablet.png, homepage-person@tablet-2x.png 2x\u0026#34; media=\u0026#34;(min-width: 750px)\u0026#34;\u0026gt; \u0026lt;img srcset=\u0026#34;homepage-person@mobile.png, homepage-person@mobile-2x.png 2x\u0026#34; alt=\u0026#34;Shopify Merchant, Corrine Anestopoulos\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 浏览器按照 \u0026lt;source\u0026gt; 标签出现的顺序，依次判断当前设备是否满足 media 属性的媒体查询表达式，如果满足就加载 srcset 属性指定的图片文件，并且不再执行后面的 \u0026lt;source\u0026gt; 标签和 \u0026lt;img\u0026gt; 标签。\n\u0026lt;img\u0026gt; 标签是默认情况下加载的图片，用来满足上面所有 \u0026lt;source\u0026gt; 都不匹配的情况。\n\u0026lt;picture\u0026gt; 标签还可以用来选择不同格式的图片。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图片，否则加载 PNG 图片。\n\u0026lt;picture\u0026gt; \u0026lt;source type=\u0026#34;image/svg+xml\u0026#34; srcset=\u0026#34;logo.xml\u0026#34;\u0026gt; \u0026lt;source type=\u0026#34;image/webp\u0026#34; srcset=\u0026#34;logo.webp\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;logo.png\u0026#34; alt=\u0026#34;ACME Corp\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 浏览器按照 \u0026lt;source\u0026gt; 标签出现的顺序，依次检查是否支持 type 属性指定的图片格式，如果支持就加载图片，并且不再检查后面的 \u0026lt;source\u0026gt; 标签了。\nCSS # CSS 媒体查询，CSS 样式只针对背景图片。\n移动端响应式 # 声明视窗的大小：\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\u0026quot;\u0026gt;\nviewport 声明视窗。只适用于移动端。 width=device-width 宽度等于设备宽度。 initial-scale=1 初始化比例是 1。 minimum-scale=1 最小的缩小比例是 1。 maximum-scale=1 最大的放大比例是 1。 user-scalable=no 用户不允许缩放。 物理分辨率和逻辑分辨率 # 屏幕的发展，最初是以像素为单位，像素越多，屏幕尺寸也越大，这是一种物理性的变大。但是物理的变大时有限制的，不能过大，所以后来出现了在同样尺寸下放入更多的像素的技术，例如苹果的 Retina 显示屏（高倍屏），5K 的显示屏分辨率是 5120*2880，而普通屏幕的在同样的尺寸下分辨率是 2560*1440。\n如果我们用高倍屏去显示内容，那么就会出现一个问题，就是内容会变小。\n例如下图，如果按照 1:1 的比例去显示，在普通屏幕上占 6 个像素的图片，放到高倍屏还是占据 6 个像素，按照这个逻辑，同样的内容，在高倍屏上显示差不多就是 1/4。\n那么这显然是不合理的，所以操作系统层面就出现了逻辑分辨率，就是一个虚拟的分辨率。对应屏幕的物理分辨率。逻辑分辨率就是为了让高倍屏和普通屏在显示内容时能显示出一样的大小。\n如下图，如果一张图片占 6 个像素，那么在高倍屏时，操作系统会根据高倍屏的逻辑分辨率，把这张图片放大到 24 个像素，这样就不会出现内容变小的情况。\n设备像素比就是逻辑分辨率的宽度（高度）除以物理分辨率的宽度（高度）。对于移动端设备，设备像素比可能更高。设备像素比可以在浏览器的控制台查看，输入 devicePixelRatio 回车即可。\n移动端适配 # 不同的移动端设备分辨率，尺寸都不同，可以先针对一种设备，以 iphone6 为例，设计好页面的样式之后，设置 content=\u0026quot;width=375,user-scalable=no\u0026quot;，禁止用户缩放，指定宽度为 iphone6 的宽度，那么不同分辨率的设备（移动端）都会自适应这个宽度。\n"},{"id":19,"href":"/frontend-learn/docs/html/08_svg/","title":"SVG","section":"HTML 和 CSS","content":" 概述 # SVG (Scalable Vector Graphics) 可伸缩矢量图形，也即是说不管怎么放大，图形都不会失真。适合在响应式的网站中使用。\n与矢量图相对应的是位图，位图放的比较大的时候就会失真。常见的位图格式如：png、jpg、gif。只要是有图片分辨率的都是位图。位图本质上，它是由一个个像素点组成的。图片文件里保存的是每个像素点的颜色值。所以它一旦放大了之后，相当于让多个像素点显示同一个颜色，这样就会造成模糊的效果。\n矢量图保存的不是每个像素点的颜色值，而是图形的绘制逻辑。所以它本质上是文本文件，体积较小。\nLottieFiles：一个基于 SVG 的开源的动画解决方案，可以直接在网页端，手机端制作动画效果，再导出某种格式的文件。LottieFiles 的 Marketplace 中，有很多的动画效果，可以直接使用。 Rive：基于 Canvas 实现的动画解决方案，大部分动画效果都可以实现，2D，3D。 "},{"id":20,"href":"/frontend-learn/docs/angular/08_service/","title":"服务","section":"Angular","content":" 创建服务 # import { Injectable } from \u0026#39;@angular/core\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class TestService { } 使用：\nexport class AppComponent { // 这里的 TestService 实际上就是获取示例对象的 Token（唯一标识） constructor (private _test: TestService) {} } 服务的作用域 # 使用服务可以轻松实现跨模块跨组件共享数据，这取决于服务的作用域。\n在根注入器中注册服务，所有模块使用同一个服务实例对象。\nimport { Injectable } from \u0026#39;@angular/core\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class CarListService { } 在模块级别注册服务，该模块中的所有组件使用同一个服务实例对象。\n新语法：\nimport { Injectable } from \u0026#39;@angular/core\u0026#39;; import { CarModule } from \u0026#39;./car.module\u0026#39;; @Injectable({ providedIn: CarModule, }) export class CarListService { } 老语法：\nimport { CarListService } from \u0026#39;./car-list.service\u0026#39;; @NgModule({ providers: [CarListService], }) export class CarModule { } 在组件级别注册服务，该组件及其子组件使用同一个服务实例对象。\nimport { Component } from \u0026#39;@angular/core\u0026#39;; import { CarListService } from \u0026#39;../car-list.service.ts\u0026#39; @Component({ selector: \u0026#39;app-car-list\u0026#39;, templateUrl: \u0026#39;./car-list.component.html\u0026#39;, providers: [CarListService] }) "},{"id":21,"href":"/frontend-learn/docs/html/09_chrome/","title":"Chrome 开发者工具","section":"HTML 和 CSS","content":" Chrome 开发者工具 # Chrome 的开发者工具查看元素的样式如下图：\n右侧样式的排序，选择器的优先级高的会在上面。\nuse agent stylesheet 是浏览器给元素的默认样式。 :hov 给元素强制加上某种伪类，使元素显示对应的样式。 :cls 给元素添加 class 切换页面的深色模式：\nComputed 包含盒子模型和元素最终显示出来的样式的值。\n如果在修改一些元素的样式，发现不生效时，就可以在列表中，点击对应属性。它会把这个属性相关的所有设置都列出来。列表中的第一个就是最终生效的那个，下面的就是被覆盖的。\n上面的盒子模型的值都是可以修改的。\nDevice ToolBar # 1：切换移动端模式。 2：添加更多的移动端设备，并且可以添加自定义尺寸的设备。 3：选择自适应模式，设备尺寸可以任意调整。 4：缩放。 5：节流模式，可以模拟网速的快慢，无网络等状态。 6：旋转，模拟屏幕旋转。 媒体查询 # 打开媒体查询工具：\n打开之后，尺寸下面多了一栏，鼠标悬浮上去会显示，当前的宽度是什么设备的尺寸。\n如果设置了媒体查询，会出现对应的一行，鼠标悬浮上去会显示匹配的规则。\n上图中有三条媒体查询的规则：\n.parent { width: 50vh; height: 50vh; background-color: aqua; } @media (min-width: 600px) { .parent { background-color: blueviolet; } } @media (max-width: 1000px) { .parent { background-color: blueviolet; } } @media (min-width: 600px) and (max-width: 1000px) { .parent { background-color:burlywood; } } 当多个媒体查询同时匹配时，会按照从上到下的顺序进行匹配。也就是说最后的才会生效。\nAnimations # Chrome 开发者工具的动画面板，可以查看元素动画效果的细节。\n打开动画面板：\n面板中有三个百分比，选择 10%，动画效果就会变得非常慢，面板中还记录了元素属性发生变化的过程，并且可以手动调节：\n网页截图 # Chrome 提供了网页截图的工具，可以将网页截图保存到本地。打开命令行面板，输入 screenshot 命令，然后回车，会出现四个 screenshot 相关的命令：\ncapture full size screenshot：截图整个页面。 capture node screenshot：截图元素。先使用选择页面元素工具在页面中选择某个需要截图的元素，再使用 capture node screenshot 命令，这个元素就会被截图。 capture screenshot：截图当前页面显示区域。 capture area screenshot：截图选中的区域。类似常见的截图工具，出现一个十字，选中区域截图。 "},{"id":22,"href":"/frontend-learn/docs/angular/09_form/","title":"表单","section":"Angular","content":" 概述 # 在 Angular 中，表单有两种类型，分别为模板驱动表单和响应式表单。\n模板驱动表单 # 概述 # 表单的控制逻辑写在组件模板中，适合简单的表单类型。\n快速上手 # 引入依赖模块 FormsModule\nimport { FormsModule } from \u0026#34;@angular/forms\u0026#34; @NgModule({ imports: [FormsModule], }) export class AppModule {} 将 DOM 表单转换为 ngForm\n\u0026lt;form #f=\u0026#34;ngForm\u0026#34; (submit)=\u0026#34;onSubmit(f)\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; 声明表单字段为 ngModel\n\u0026lt;form #f=\u0026#34;ngForm\u0026#34; (submit)=\u0026#34;onSubmit(f)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; ngModel /\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 获取表单字段值\nimport { NgForm } from \u0026#34;@angular/forms\u0026#34; export class AppComponent { onSubmit(form: NgForm) { console.log(form.value) } } 表单分组\n当你的表单的表单项比较多，可以把相关的表单项分组。\n\u0026lt;form #f=\u0026#34;ngForm\u0026#34; (submit)=\u0026#34;onSubmit(f)\u0026#34;\u0026gt; \u0026lt;div ngModelGroup=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; ngModel /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div ngModelGroup=\u0026#34;contact\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;phone\u0026#34; ngModel /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 分组后，访问表单数据，例如 username，就是 form.user.username。\n表单验证 # required 必填字段 minlength 字段最小长度 maxlength 字段最大长度 pattern 验证正则 例如：pattern=\u0026quot;\\d\u0026quot; 匹配一个数值 \u0026lt;form #f=\u0026#34;ngForm\u0026#34; (submit)=\u0026#34;onSubmit(f)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; ngModel required pattern=\u0026#34;\\d\u0026#34; /\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; export class AppComponent { onSubmit(form: NgForm) { // 查看表单整体是否验证通过 console.log(form.valid) } } \u0026lt;!-- 表单整体未通过验证时禁用提交表单 --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; [disabled]=\u0026#34;f.invalid\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; 在组件模板中显示表单项未通过时的错误信息。\n\u0026lt;form #f=\u0026#34;ngForm\u0026#34; (submit)=\u0026#34;onSubmit(f)\u0026#34;\u0026gt; \u0026lt;input #username=\u0026#34;ngModel\u0026#34; /\u0026gt; \u0026lt;!-- touched 为 true 表示用户操作过该表单项 --\u0026gt; \u0026lt;div *ngIf=\u0026#34;username.touched \u0026amp;\u0026amp; !username.valid \u0026amp;\u0026amp; username.errors\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;username.errors.required\u0026#34;\u0026gt;请填写用户名\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;username.errors.pattern\u0026#34;\u0026gt;不符合正则规则\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; dirty 和 touched 都可以用来判断表单控件是否被用户操作过：\ndirty：如果用户修改了表单控件的值，则该控件的 dirty 状态会被设置为 true。如果控件的值没有被修改，dirty 状态为 false。 touched：如果控件失去焦点（即用户点击过该控件并离开），则控件的 touched 状态会被设置为 true。 指定表单项未通过验证时的样式。\ninput.ng-touched.ng-invalid { border: 2px solid red; } 响应式表单 # 概述 # 表单的控制逻辑写在组件类中，对验证逻辑拥有更多的控制权，适合复杂的表单的类型。\n在响应式表单中，表单字段需要是 FormControl 类的实例，实例对象可以验证表单字段中的值，值是否被修改过等等。\n一组表单字段构成整个表单，整个表单需要是 FormGroup 类的实例，它可以对表单进行整体验证。\nFormControl：表单组中的一个表单项 FormGroup：表单组，表单至少是一个 FormGroup FormArray：用于复杂表单，可以动态添加表单项或表单组，在表单验证时，FormArray 中有一项没通过，那么整体就不会通过。 快速上手 # 引入 ReactiveFormsModule\nimport { ReactiveFormsModule } from \u0026#34;@angular/forms\u0026#34; @NgModule({ imports: [ReactiveFormsModule] }) export class AppModule {} 在组件类中创建 FormGroup 表单控制对象\nimport { FormControl, FormGroup } from \u0026#34;@angular/forms\u0026#34; export class AppComponent { contactForm: FormGroup = new FormGroup({ name: new FormControl(), phone: new FormControl() }) } 使用 formGroup 来绑定一组表单控件，使用 formControlName 来绑定每个表单控件。\n\u0026lt;form [formGroup]=\u0026#34;contactForm\u0026#34; (submit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;phone\u0026#34; /\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 获取表单值\nexport class AppComponent { onSubmit() { console.log(this.contactForm.value) } } 设置表单默认值\ncontactForm: FormGroup = new FormGroup({ name: new FormControl(\u0026#34;默认值\u0026#34;), phone: new FormControl(15888888888) }) 表单分组\ncontactForm: FormGroup = new FormGroup({ fullName: new FormGroup({ firstName: new FormControl(), lastName: new FormControl() }), phone: new FormControl() }) \u0026lt;form [formGroup]=\u0026#34;contactForm\u0026#34; (submit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div formGroupName=\u0026#34;fullName\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;firstName\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;lastName\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;phone\u0026#34; /\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; onSubmit() { // 下面两种方式都可以获取到表单项的值 console.log(this.contactForm.value.name.username) console.log(this.contactForm.get([\u0026#34;name\u0026#34;, \u0026#34;username\u0026#34;])?.value) } formControl 指令用于将一个单独的 FormControl 实例绑定到模板中的表单控件。通常在没有 FormGroup 的情况下使用，适合单独处理一个控件，而不需要嵌套在表单组中。\n\u0026lt;input [formControl]=\u0026#34;nameControl\u0026#34; /\u0026gt; import { Component } from \u0026#39;@angular/core\u0026#39;; import { FormControl } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-my-form\u0026#39;, templateUrl: \u0026#39;./my-form.component.html\u0026#39;, }) export class MyFormComponent { nameControl = new FormControl(\u0026#39;\u0026#39;); // 创建 FormControl 实例 } formControlName 指令用于将一个 FormControl 实例绑定到 FormGroup 中的表单控件。这个指令只能用于响应式表单（ReactiveForms），并且必须与 FormGroup 一起使用。\n\u0026lt;form [formGroup]=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;input formControlName=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; import { Component } from \u0026#39;@angular/core\u0026#39;; import { FormControl, FormGroup } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-my-form\u0026#39;, templateUrl: \u0026#39;./my-form.component.html\u0026#39;, }) export class MyFormComponent { form = new FormGroup({ name: new FormControl(\u0026#39;\u0026#39;), // 将 \u0026#39;name\u0026#39; 字段添加到 FormGroup 中 }); } FormArray # FormArray 是一种特殊类型的 FormGroup，用于管理一组表单控件，通常用于处理动态数量的控件，它允许你动态地添加、移除或更新表单控件。例如，当你需要让用户添加多个相似项（如动态添加多个电子邮件地址、电话号码、或者一组购物车项目）时，FormArray 是理想的选择。\n例如实现一个表单，允许用户输入多个电子邮件地址：\nimport { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup, FormArray, Validators } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-dynamic-form\u0026#39;, templateUrl: \u0026#39;./dynamic-form.component.html\u0026#39; }) export class DynamicFormComponent implements OnInit { emailForm: FormGroup; constructor(private fb: FormBuilder) {} ngOnInit(): void { this.emailForm = this.fb.group({ emails: this.fb.array([this.createEmailControl()]) }); } // 创建单个电子邮件控件 createEmailControl(): FormGroup { return this.fb.group({ email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]] }); } // 获取 FormArray get emailControls(): FormArray { return this.emailForm.get(\u0026#39;emails\u0026#39;) as FormArray; } // 添加新的电子邮件控件 addEmail() { this.emailControls.push(this.createEmailControl()); } // 删除指定索引的电子邮件控件 removeEmail(index: number) { this.emailControls.removeAt(index); } // 提交表单数据 onSubmit() { if (this.emailForm.valid) { console.log(this.emailForm.value); } else { console.log(\u0026#39;Form is invalid\u0026#39;); } } } emailForm 是一个包含 emails 的表单组，emails 是一个 FormArray。 createEmailControl() 是一个方法，用来创建一个带有电子邮件验证的 FormGroup。 emailControls 是一个 getter，用来获取 FormArray。 addEmail() 方法用于动态添加新的电子邮件控件到 FormArray。 removeEmail(index) 方法用于删除指定索引的控件。\n\u0026lt;form [formGroup]=\u0026#34;emailForm\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div formArrayName=\u0026#34;emails\u0026#34;\u0026gt; \u0026lt;div *ngFor=\u0026#34;let email of emailControls.controls; let i = index\u0026#34; [formGroupName]=\u0026#34;i\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email{{ i }}\u0026#34;\u0026gt;Email {{ i + 1 }}:\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;email{{ i }}\u0026#34; formControlName=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;removeEmail(i)\u0026#34;\u0026gt;Remove\u0026lt;/button\u0026gt; \u0026lt;div *ngIf=\u0026#34;email.get(\u0026#39;email\u0026#39;).invalid \u0026amp;\u0026amp; email.get(\u0026#39;email\u0026#39;).touched\u0026#34;\u0026gt; \u0026lt;small *ngIf=\u0026#34;email.get(\u0026#39;email\u0026#39;).hasError(\u0026#39;required\u0026#39;)\u0026#34;\u0026gt;Email is required.\u0026lt;/small\u0026gt; \u0026lt;small *ngIf=\u0026#34;email.get(\u0026#39;email\u0026#39;).hasError(\u0026#39;email\u0026#39;)\u0026#34;\u0026gt;Invalid email format.\u0026lt;/small\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;addEmail()\u0026#34;\u0026gt;Add Email\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; [disabled]=\u0026#34;emailForm.invalid\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; formArrayName=\u0026quot;emails\u0026quot;：将 FormArray 与模板中的对应部分绑定。 *ngFor：遍历 FormArray 中的每个表单控件。 formControlName=\u0026quot;email\u0026quot;：为每个表单控件（电子邮件输入框）绑定一个 FormControl。 addEmail()：点击 \u0026ldquo;Add Email\u0026rdquo; 按钮时，调用 addEmail() 方法来向表单中添加一个新的电子邮件输入框。 removeEmail(i)：点击 \u0026ldquo;Remove\u0026rdquo; 按钮时，调用 removeEmail() 方法来从表单中删除指定的电子邮件输入框。 内置表单验证器 # 使用内置验证器提供的验证规则验证表单字段\nimport { FormControl, FormGroup, Validators } from \u0026#34;@angular/forms\u0026#34; contactForm: FormGroup = new FormGroup({ name: new FormControl(\u0026#34;默认值\u0026#34;, [ Validators.required, Validators.minLength(2) ]) }) 获取整体表单是否验证通过\nonSubmit() { console.log(this.contactForm.valid) } \u0026lt;!-- 表单整体未验证通过时禁用表单按钮 --\u0026gt; \u0026lt;button [disabled]=\u0026#34;contactForm.invalid\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; 在组件模板中显示为验证通过时的错误信息\nget name() { return this.contactForm.get(\u0026#34;name\u0026#34;)! } \u0026lt;form [formGroup]=\u0026#34;contactForm\u0026#34; (submit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; formControlName=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;div *ngIf=\u0026#34;name.touched \u0026amp;\u0026amp; name.invalid \u0026amp;\u0026amp; name.errors\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;name.errors.required\u0026#34;\u0026gt;请填写姓名\u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;name.errors.maxlength\u0026#34;\u0026gt; 姓名长度不能大于 {{ name.errors.maxlength.requiredLength }} 实际填写长度为 {{ name.errors.maxlength.actualLength }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 自定义同步表单验证器 # 自定义验证器的类型是 TypeScript 类 类中包含具体的验证方法，验证方法必须为静态方法 验证方法有一个参数 control，类型为 AbstractControl。其实就是 FormControl 类的实例对象的类型 如果验证成功，返回 null 如果验证失败，返回对象，对象中的属性即为验证标识，值为 true，标识该项验证失败 验证方法的返回值为 ValidationErrors | null import { AbstractControl, ValidationErrors } from \u0026#34;@angular/forms\u0026#34; export class NameValidators { // 字段值中不能包含空格 static cannotContainSpace(control: AbstractControl): ValidationErrors | null { // 验证未通过 if (/\\s/.test(control.value)) return { cannotContainSpace: true } // 验证通过 return null } } import { NameValidators } from \u0026#34;./Name.validators\u0026#34; contactForm: FormGroup = new FormGroup({ name: new FormControl(\u0026#34;\u0026#34;, [ Validators.required, NameValidators.cannotContainSpace ]) }) \u0026lt;div *ngIf=\u0026#34;name.touched \u0026amp;\u0026amp; name.invalid \u0026amp;\u0026amp; name.errors\u0026#34;\u0026gt; \u0026lt;div *ngIf=\u0026#34;name.errors.cannotContainSpace\u0026#34;\u0026gt;姓名中不能包含空格\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 自定义异步表单验证器 # 异步验证器函数：\nimport { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; import { Observable, of } from \u0026#39;rxjs\u0026#39;; import { debounceTime, map, catchError, switchMap, take } from \u0026#39;rxjs/operators\u0026#39;; import { AbstractControl, AsyncValidatorFn, ValidationErrors } from \u0026#39;@angular/forms\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class EmailValidatorService { constructor(private http: HttpClient) {} // 异步验证器：检查邮箱是否已注册 emailExistsValidator(): AsyncValidatorFn { return (control: AbstractControl): Observable\u0026lt;ValidationErrors | null\u0026gt; =\u0026gt; { if (!control.value) { return of(null); // 如果控件值为空，不做验证 } // 返回 Observable，模拟 HTTP 请求 return this.http.get\u0026lt;any\u0026gt;(`/api/check-email?email=${control.value}`).pipe( debounceTime(500), // 防止发送过多请求 map(response =\u0026gt; { // 假设 response 存在 `exists` 字段，表示邮箱是否已经存在 return response.exists ? { emailExists: true } : null; }), catchError(() =\u0026gt; of(null)) // 如果发生错误（如网络请求失败），返回 null ); }; } } AsyncValidatorFn：这是异步验证器的类型，它返回一个 Observable 或 Promise，并且必须解析为 ValidationErrors（验证失败时）或 null（验证通过）。 debounceTime：这是防止发送过多请求的技巧，尤其是在用户输入过程中。通常，在输入停止一段时间后再发起验证请求。 catchError：如果网络请求失败或出现错误，返回 null 表示验证成功。 在组件中使用异步验证器：\nimport { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup, Validators } from \u0026#39;@angular/forms\u0026#39;; import { EmailValidatorService } from \u0026#39;./email-validator.service\u0026#39;; @Component({ selector: \u0026#39;app-user-form\u0026#39;, templateUrl: \u0026#39;./user-form.component.html\u0026#39; }) export class UserFormComponent implements OnInit { userForm: FormGroup; constructor( private fb: FormBuilder, private emailValidator: EmailValidatorService ) {} ngOnInit(): void { this.userForm = this.fb.group({ email: [ \u0026#39;\u0026#39;, [Validators.required, Validators.email], [this.emailValidator.emailExistsValidator()] ] }); } onSubmit(): void { if (this.userForm.valid) { console.log(this.userForm.value); } else { console.log(\u0026#39;Form is invalid\u0026#39;); } } } emailExistsValidator()：这是在 EmailValidatorService 中定义的异步验证器，用于验证用户输入的电子邮件地址是否已存在。 [this.emailValidator.emailExistsValidator()]：将异步验证器作为第三个参数传递给 FormControl，它会在表单控件的值变化时触发。 FormControl 的验证顺序：Validators.required 和 Validators.email 是同步验证器，而 emailExistsValidator() 是异步验证器。 模板代码：\n\u0026lt;form [formGroup]=\u0026#34;userForm\u0026#34; (ngSubmit)=\u0026#34;onSubmit()\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email:\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;email\u0026#34; formControlName=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;!-- 错误消息 --\u0026gt; \u0026lt;div *ngIf=\u0026#34;userForm.get(\u0026#39;email\u0026#39;).hasError(\u0026#39;required\u0026#39;) \u0026amp;\u0026amp; userForm.get(\u0026#39;email\u0026#39;).touched\u0026#34;\u0026gt; Email is required. \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;userForm.get(\u0026#39;email\u0026#39;).hasError(\u0026#39;email\u0026#39;) \u0026amp;\u0026amp; userForm.get(\u0026#39;email\u0026#39;).touched\u0026#34;\u0026gt; Invalid email format. \u0026lt;/div\u0026gt; \u0026lt;div *ngIf=\u0026#34;userForm.get(\u0026#39;email\u0026#39;).hasError(\u0026#39;emailExists\u0026#39;) \u0026amp;\u0026amp; userForm.get(\u0026#39;email\u0026#39;).touched\u0026#34;\u0026gt; This email address is already registered. \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; [disabled]=\u0026#34;userForm.invalid\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; FormBuilder # FormBuilder 是一个辅助工具，用于简化和减少 FormControl 和 FormGroup 的冗长创建过程，特别是在需要创建大量表单控件时。通过 FormBuilder，可以更简洁、更易读地构建表单。\nthis.fb.control：表单项 this.fb.group：表单组，表单至少是一个 FormGroup this.fb.array：用于复杂表单，可以动态添加表单项或表单组，在表单验证时，FormArray 中有一项没通过，那么整体就不会通过。 this.form = this.fb.group({ name: [\u0026#39;\u0026#39;, Validators.required], email: [\u0026#39;\u0026#39;, [Validators.required, Validators.email]], }); 其他 # setValue # 用于将整个表单控件的值设置为一个新的值。如果你使用 setValue，必须提供一个完整的对象，该对象必须包含所有控件的值，且顺序和控件名必须与原始表单控件匹配。\nformGroup.setValue(value: { [key: string]: any }, options?: { onlySelf?: boolean, emitEvent?: boolean }) value：一个包含所有控件的值的对象，必须包含表单中所有控件的值。 onlySelf（可选）：如果为 true，则只会更新当前控件的值，不会影响父表单。 emitEvent（可选）：如果为 false，则不会触发控件的 valueChanges 事件。 patchValue # patchValue 方法与 setValue 类似，也用于更新表单控件的值。但是，patchValue 允许部分更新表单控件的值。你只需要提供你希望更新的控件的值，而不必提供整个表单控件的值。这对于动态表单或者只需更新部分控件的场景非常有用。\nformGroup.patchValue(value: { [key: string]: any }, options?: { onlySelf?: boolean, emitEvent?: boolean }) value：一个包含部分控件值的对象，更新该对象中的字段，不需要提供所有控件的值。 onlySelf（可选）：如果为 true，则只会更新当前控件的值，不会影响父表单。 emitEvent（可选）：如果为 false，则不会触发控件的 valueChanges 事件。 reset # 方法用于将表单恢复到初始状态。可以通过它将控件值重置为初始值，并恢复表单的有效性。\nvalid、invalid # 这两个属性用来检查表单是否有效。valid 返回 true 如果表单是有效的，invalid 返回 true 如果表单是无效的。\ndirty、pristine # dirty：如果控件的值已经被修改，则返回 true，否则返回 false。 pristine：与 dirty 相反，如果控件的值从未被修改过，则返回 true。 touched、untouched # touched：如果控件已经被触摸（即用户离开了该控件），则返回 true。 untouched：如果控件未被触摸，则返回 true。 markAsTouched()、markAsUntouched() # markAsTouched()：将所有控件标记为已触摸。 markAsUntouched()：将所有控件标记为未触摸。 markAsDirty()、markAsPristine() # markAsDirty()：将所有控件标记为已修改。 markAsPristine()：将所有控件标记为未修改。 enable()、disable() # enable()：启用表单控件。 disable()：禁用表单控件。 hasError() # hasError() 用于检查控件是否存在特定的验证错误。\nif (this.formGroup.get(\u0026#39;email\u0026#39;).hasError(\u0026#39;required\u0026#39;)) { console.log(\u0026#39;Email is required\u0026#39;); } setErrors() # setErrors() 将控件设置错误，并且可以指定一个错误对象。\nformGroup.setErrors(errors: ValidationErrors | null, options?: { emitEvent?: boolean }): void errors：一个包含错误信息的对象，或者为 null，表示清除所有错误。ValidationErrors 是一个键值对对象，键是错误的名称，值是错误的描述信息。 options.emitEvent（可选）：一个布尔值，表示是否触发 statusChanges 和 valueChanges 事件。默认为 true，即触发事件。 this.formGroup.setErrors({ invalidForm: \u0026#39;The form is invalid\u0026#39; }); valueChanges、statusChanges # valueChanges：当表单控件的值发生变化时（例如 setValue()），会触发该 Observable。 statusChanges：当表单控件的状态发生变化时（例如从 valid 到 invalid，或者调用 setErrors()），会触发该 Observable。 this.formGroup.valueChanges.subscribe(value =\u0026gt; { console.log(\u0026#39;Form value changed:\u0026#39;, value); }); this.formGroup.statusChanges.subscribe(status =\u0026gt; { console.log(\u0026#39;Form status changed:\u0026#39;, status); }); updateValueAndValidity # 用于更新表单控件的值和有效性。它会触发控件的验证过程，重新评估控件的值是否有效，并更新控件的验证状态（如 valid、invalid、pending、touched 等）。\n这个方法在你手动修改控件的值或验证器时特别有用，确保控件的状态得到重新评估。\nformControl.updateValueAndValidity(options?: { onlySelf?: boolean, emitEvent?: boolean }): void onlySelf（可选）：如果为 true，仅会更新当前控件，而不会影响父表单。默认为 false，即更新当前控件及其父控件。 emitEvent（可选）：如果为 false，则不会触发 valueChanges 或 statusChanges 事件。默认为 true，即会触发这些事件。 "},{"id":23,"href":"/frontend-learn/docs/angular/10_custom_form/","title":"自定义表单控件","section":"Angular","content":" 自定义表单控件 # 创建自定义表单控件时，通常需要三步：\n实现 ControlValueAccessor 接口：使自定义控件能够与 Angular 表单框架配合使用。 实现 Validator 接口：提供自定义的验证逻辑。 注册自定义控件为 Angular 表单控件。 实现 ControlValueAccessor 接口 # ControlValueAccessor 接口允许自定义控件与 Angular 的表单控件（FormControl, ngModel）进行交互。需要实现以下方法：\nwriteValue(value: any): void：这个方法会将父组件的表单值写入自定义控件。 registerOnChange(fn: any): void：当自定义控件的值发生变化时，调用该方法通知父组件。 registerOnTouched(fn: any): void：当控件被触摸时（比如失去焦点），会调用这个方法通知父组件。通常来说，将 onBlur() 事件会绑定到控件的 blur 事件上，并在 onBlur() 方法中调用它。。 setDisabledState(isDisabled: boolean): void：用于设置控件的禁用状态。可以根据 isDisabled 值来禁用或启用自定义控件。 writeValue 和 setDisabledState 通常在父组件中调用 CustomFormControl.setValue() 和 CustomFormControl.disable() 方法时会执行。父组件初始化控件时也会执行，例如：\nthis.myCustomCtrl = new FormControl({value: \u0026#39;\u0026#39;, disabled: true}); 实现 ControlValueAccessor 接口示例：\nimport { Component, forwardRef } from \u0026#39;@angular/core\u0026#39;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-custom-input\u0026#39;, template: `\u0026lt;input [value]=\u0026#34;value\u0026#34; (input)=\u0026#34;onInput($event)\u0026#34; /\u0026gt;`, providers: [ { provide: NG_VALUE_ACCESSOR, // 注册到 Angular 表单系统 useExisting: forwardRef(() =\u0026gt; CustomInputComponent), // 指向当前组件 multi: true // 表示可以有多个实现 } ] }) export class CustomInputComponent implements ControlValueAccessor { value: string = \u0026#39;\u0026#39;; onChange: any = () =\u0026gt; {}; onTouched: any = () =\u0026gt; {}; // 实现 ControlValueAccessor 接口 registerOnChange(fn: any): void { this.onChange = fn; // 也可以直接监听 valueChanges，并通知父组件 // this.control.valueChanges.subscribe(fn); // 当 FormControl 的值变化时，调用回调 } registerOnTouched(fn: any): void { this.onTouched = fn; } writeValue(value: any): void { if (value !== undefined) { this.value = value; } } setDisabledState(isDisabled: boolean): void { // 可以在这里设置控件的禁用状态 } onInput(event: Event): void { const input = event.target as HTMLInputElement; this.value = input.value; this.onChange(this.value); // 通知 Angular 表单模型控件值已经变化 } } 实现 Validator 接口 # Validator 接口用于添加自定义的验证逻辑。它定义了一个 validate() 方法，这个方法返回一个 ValidationErrors 对象，或者是 null（表示没有验证错误）。\nValidationErrors 是一个键值对对象，其中每个键表示一个错误类型，值表示错误的详细信息。\nimport { AbstractControl, ValidationErrors, Validator } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-custom-input\u0026#39;, template: `\u0026lt;input [value]=\u0026#34;value\u0026#34; (input)=\u0026#34;onInput($event)\u0026#34; /\u0026gt;`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =\u0026gt; CustomInputComponent), multi: true }, { provide: NG_VALIDATORS, useExisting: forwardRef(() =\u0026gt; CustomInputComponent), multi: true // 表示可以有多个验证器 } ] }) export class CustomInputComponent implements ControlValueAccessor, Validator { // ControlValueAccessor 接口实现 ... // 实现 Validator 接口 validate(control: AbstractControl): ValidationErrors | null { // 例如，验证输入值是否为数字 const value = control.value; if (value \u0026amp;\u0026amp; isNaN(value)) { return { \u0026#39;invalidNumber\u0026#39;: \u0026#39;The value must be a number.\u0026#39; }; } return null; // 返回 null 表示验证通过 } } 使用自定义表单控件：\n\u0026lt;form [formGroup]=\u0026#34;myForm\u0026#34;\u0026gt; \u0026lt;app-custom-input formControlName=\u0026#34;customInput\u0026#34;\u0026gt;\u0026lt;/app-custom-input\u0026gt; \u0026lt;div *ngIf=\u0026#34;myForm.get(\u0026#39;customInput\u0026#39;).hasError(\u0026#39;invalidNumber\u0026#39;)\u0026#34;\u0026gt; Value must be a number! \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; NG_VALUE_ACCESSOR 和 NG_VALIDATORS # NG_VALUE_ACCESSOR：NG_VALUE_ACCESSOR 令牌指向一个实现了 ControlValueAccessor 接口的组件，允许 Angular 在处理表单时使用该组件。 表单绑定：NG_VALUE_ACCESSOR 让自定义控件能够与 Angular 表单控件（FormControl, ngModel 等）进行数据绑定。 双向数据绑定：它允许自定义控件接收表单模型的数据，并将用户的输入传递回表单模型。 自定义控件集成：通过实现 ControlValueAccessor 接口并提供 NG_VALUE_ACCESSOR，可以将自定义控件集成到 Angular 的表单框架中，享受 Angular 表单系统提供的功能（如验证、状态管理等）。 NG_VALIDATORS 主要用于在表单控件上添加自定义的验证逻辑。可以将自定义验证器与 Angular 表单控件（如 FormControl, ngModel）一起使用。 "},{"id":24,"href":"/frontend-learn/docs/angular/11_router/","title":"路由","section":"Angular","content":" 快速上手 # 创建页面组件、Layout 组件以及 Navigation 组件，供路由使用\n创建首页页面组件ng g c pages/home 创建关于我们页面组件ng g c pages/about 创建布局组件ng g c pages/layout 创建导航组件ng g c pages/navigation 创建路由规则\n// app.module.ts import { Routes } from \u0026#34;@angular/router\u0026#34; const routes: Routes = [ { path: \u0026#34;home\u0026#34;, component: HomeComponent }, { path: \u0026#34;about\u0026#34;, component: AboutComponent } ] 引入路由模块并启动\n// app.module.ts import { RouterModule, Routes } from \u0026#34;@angular/router\u0026#34; @NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], }) export class AppModule {} 添加路由插座\n路由插座 \u0026lt;router-outlet\u0026gt; 即占位组件 匹配到的路由组件将会显示在这个地方\n\u0026lt;!-- --\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; 在导航组件中定义链接\n\u0026lt;a routerLink=\u0026#34;/home\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt; \u0026lt;a routerLink=\u0026#34;/about\u0026#34;\u0026gt;关于我们\u0026lt;/a\u0026gt; 路由规则 # 重定向 # const routes: Routes = [ { path: \u0026#34;home\u0026#34;, component: HomeComponent }, { path: \u0026#34;about\u0026#34;, component: AboutComponent }, { path: \u0026#34;\u0026#34;, // 重定向 redirectTo: \u0026#34;home\u0026#34;, // 完全匹配 pathMatch: \u0026#34;full\u0026#34; } ] 404 页面 # const routes: Routes = [ { path: \u0026#34;home\u0026#34;, component: HomeComponent }, { path: \u0026#34;about\u0026#34;, component: AboutComponent }, { path: \u0026#34;**\u0026#34;, component: NotFoundComponent } ] 路由传参 # 查询参数 # 通过 queryParams 添加查询参数：\n\u0026lt;a routerLink=\u0026#34;/about\u0026#34; [queryParams]=\u0026#34;{ name: \u0026#39;kitty\u0026#39; }\u0026#34;\u0026gt;关于我们\u0026lt;/a\u0026gt; 访问 url 路径是：/about?name=kitty。\nimport { ActivatedRoute } from \u0026#34;@angular/router\u0026#34; export class AboutComponent implements OnInit { constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.queryParamMap.subscribe(query =\u0026gt; { query.get(\u0026#34;name\u0026#34;) }) } } 动态参数 # const routes: Routes = [ { path: \u0026#34;home\u0026#34;, component: HomeComponent }, { path: \u0026#34;about/:name\u0026#34;, component: AboutComponent } ] about/:name 中的 :name 就是一个动态参数。\n\u0026lt;a [routerLink]=\u0026#34;[\u0026#39;/about\u0026#39;, \u0026#39;zhangsan\u0026#39;]\u0026#34;\u0026gt;关于我们\u0026lt;/a\u0026gt; 访问 url 路径是：/about/zhangsan。\nimport { ActivatedRoute } from \u0026#34;@angular/router\u0026#34; export class AboutComponent implements OnInit { constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.paramMap.subscribe(params =\u0026gt; { params.get(\u0026#34;name\u0026#34;) }) } } 配置路由数据 # Angular 可以在路由配置中使用 data 属性来定义数据。data 属性接受一个对象，可以在组件中通过 ActivatedRoute 获取这些数据。\nimport { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { HomeComponent } from \u0026#39;./home/home.component\u0026#39;; import { AboutComponent } from \u0026#39;./about/about.component\u0026#39;; const routes: Routes = [ { path: \u0026#39;\u0026#39;, component: HomeComponent, data: { title: \u0026#39;Home Page\u0026#39; } // 配置数据 }, { path: \u0026#39;about\u0026#39;, component: AboutComponent, data: { title: \u0026#39;About Us\u0026#39; } // 配置数据 } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { } 通过 ActivatedRoute 来访问路由数据：\nimport { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRoute } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-home\u0026#39;, template: `\u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt;` }) export class HomeComponent implements OnInit { title: string = \u0026#39;\u0026#39;; constructor(private route: ActivatedRoute) {} ngOnInit(): void { // 获取路由配置中的数据 this.title = this.route.snapshot.data[\u0026#39;title\u0026#39;]; // 也可以订阅数据变化 this.route.data.subscribe(data =\u0026gt; { this.title = data[\u0026#39;title\u0026#39;]; }); } } snapshot # ActivatedRoute.snapshot 是一个用于获取当前路由状态的快照对象。它包含了与当前路由相关的所有信息，包括路由参数、查询参数、数据等。snapshot 主要用于同步获取路由信息。\n当你需要在路由切换时读取静态的路由信息时，而不需要响应路由变化。 不需要监听路由变化，而是只需要在组件初始化时获取一次路由参数和其他信息时使用。 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRoute } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-product-detail\u0026#39;, templateUrl: \u0026#39;./product-detail.component.html\u0026#39;, styleUrls: [\u0026#39;./product-detail.component.css\u0026#39;] }) export class ProductDetailComponent implements OnInit { productId: string; category: string; constructor(private route: ActivatedRoute) {} ngOnInit() { // 获取路由参数 this.productId = this.route.snapshot.paramMap.get(\u0026#39;id\u0026#39;); // 获取查询参数 this.category = this.route.snapshot.queryParamMap.get(\u0026#39;category\u0026#39;); // 获取完整的 URL console.log(this.route.snapshot.url); // 返回 URL 数组 console.log(this.route.snapshot.url.join(\u0026#39;/\u0026#39;)); // 返回 URL 字符串 } } 它适用于你只需要在组件加载时读取一次路由信息，并且不需要响应路由参数变化的场景。如果需要响应路由的变化（例如，路由参数的改变），则应该使用 route.params 或 route.queryParams 并订阅它们。\n路由嵌套 # 路由嵌套指的是如何定义子级路由。\nconst routes: Routes = [ { path: \u0026#34;about\u0026#34;, component: AboutComponent, children: [ { path: \u0026#34;introduce\u0026#34;, component: IntroduceComponent }, { path: \u0026#34;history\u0026#34;, component: HistoryComponent } ] } ] 下面是父级组件模板：\n\u0026lt;!-- about.component.html --\u0026gt; \u0026lt;app-layout\u0026gt; \u0026lt;p\u0026gt;about works!\u0026lt;/p\u0026gt; \u0026lt;a routerLink=\u0026#34;/about/introduce\u0026#34;\u0026gt;公司简介\u0026lt;/a\u0026gt; \u0026lt;a routerLink=\u0026#34;/about/history\u0026#34;\u0026gt;发展历史\u0026lt;/a\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/app-layout\u0026gt; 父级模板中添加了 \u0026lt;router-outlet\u0026gt;，用来显示子级路由的组件。\n命名插座 # 命名路由插座使得在同一页面中渲染多个视图变得更加灵活，常用于复杂的布局或多个区域显示不同内容的场景。。\n命名插座使用 outlet 属性来指定。\nconst routes: Routes = [ { path: \u0026#39;dashboard\u0026#39;, component: DashboardComponent }, { path: \u0026#39;user-profile\u0026#39;, component: UserProfileComponent, outlet: \u0026#39;sidebar\u0026#39; } ]; 模板布局：\n\u0026lt;div class=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;router-outlet\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;!-- 默认插座显示 dashboard 或其他组件 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;router-outlet name=\u0026#34;sidebar\u0026#34;\u0026gt;\u0026lt;/router-outlet\u0026gt; \u0026lt;!-- 命名插座显示 user-profile --\u0026gt; \u0026lt;/div\u0026gt; 可以在路由链接中指定插座名称：\n\u0026lt;a [routerLink]=\u0026#34;[{ outlets: { primary: [\u0026#39;dashboard\u0026#39;], sidebar: [\u0026#39;user-profile\u0026#39;] } }]\u0026#34;\u0026gt; Go to Dashboard and User Profile \u0026lt;/a\u0026gt; 导航路由 # 在 JS 中通过 Router.navigate 方法跳转路由：\n\u0026lt;!-- app.component.html --\u0026gt; \u0026lt;button (click)=\u0026#34;jump()\u0026#34;\u0026gt;跳转到发展历史\u0026lt;/button\u0026gt; // app.component.ts import { Router } from \u0026#34;@angular/router\u0026#34; export class HomeComponent { constructor(private router: Router) {} jump() { this.router.navigate([\u0026#34;/about/history\u0026#34;], { queryParams: { name: \u0026#34;Kitty\u0026#34; } }) } } 路由懒加载 # Angular 最新的版本推荐使用 Standalone 组件，可以通过 loadComponent 来进行懒加载配置。和常规的模块懒加载不同，Standalone 组件的懒加载是基于组件的，而不是模块。\nimport { Routes, RouterModule } from \u0026#39;@angular/router\u0026#39;; const routes: Routes = [ { path: \u0026#39;dashboard\u0026#39;, loadComponent: () =\u0026gt; import(\u0026#39;./dashboard/dashboard.component\u0026#39;).then(m =\u0026gt; m.DashboardComponent) // 懒加载 Standalone 组件 }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/dashboard\u0026#39;, pathMatch: \u0026#39;full\u0026#39; } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} 在 Angular 中，Standalone 组件配置了懒加载，其子组件不会自动成为懒加载组件。懒加载是基于路由配置的，当你在路由配置中指定某个组件使用 loadComponent 来进行懒加载时，只有该组件本身被懒加载。其子组件仍然会像常规组件一样，在加载父组件时一并加载。\n路由懒加载的好处 # 减小初始包体积：只有在用户访问某个路由时，相关的 Standalone 组件才会被加载，这样可以减小应用的初始包体积，提升性能。 按需加载：用户只加载他们需要的部分，这对于大型应用来说是一个显著的性能优化。 简单配置：与传统的模块懒加载相比，Standalone 组件的懒加载配置更加简洁，因为不再需要为每个懒加载的组件创建单独的模块。 路由守卫 # 路由守卫（Route Guards）用于在用户导航到路由之前、或者离开路由时，控制访问权限或执行某些逻辑。\n路由守卫可以帮助你做很多事情，例如：权限控制、登录验证、数据预加载等。\n常用的路由守卫类型：\nCanActivate: 在导航到某个路由时进行检查，控制是否允许该路由激活。 CanDeactivate: 在导航离开当前路由时进行检查，控制是否允许离开该路由（例如，防止丢失未保存的表单数据）。 CanLoad: 在懒加载模块时进行检查，控制是否允许加载该模块。 Resolve: 在路由激活前加载数据，确保数据在路由激活之前就被加载。 路由可以应用多个守卫，所有守卫方法都允许，路由才被允许访问，有一个守卫方法不允许，则路由不允许被访问。\nCanActivate # CanActivate 守卫用于控制进入路由时的权限，比如检查用户是否已经登录，或者是否有权限访问某个页面。CanActivate 会在路由激活之前执行。即便是懒加载模块，CanActivate 也会在模块加载之前执行。\n创建路由守卫：ng generate guard auth\n// auth.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AuthService } from \u0026#39;./auth.service\u0026#39;; // 假设你有一个 AuthService 用于检查登录状态 @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthGuard implements CanActivate { constructor(private authService: AuthService, private router: Router) {} canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot ): Observable\u0026lt;boolean\u0026gt; | Promise\u0026lt;boolean\u0026gt; | boolean { if (this.authService.isAuthenticated()) { return true; } else { // 如果未认证，重定向到登录页面 this.router.navigate([\u0026#39;/login\u0026#39;]); return false; } } } 然后，在路由配置中使用该守卫：\n// app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { AuthGuard } from \u0026#39;./auth.guard\u0026#39;; // 引入守卫 const routes: Routes = [ { path: \u0026#39;dashboard\u0026#39;, component: DashboardComponent, canActivate: [AuthGuard] // 使用守卫 }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/dashboard\u0026#39;, pathMatch: \u0026#39;full\u0026#39; } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} 当用户尝试访问 /dashboard 路由时，AuthGuard 会先执行，如果用户已经认证（authService.isAuthenticated() 返回 true），则允许导航；否则，导航会被重定向到 /login 页面。\nCanActivateChild # CanActivateChild 路由守卫用于控制 子路由 的访问权限。它与 CanActivate 类似，但 CanActivateChild 主要针对的是父路由的所有子路由的访问控制。通过使用 CanActivateChild，可以统一管理子路由的权限控制，而不需要在每个子路由上单独配置守卫。\n// auth.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { CanActivateChild, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AuthService } from \u0026#39;./auth.service\u0026#39;; // 假设你有一个 AuthService 用于检查用户登录状态 @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class AuthGuard implements CanActivateChild { constructor(private authService: AuthService, private router: Router) {} canActivateChild( next: ActivatedRouteSnapshot, state: RouterStateSnapshot ): Observable\u0026lt;boolean\u0026gt; | Promise\u0026lt;boolean\u0026gt; | boolean { // 判断用户是否已认证 if (this.authService.isAuthenticated()) { return true; // 允许访问子路由 } else { // 如果未认证，重定向到登录页面 this.router.navigate([\u0026#39;/login\u0026#39;]); return false; // 拒绝访问 } } } 在路由配置中使用 CanActivateChild 守卫。CanActivateChild 需要被配置在父路由上，而不是每个子路由。\n// app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { AuthGuard } from \u0026#39;./auth.guard\u0026#39;; // 引入守卫 import { DashboardComponent } from \u0026#39;./dashboard/dashboard.component\u0026#39;; import { SettingsComponent } from \u0026#39;./settings/settings.component\u0026#39;; import { ProfileComponent } from \u0026#39;./profile/profile.component\u0026#39;; const routes: Routes = [ { path: \u0026#39;dashboard\u0026#39;, component: DashboardComponent, canActivateChild: [AuthGuard], // 使用 CanActivateChild 守卫 children: [ { path: \u0026#39;settings\u0026#39;, component: SettingsComponent }, { path: \u0026#39;profile\u0026#39;, component: ProfileComponent } ] }, { path: \u0026#39;login\u0026#39;, component: LoginComponent }, { path: \u0026#39;\u0026#39;, redirectTo: \u0026#39;/dashboard\u0026#39;, pathMatch: \u0026#39;full\u0026#39; } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} CanDeactivate # CanDeactivate 守卫用于在离开当前路由时进行检查，通常用于防止用户丢失未保存的表单数据或者在离开当前页面时提示用户。\n// can-deactivate.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { CanDeactivate } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; // 守卫可以适用于多个组件，通常会创建一个接口来约束组件 export interface CanComponentDeactivate { canDeactivate: () =\u0026gt; Observable\u0026lt;boolean\u0026gt; | Promise\u0026lt;boolean\u0026gt; | boolean; } @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class CanDeactivateGuard implements CanDeactivate\u0026lt;CanComponentDeactivate\u0026gt; { canDeactivate( component: CanComponentDeactivate ): Observable\u0026lt;boolean\u0026gt; | Promise\u0026lt;boolean\u0026gt; | boolean { return component.canDeactivate ? component.canDeactivate() : true; } } 在组件中实现 canDeactivate 方法：\n// form.component.ts import { Component } from \u0026#39;@angular/core\u0026#39;; import { CanComponentDeactivate } from \u0026#39;./can-deactivate.guard\u0026#39;; @Component({ selector: \u0026#39;app-form\u0026#39;, templateUrl: \u0026#39;./form.component.html\u0026#39; }) export class FormComponent implements CanComponentDeactivate { formIsDirty = false; // 假设这是表单是否已更改的状态 canDeactivate(): boolean { if (this.formIsDirty) { return window.confirm(\u0026#39;You have unsaved changes. Do you really want to leave?\u0026#39;); } return true; } } 配置路由守卫：\n// app-routing.module.ts import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { RouterModule, Routes } from \u0026#39;@angular/router\u0026#39;; import { CanDeactivateGuard } from \u0026#39;./can-deactivate.guard\u0026#39;; // 引入守卫 import { FormComponent } from \u0026#39;./form.component\u0026#39;; const routes: Routes = [ { path: \u0026#39;form\u0026#39;, component: FormComponent, canDeactivate: [CanDeactivateGuard] // 使用守卫 } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} CanLoad # CanLoad 守卫用于在懒加载模块时进行检查，确保只有在满足某些条件下才允许加载该模块。它通常用于懒加载模块的权限控制。如果用户没有权限或未登录，CanLoad 可以阻止模块加载，避免加载不必要的资源。\n// can-load.guard.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { CanLoad, Route, UrlSegment, Router } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AuthService } from \u0026#39;./auth.service\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class CanLoadGuard implements CanLoad { constructor(private authService: AuthService, private router: Router) {} canLoad( route: Route, segments: UrlSegment[] ): Observable\u0026lt;boolean\u0026gt; | Promise\u0026lt;boolean\u0026gt; | boolean { if (this.authService.isAuthenticated()) { return true; } else { this.router.navigate([\u0026#39;/login\u0026#39;]); return false; } } } 然后在懒加载模块的路由配置中使用 CanLoad 守卫：\n// app-routing.module.ts import { Routes, RouterModule } from \u0026#39;@angular/router\u0026#39;; const routes: Routes = [ { path: \u0026#39;admin\u0026#39;, loadChildren: () =\u0026gt; import(\u0026#39;./admin/admin.module\u0026#39;).then(m =\u0026gt; m.AdminModule), canLoad: [CanLoadGuard] // 使用 CanLoad 守卫 } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} Resolve # Resolve 守卫用于在路由激活之前预先加载数据，确保组件渲染之前数据已经准备好。\n通常会调用一个服务来获取数据，然后在服务中实现 Resolve 接口：\n// data-resolver.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { Resolve } from \u0026#39;@angular/router\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { DataService } from \u0026#39;./data.service\u0026#39;; // 假设有一个服务提供数据 @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class DataResolver implements Resolve\u0026lt;any\u0026gt; { constructor(private dataService: DataService) {} resolve(): Observable\u0026lt;any\u0026gt; { return this.dataService.getData(); // 返回需要加载的数据 } } 配置路由时使用 resolve：\n// app-routing.module.ts import { Routes, RouterModule } from \u0026#39;@angular/router\u0026#39;; import { DataResolver } from \u0026#39;./data-resolver.service\u0026#39;; import { DashboardComponent } from \u0026#39;./dashboard/dashboard.component\u0026#39;; const routes: Routes = [ { path: \u0026#39;dashboard\u0026#39;, component: DashboardComponent, resolve: { data: DataResolver // 使用 resolve 守卫 } } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} 在组件中，通过 ActivatedRoute 来访问预加载的数据：\n// dashboard.component.ts import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { ActivatedRoute } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-dashboard\u0026#39;, templateUrl: \u0026#39;./dashboard.component.html\u0026#39; }) export class DashboardComponent implements OnInit { data: any; constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.data = this.route.snapshot.data[\u0026#39;data\u0026#39;]; // 获取 resolve 中的数据 } } 路由事件 # 路由事件 (RouterEvent) 是指与路由相关的各种操作发生时触发的事件。通过监听这些事件，可以执行一些特定的操作，如路由开始时的动画效果、在路由切换时获取日志信息、监控路由生命周期等。\n常用的路由事件：\nNavigationStart: 当路由开始导航时触发。 NavigationEnd: 当路由导航完成时触发。 NavigationCancel: 如果导航被取消时触发。 NavigationError: 如果导航出错时触发。 RoutesRecognized: 当路由的目标路径已经解析完毕时触发。 ChildActivationStart: 当子路由激活开始时触发。 ChildActivationEnd: 当子路由激活结束时触发。 ActivationStart: 当路由激活开始时触发。 ActivationEnd: 当路由激活结束时触发。 DeactivationStart: 当路由停用开始时触发。 DeactivationEnd: 当路由停用结束时触发。 显示加载指示器 # 如果要实现在导航开始时显示一个加载器，并在导航完成时隐藏它。可以通过订阅 NavigationStart 和 NavigationEnd 事件来实现。\nimport { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { Router, NavigationStart, NavigationEnd } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-root\u0026#39;, templateUrl: \u0026#39;./app.component.html\u0026#39;, styleUrls: [\u0026#39;./app.component.css\u0026#39;] }) export class AppComponent implements OnInit { loading: boolean = false; constructor(private router: Router) {} ngOnInit(): void { this.router.events.subscribe((event) =\u0026gt; { if (event instanceof NavigationStart) { this.loading = true; // 显示加载指示器 } if (event instanceof NavigationEnd) { this.loading = false; // 隐藏加载指示器 } }); } } "},{"id":25,"href":"/frontend-learn/docs/angular/12_http/","title":"HttpClient","section":"Angular","content":"该模块用于发送 Http 请求，用于发送请求的方法都返回 Observable 对象。\n快速开始 # 引入 HttpClientModule 模块\n// app.module.ts import { httpClientModule } from \u0026#39;@angular/common/http\u0026#39;; imports: [ httpClientModule ] 注入 HttpClient 服务实例对象，用于发送请求\n// app.component.ts import { HttpClient } from \u0026#39;@angular/common/http\u0026#39;; export class AppComponent { constructor(private http: HttpClient) {} } 发送请求\nimport { HttpClient } from \u0026#34;@angular/common/http\u0026#34; export class AppComponent implements OnInit { constructor(private http: HttpClient) {} ngOnInit() { this.getUsers().subscribe(console.log) } getUsers() { return this.http.get(\u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;) } } 请求方法 # this.http.get(url [, options]); this.http.post(url, data [, options]); this.http.delete(url [, options]); this.http.put(url, data [, options]); this.http.get\u0026lt;Post[]\u0026gt;(\u0026#39;/getAllPosts\u0026#39;) .subscribe(response =\u0026gt; console.log(response)) 请求的配置选项 # 请求参数 # import { HttpParams } from \u0026#39;@angular/common/http\u0026#39;; const params = new HttpParams().set(\u0026#39;page\u0026#39;, \u0026#39;1\u0026#39;).set(\u0026#39;limit\u0026#39;, \u0026#39;10\u0026#39;); this.http.get(\u0026#39;url\u0026#39;, { params }).subscribe(response =\u0026gt; console.log(response)); 请求头 # import { HttpHeaders } from \u0026#39;@angular/common/http\u0026#39;; const headers = new HttpHeaders().set(\u0026#39;Authorization\u0026#39;, \u0026#39;Bearer token\u0026#39;); this.http.get(\u0026#39;url\u0026#39;, { headers }).subscribe(response =\u0026gt; console.log(response)); 响应内容 # declare type HttpObserve = \u0026#39;body\u0026#39; | \u0026#39;response\u0026#39;; // response 读取完整响应体 // body 读取服务器端返回的数据 this.http.get( \u0026#34;https://jsonplaceholder.typicode.com/users\u0026#34;, { observe: \u0026#34;body\u0026#34; } ).subscribe(console.log) 拦截器 # 多个拦截器是按顺序执行的，顺序从上到下，即先注册的拦截器会先执行。\n请求拦截器：先处理请求 响应拦截器：先处理响应 如果你有多个拦截器，它们会按顺序依次处理请求和响应。\n创建拦截器：ng g interceptor \u0026lt;name\u0026gt;。\n请求拦截 # 一个拦截器用来记录每个请求和响应的日志：\n// logging-interceptor.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; @Injectable() export class LoggingInterceptor implements HttpInterceptor { intercept(req: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;any\u0026gt;\u0026gt; { console.log(\u0026#39;Request:\u0026#39;, req); // 继续传递请求 return next.handle(req).pipe( tap( event =\u0026gt; console.log(\u0026#39;Response:\u0026#39;, event), error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error) ) ); } } 为每个 HTTP 请求中自动附加一个身份验证令牌：\n// auth-interceptor.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { AuthService } from \u0026#39;./auth.service\u0026#39;; // 假设你有一个 AuthService 来获取 token @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(private authService: AuthService) {} intercept(req: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;any\u0026gt;\u0026gt; { // 获取存储的 token const authToken = this.authService.getToken(); // 如果 token 存在，修改请求头，添加 Authorization if (authToken) { const clonedRequest = req.clone({ setHeaders: { Authorization: `Bearer ${authToken}` } }); // 将修改后的请求传递给下一个处理程序 return next.handle(clonedRequest); } // 如果没有 token，直接传递原始请求 return next.handle(req); } } 响应拦截 # // response-interceptor.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { tap } from \u0026#39;rxjs/operators\u0026#39;; @Injectable() export class ResponseInterceptor implements HttpInterceptor { intercept(req: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;any\u0026gt;\u0026gt; { return next.handle(req).pipe( tap(event =\u0026gt; { if (event instanceof HttpResponse) { // 在响应到达时修改响应数据 console.log(\u0026#39;Response body:\u0026#39;, event.body); // 你可以在这里修改响应数据，比如做一些转换 } }) ); } } 使用拦截器来集中处理 HTTP 错误，比如统一处理 401 错误（未授权）或 500 错误（服务器错误）：\n// error-interceptor.service.ts import { Injectable } from \u0026#39;@angular/core\u0026#39;; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from \u0026#39;@angular/common/http\u0026#39;; import { Observable } from \u0026#39;rxjs\u0026#39;; import { catchError } from \u0026#39;rxjs/operators\u0026#39;; import { throwError } from \u0026#39;rxjs\u0026#39;; @Injectable() export class ErrorInterceptor implements HttpInterceptor { intercept(req: HttpRequest\u0026lt;any\u0026gt;, next: HttpHandler): Observable\u0026lt;HttpEvent\u0026lt;any\u0026gt;\u0026gt; { return next.handle(req).pipe( catchError(error =\u0026gt; { if (error.status === 401) { console.error(\u0026#39;Unauthorized request. Redirecting to login...\u0026#39;); // 处理 401 错误：例如跳转到登录页 } else if (error.status === 500) { console.error(\u0026#39;Internal server error:\u0026#39;, error); // 处理 500 错误：例如弹出错误提示 } return throwError(error); // 重新抛出错误 }) ); } } 拦截器注入 # @NgModule({ providers: [ { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true } ] }) export class AppModule {} "},{"id":26,"href":"/frontend-learn/docs/angular/13_other/","title":"其他","section":"Angular","content":" Angular 操作 DOM # ElementRef # ElementRef 是一个包装器，提供了对原生 DOM 元素的引用，通常是通过 @ViewChild 或 @ContentChild 来访问模板中的元素，但也可以直接注入 ElementRef 来操作宿主元素。\n当你直接注入 ElementRef 时，Angular 会自动将组件或指令的宿主元素传递给你。你可以通过 ElementRef 访问宿主元素，并执行一些 DOM 操作：\nimport { Component, ElementRef, OnInit } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: `\u0026lt;p\u0026gt;This is an example component!\u0026lt;/p\u0026gt;` }) export class ExampleComponent implements OnInit { constructor(private elementRef: ElementRef) {} ngOnInit() { // 通过 ElementRef 访问宿主元素 console.log(this.elementRef.nativeElement); // 打印宿主元素 this.elementRef.nativeElement.style.backgroundColor = \u0026#39;lightblue\u0026#39;; // 动态修改背景色 } } 直接注入 ElementRef 虽然可以直接通过 nativeElement 操作 DOM，但更推荐使用 Renderer2 来确保代码的跨平台兼容性、安全性和稳定性。\nViewRef # ViewRef 是 Angular 视图 (View) 的抽象。在 Angular 中，View 是应用程序的基本构建块。它是在一起被创建或者销毁的最小元素组单位。Angular 哲学鼓励开发者将 UI 界面 看作 View 的聚合。而不要看作标准的 HTML 元素树。\nAngular 支持两种 View:\nEmbedded View，指 Template Host View，指 Component ViewContainerRef # 用于动态地管理视图（View）的 Service。它允许你在运行时向应用程序中添加、移除或更改视图（模板），从而实现动态组件加载、条件渲染等功能。\n动态创建组件 # import { Component } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-dynamic\u0026#39;, template: `\u0026lt;p\u0026gt;This is a dynamically loaded component!\u0026lt;/p\u0026gt;` }) export class DynamicComponent {} 父组件：\nimport { Component, ViewChild, ViewContainerRef, ComponentFactoryResolver, OnInit } from \u0026#39;@angular/core\u0026#39;; import { DynamicComponent } from \u0026#39;./dynamic.component\u0026#39;; @Component({ selector: \u0026#39;app-parent\u0026#39;, template: `\u0026lt;ng-container #container\u0026gt;\u0026lt;/ng-container\u0026gt;` }) export class ParentComponent implements OnInit { @ViewChild(\u0026#39;container\u0026#39;, { read: ViewContainerRef }) container: ViewContainerRef; constructor(private componentFactoryResolver: ComponentFactoryResolver) {} ngOnInit() { // 创建并插入动态组件 const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent); this.container.clear(); // 清除之前的视图（如果有的话） this.container.createComponent(componentFactory); // 动态加载组件 } } 使用 @ViewChild('container', { read: ViewContainerRef }) 获取 ViewContainerRef。 通过 ComponentFactoryResolver 创建 DynamicComponent 的工厂，并使用 ViewContainerRef 将组件插入视图。 clear() 方法用于清除容器中的所有现有视图（可选，防止插入多个相同组件）。 动态插入模板 # ViewContainerRef 还可以与 TemplateRef 配合使用，用于动态插入模板。\nimport { Component, ViewChild, ViewContainerRef, TemplateRef, OnInit } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-parent\u0026#39;, template: ` \u0026lt;ng-template #template\u0026gt; \u0026lt;p\u0026gt;This is a dynamically inserted template!\u0026lt;/p\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;ng-container #container\u0026gt;\u0026lt;/ng-container\u0026gt; ` }) export class ParentComponent implements OnInit { @ViewChild(\u0026#39;container\u0026#39;, { read: ViewContainerRef }) container: ViewContainerRef; @ViewChild(\u0026#39;template\u0026#39;) template: TemplateRef\u0026lt;any\u0026gt;; ngOnInit() { // 动态插入模板 this.container.createEmbeddedView(this.template); } } 条件渲染 # ViewContainerRef 可以通过动态加载组件和模板来实现条件渲染。\nimport { Component, ViewChild, ViewContainerRef, ComponentFactoryResolver, OnInit } from \u0026#39;@angular/core\u0026#39;; import { DynamicComponent } from \u0026#39;./dynamic.component\u0026#39;; @Component({ selector: \u0026#39;app-parent\u0026#39;, template: ` \u0026lt;button (click)=\u0026#34;toggleComponent()\u0026#34;\u0026gt;Toggle Component\u0026lt;/button\u0026gt; \u0026lt;ng-container #container\u0026gt;\u0026lt;/ng-container\u0026gt; ` }) export class ParentComponent implements OnInit { @ViewChild(\u0026#39;container\u0026#39;, { read: ViewContainerRef }) container: ViewContainerRef; private componentCreated = false; constructor(private componentFactoryResolver: ComponentFactoryResolver) {} ngOnInit() {} toggleComponent() { if (this.componentCreated) { this.container.clear(); // 移除组件 this.componentCreated = false; } else { const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent); this.container.createComponent(componentFactory); // 动态创建组件 this.componentCreated = true; } } } 在上面的代码中：\n点击按钮会动态插入或删除 DynamicComponent。 通过 ViewContainerRef.clear() 方法移除组件或视图。 Renderer2 # Renderer2 是一个用于与 DOM 进行交互的服务，它提供了一些安全的、平台无关的 API 来操作 DOM 元素。\nRenderer2 的主要目的是提供跨平台的兼容性，使得 Angular 应用可以在浏览器、服务器端渲染（Angular Universal）等环境下正常工作，同时也提高了代码的安全性（例如避免直接操作 DOM 引发 XSS 攻击）。\nimport { Component, Renderer2, ElementRef, OnInit } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, templateUrl: \u0026#39;./example.component.html\u0026#39; }) export class ExampleComponent implements OnInit { constructor(private renderer: Renderer2, private el: ElementRef) {} ngOnInit() { // 使用 Renderer2 操作 DOM } } setProperty：用于设置指定元素的属性，第二个参数是要设置的值。\nthis.renderer.setProperty(this.el.nativeElement, \u0026#39;textContent\u0026#39;, \u0026#39;Hello World!\u0026#39;); setStyle：用于设置元素的样式，第一个参数是 DOM 元素，第二个参数是 CSS 属性名称，第三个参数是样式的值。\nremoveStyle：移除元素的指定样式。\nthis.renderer.setStyle(this.el.nativeElement, \u0026#39;color\u0026#39;, \u0026#39;red\u0026#39;); this.renderer.removeStyle(this.el.nativeElement, \u0026#39;color\u0026#39;); addClass：给元素添加指定的 CSS 类。\nremoveClass：从元素中移除指定的 CSS 类。\nthis.renderer.addClass(this.el.nativeElement, \u0026#39;highlight\u0026#39;); this.renderer.removeClass(this.el.nativeElement, \u0026#39;highlight\u0026#39;); listen：用于监听 DOM 事件\nconst unsubscribe = this.renderer.listen(this.el.nativeElement, \u0026#39;click\u0026#39;, (event) =\u0026gt; { console.log(\u0026#39;Element clicked\u0026#39;); }); createElement：用于创建一个 DOM 元素。\ncreateText：用于创建一个文本节点。\nappendChild：用于将子元素添加到父元素。\nremoveChild：`方法，用于从父元素中移除子元素。\nconst div = this.renderer.createElement(\u0026#39;div\u0026#39;); const text = this.renderer.createText(\u0026#39;Hello Renderer2!\u0026#39;); this.renderer.appendChild(div, text); this.renderer.appendChild(this.el.nativeElement, div); this.renderer.removeChild(this.el.nativeElement, div); Title # Title 标签是一个 HTML 元素，用于指定网页标题。Title 标签作为给定结果的可点击标题，显示在搜索引擎结果页面（SERP）上。它们对于可用性、SEO 和社交共享而言至关重要。\nAngular 在 @angular/platform-browser 中有一个 Title 服务。只需将 Title 服务注入到组件中，然后使用 setTitle 方法设置标题。\nimport { Title } from \u0026#34;@angular/platform-browser\u0026#34; @Component({ ... }) export class LoginComponent implements OnInit { constructor(private title: Title) {} ngOnInit() { title.setTitle(\u0026#34;Login\u0026#34;) } } Meta # Angular 在 @angular/platform-browser 中有一个 Meta 服务，使我们能够从组件中设置 meta 标签。\nMeta 元素提供有关网页的信息，搜索引擎可以在这些信息的帮助下正确地分类网页。\nimport { Meta } from \u0026#34;@angular/platform-browser\u0026#34; @Component({ ... }) export class BlogComponent implements OnInit { constructor(private meta: Meta) {} ngOnInit() { meta.updateTag({name: \u0026#34;title\u0026#34;, content: \u0026#34;\u0026#34;}) meta.updateTag({name: \u0026#34;description\u0026#34;, content: \u0026#34;Lorem ipsum dolor\u0026#34;}) meta.updateTag({name: \u0026#34;image\u0026#34;, content: \u0026#34;./assets/blog-image.jpg\u0026#34;}) meta.updateTag({name: \u0026#34;site\u0026#34;, content: \u0026#34;My Site\u0026#34;}) } } DOCUMENT # DOCUMENT 是一个注入令牌（token），它是一个用于获取和操作浏览器 document 对象的服务。直接使用 window.document 只能在浏览器环境中工作，而 Angular 提供的 DOCUMENT 是通过依赖注入来提供的，可以在浏览器和其他环境（如服务器端渲染）之间自动适配。\nimport { Component, Inject, OnInit } from \u0026#39;@angular/core\u0026#39;; import { DOCUMENT } from \u0026#39;@angular/common\u0026#39;; @Component({ selector: \u0026#39;app-document-example\u0026#39;, template: `\u0026lt;h1\u0026gt;Check the document title in the console!\u0026lt;/h1\u0026gt;` }) export class DocumentExampleComponent implements OnInit { constructor(@Inject(DOCUMENT) private document: Document) {} ngOnInit() { // 访问和操作 document 对象 console.log(\u0026#39;Document title:\u0026#39;, this.document.title); this.document.title = \u0026#39;New Document Title\u0026#39;; // 修改文档标题 } } Location # Location 是一个提供访问和操作浏览器 URL 的服务。它允许在不重新加载页面的情况下操作浏览器的历史记录和 URL。这使得你能够在单页面应用（SPA）中实现 URL 路由和导航，同时避免浏览器刷新。\n不要直接修改 window.location，使用 Location 或 Router 来保证跨平台兼容性。并且 Location 支持服务端渲染（SSR），可以在 Node.js 环境中模拟操作。\n与 window.location 的区别 # 功能 Angular Location window.location 修改 URL 可以修改 URL，不会刷新页面 修改 URL 时通常会导致页面刷新 支持单页面应用（SPA） 是专为单页面应用设计的工具 通常用于传统的页面导航和跳转 操作历史记录 提供 back 和 forward 方法 使用 history.back() 等实现 获取和解析 URL 提供 path() 等方法获取路径部分 提供 window.location.pathname 等 不触发页面刷新 支持通过 go() 和 replaceState() 修改 URL 而不刷新页面 大部分操作都会导致页面刷新 适用场景：\n场景 Angular Location window.location 单页面应用（SPA） 推荐使用，用于导航和历史记录管理 不推荐，会导致页面刷新 传统页面跳转 不适用 推荐使用 操作浏览器历史记录 提供方便的方法，如 back()、forward() 可以通过 window.history 操作 URL 操作与刷新行为 不刷新页面，适合动态导航 大多数情况下刷新页面 NgZone # NgZone 是 Angular 提供的一个服务，用于与 Angular 的变更检测机制进行交互，帮助你控制异步操作和变更检测的行为。\nNgZone 允许你在执行异步操作时明确控制是否触发变更检测，避免不必要的性能开销。\nNgZone 是 Angular 基于 zone.js 库的一个封装，zone.js 是一个 JavaScript 库，帮助开发者追踪异步任务的执行。通过 NgZone，Angular 可以追踪和管理异步任务（如定时器、HTTP 请求、用户输入事件等），并确保这些任务在执行后会触发 Angular 的变更检测机制。\nrunOutsideAngular # 函数 runOutsideAngular 内执行的代码不会触发变更检测。\nimport { Component, NgZone } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-ngzone-example\u0026#39;, template: `\u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt;` }) export class NgZoneExampleComponent { message: string = \u0026#39;Hello\u0026#39;; constructor(private ngZone: NgZone) {} startLongRunningTask() { // 在 Angular Zone 外部运行代码，不触发变更检测 this.ngZone.runOutsideAngular(() =\u0026gt; { setInterval(() =\u0026gt; { // 假设这是一个非常频繁的操作 console.log(\u0026#39;Running outside Angular zone\u0026#39;); }, 1000); }); } } run # run 方法的目的与 runOutsideAngular 正好相反。任何写在 run 里的方法，都会进入 Angular Zone 的管辖范围，确保变更检测被触发。\nimport { Component, NgZone } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-ngzone-example\u0026#39;, template: `\u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt;` }) export class NgZoneExampleComponent { message: string = \u0026#39;Hello\u0026#39;; constructor(private ngZone: NgZone) {} updateMessage() { // 在 Angular Zone 内运行，确保变更检测被触发 this.ngZone.run(() =\u0026gt; { this.message = \u0026#39;Updated Message\u0026#39;; }); } } onStable # onStable：是一个 Observable，它会在 Angular 完成所有异步任务并且变更检测稳定后触发。这在需要确保所有变更检测已经完成之后执行某些操作时非常有用。\nimport { Component, NgZone, OnInit } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-ngzone-example\u0026#39;, template: `\u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt;` }) export class NgZoneExampleComponent implements OnInit { message: string = \u0026#39;Hello\u0026#39;; constructor(private ngZone: NgZone) {} ngOnInit() { // 监听 Angular Zone 的稳定事件 this.ngZone.onStable.subscribe(() =\u0026gt; { console.log(\u0026#39;All asynchronous tasks have completed.\u0026#39;); }); } } hasPendingMacrotasks 和 hasPendingMicrotasks # hasPendingMacrotasks 和 hasPendingMicrotasks 用于检查 Angular Zone 内是否还有待处理的宏任务和微任务。这在调试时可以非常有用，帮助你确定是否还有异步任务在执行。\nimport { Component, NgZone, OnInit } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-ngzone-example\u0026#39;, template: `\u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt;` }) export class NgZoneExampleComponent implements OnInit { message: string = \u0026#39;Hello\u0026#39;; constructor(private ngZone: NgZone) {} ngOnInit() { console.log(\u0026#39;Has pending macro tasks:\u0026#39;, this.ngZone.hasPendingMacrotasks); console.log(\u0026#39;Has pending micro tasks:\u0026#39;, this.ngZone.hasPendingMicrotasks); } } DomSanitizer # 用于帮助开发者安全地处理动态 HTML、样式、URL、资源等。它的主要作用是防止 跨站脚本攻击（XSS），通过对可能不安全的内容进行清理和消毒，确保它们在渲染时不会带来安全风险。\nimport { Component } from \u0026#39;@angular/core\u0026#39;; import { DomSanitizer, SafeHtml, SafeStyle, SafeUrl, SafeResourceUrl } from \u0026#39;@angular/platform-browser\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: ` \u0026lt;div [innerHTML]=\u0026#34;trustedHtml\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;img [src]=\u0026#34;trustedUrl\u0026#34; /\u0026gt; `, }) export class ExampleComponent { trustedHtml: SafeHtml; trustedUrl: SafeUrl; constructor(private sanitizer: DomSanitizer) { // 使用 DomSanitizer 处理不安全的内容 this.trustedHtml = this.sanitizer.bypassSecurityTrustHtml(\u0026#39;\u0026lt;p\u0026gt;Unsafe HTML content\u0026lt;/p\u0026gt;\u0026#39;); this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(\u0026#39;javascript:alert(\u0026#34;XSS Attack\u0026#34;)\u0026#39;); } } DomSanitizer 常用方法：\nbypassSecurityTrustHtml：将不安全的 HTML 内容标记为“可信”，以便 Angular 渲染。这个方法通常用于插入动态 HTML 内容。\nbypassSecurityTrustUrl：将 URL 标记为可信的 URL，通常用于动态绑定 href、src 或其他需要 URL 的属性。\nbypassSecurityTrustStyle：将 CSS 样式标记为可信，允许动态添加不安全的样式到组件中。\nimport { DomSanitizer } from \u0026#39;@angular/platform-browser\u0026#39;; export class ExampleComponent { constructor(private sanitizer: DomSanitizer) {} getTrustedStyle() { const unsafeStyle = \u0026#39;background-color: red;\u0026#39;; return this.sanitizer.bypassSecurityTrustStyle(unsafeStyle); } } bypassSecurityTrustResourceUrl：用于将不安全的资源 URL（如 iframe 的 src）标记为可信资源。可以用于动态加载嵌入式资源（如视频、音频等）。\nAttribute 装饰器 # @Attribute 装饰器用于读取宿主元素的属性，而不是组件或指令的输入属性。 它主要用于访问那些静态的 HTML 属性（如 id, class, aria-label 等），并且这些属性是直接应用在宿主元素上的。\n\u0026lt;app-example data-id=\u0026#34;12345\u0026#34;\u0026gt;\u0026lt;/app-example\u0026gt; import { Component, Attribute } from \u0026#39;@angular/core\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: `\u0026lt;p\u0026gt;{{ dataId }}\u0026lt;/p\u0026gt;` }) export class ExampleComponent { constructor(@Attribute(\u0026#39;data-id\u0026#39;) public dataId: string) { console.log(\u0026#39;Data ID:\u0026#39;, dataId); // 12345 } } APP_INITIALIZER # 有时候我们需要在 Angular 应用启动时运行一段代码，这段代码可能会加载一些设置，比如加载缓存，加载配置。可以使用 APP_INITIALIZER。\nAPP_INITIALIZER：初始化应用时执行的函数。如果这些函数中的任何一个返回一个 Promise 或 Observable，初始化就不会完成，直到 Promise 被解析或 Observable 被完成。\n只需要 AppModule 中添加 APP_INITIALIZER 即可：\nfunction runSettingsOnInit() { ... } @NgModule({ providers: [ { provide: APP_INITIALIZER, useFactory: runSettingsOnInit } ] }) ENVIRONMENT_INITIALIZER # ENVIRONMENT_INITIALIZER 是 Angular 14 引入的，用于在 Angular 应用启动期间运行长时间任务。它允许开发者在环境注入器中注入一个或多个初始化函数，这些函数在环境准备阶段执行。这个特性特别适用于那些需要在应用程序启动时完成的初始化工作，但又不适合放在 APP_INITIALIZER 中执行的场景。比如设置全局的服务或配置，这些工作通常需要在应用程序完全启动之前完成。\n提高应用性能：通过在环境级别进行初始化，可以减少应用启动时的延迟，因为这些初始化任务可以在应用程序完全启动之前完成，从而提高应用的性能和响应速度。\nPLATFORM_INITIALIZER # PLATFORM_INITIALIZER 是用于初始化 Angular 平台的机制。这个机制允许开发者在 Angular 平台（例如在浏览器中）完全启动之前执行一些初始化逻辑。\nPLATFORM_INITIALIZER 通常用于执行那些需要在 Angular 平台完全启动之前完成的初始化任务，比如设置全局的提供者和服务。这个初始化器与 APP_INITIALIZER 和 ENVIRONMENT_INITIALIZER 的主要区别在于它的执行时机和作用范围，它更侧重于平台级别的初始化。\n:host 、:host-context、::ng-deep # :host # :host 是一个伪类选择器，用于选中当前组件的宿主元素（即 \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt;）。它可以用于定义组件根元素的样式。该选择器允许你从组件的样式文件中访问组件外部的宿主元素，而不是组件内部的子元素。\n\u0026lt;!-- my-component.component.html --\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Content inside component\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 在组件的样式中，使用 :host 来修改宿主元素的样式：\n/* my-component.component.css */ :host { display: block; border: 1px solid red; padding: 20px; } :host(.highlight) { background-color: yellow; } 在这个例子中 :host 选择器作用于组件的宿主元素 \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt;。\n:host 只能影响宿主元素（组件标签）。 适用于修改组件根元素的样式。 :host-context # :host-context 是另一个伪类选择器，作用于宿主元素及其外部上下文。它允许你根据宿主元素的外部环境（即外部父组件或全局样式）来修改组件的样式。\n:host-context 选择器类似于 :host，但它可以应用样式时依赖宿主元素的某些父元素的样式或类。\n示例，一个父组件：\n\u0026lt;!-- parent.component.html --\u0026gt; \u0026lt;app-my-component class=\u0026#34;special\u0026#34;\u0026gt;\u0026lt;/app-my-component\u0026gt; 在 MyComponent 的样式中：\n/* my-component.component.css */ :host-context(.special) { background-color: lightblue; } :host-context(.another-class) { background-color: lightgreen; } 在这个例子中：\n当 app-my-component 的外部元素（父元素）有 special 类时，MyComponent 会获得 background-color: lightblue 的样式。 当父元素有 another-class 时，background-color 会变为 lightgreen。 ::ng-deep # ::ng-deep 是一个 Angular 特有的伪类选择器，用于穿透组件的样式封装，允许你修改子组件或深层子元素的样式，即使这些子元素位于封装的视图中。\n由于 Angular 使用的是 视图封装（View Encapsulation），通常，组件的样式只会影响该组件内部的元素，不会影响到其子组件或外部元素。::ng-deep 允许你突破这种封装，影响子组件内部的样式。\n示例：一个子组件 ChildComponent，并且你想在父组件中修改 ChildComponent 的样式。可以使用 ::ng-deep：\n\u0026lt;!-- parent.component.html --\u0026gt; \u0026lt;app-child\u0026gt;\u0026lt;/app-child\u0026gt; 在父组件的样式中：\n/* parent.component.css */ ::ng-deep app-child .child-element { color: red; } 即使 app-child 有自己的封装样式，父组件仍然可以通过 ::ng-deep 来修改 app-child 内部的 .child-element 元素的样式。\n"}]