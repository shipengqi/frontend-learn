{"/frontend-learn/docs/framework/angular/01_overview/":{"data":{"":"","ngmodule#NgModule":"Angular 应用是由一个个模块组成的，称作 NgModule。\nNgModule 是一组相关功能的集合，专注于某个应用领域，可以将组件和一组相关代码关联起来，是应用组织代码结构的一种方式。\nNgModule 可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。\nNgModule 是由 NgModule 装饰器函数装饰的类。\nimport { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; @NgModule({ imports: [ BrowserModule ] }) export class AppModule { } @NgModule 元数据 NgModule 是一个带有 @NgModule() 装饰器的类。@NgModule() 元数据对象比较重要的属性：\ndeclarations 属于当前 NgModule 的组件、指令、管道。 exports 导出当前 NgModule 的组件、指令、管道的列表。 imports 导入的 NgModule、组件、指令、管道的列表。 providers 当前 NgModule 所需的服务。 bootstrap 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有 root module 才应该设置这个 bootstrap 属性。 ","服务#服务":"服务用于放置和特定组件无关并希望跨组件共享的数据或逻辑。\n服务出现的目的在于解耦组件类中的代码，是组件类中的代码干净整洁。\n服务是由 Injectable 装饰器装饰的类。\nimport { Injectable } from '@angular/core'; @Injectable({}) export class AppService { } 服务的实例对象由 Angular 框架中内置的依赖注入系统创建和维护。服务是依赖需要被注入到组件中。\n在组件中需要通过 constructor 构造函数的参数来获取服务的实例对象。\n在组件中获取服务实例对象，写法如下。\nimport { AppService } from \"./AppService\" export class AppComponent { constructor ( private appService: AppService ) {} } Angular 会根据你指定的服务的类型来传递你想要使用的服务实例对象。\n在 Angular 中服务被设计为单例模式，这也正是为什么服务可以被用来在组件之间共享数据和逻辑的原因。","组件#组件":"组件用来描述用户界面，它由三部分组成，组件类、组件模板、组件样式，它们可以被集成在组件类文件中，也可以是三个不同的文件。\n组件类用来编写和组件直接相关的界面逻辑，在组件类中要关联该组件的组件模板和组件样式。\n组件模板用来编写组件的 HTML 结构，通过数据绑定标记将应用中数据和 DOM 进行关联。\n组件样式用来编写组件的组件的外观，组件样式可以采用 CSS、LESS、SCSS、Stylus\n在 Angular 应用中至少要有一个根组件，用于应用程序的启动。\n组件类是由 Component 装饰器函数装饰的类。\nimport { Component } from \"@angular/core\" @Component({ selector: \"app-root\", templateUrl: \"./app.component.html\", styleUrls: [\"./app.component.css\"] }) export class AppComponent { title = \"angular-test\" } "},"title":"概述"},"/frontend-learn/docs/framework/angular/02_component/":{"data":{"":"","component-装饰器#Component 装饰器":" @Component({ // 指定组件的 CSS 选择器 // 选择器会告诉 Angular：当在模板 HTML 中找到相应的标签时，就把该组件实例化在那里。 selector: 'app-component-overview', // 定义 HTML 模板 // 在单独的文件中定义 HTML 模板 templateUrl: './component-overview.component.html', // HTML 模板也可以在组件中定义 // template: '\u003ch1\u003eHello World!\u003c/h1\u003e', // 多行 // template: ` // \u003ch1\u003eHello World!\u003c/h1\u003e // \u003cp\u003eThis template definition spans multiple lines.\u003c/p\u003e // ` // 声明组件的样式 // 在单独的文件中定义组件模板的样式 styleUrls: ['./component-overview.component.css'] // 组件模板的样式也可以在组件中定义 // styles 属性接受一个包含 CSS 规则的字符串数组 // styles: ['h1 { font-weight: normal; }'] // styles 属性接受一个包含 CSS 规则的字符串 // styles: `` }) preserveWhitespaces preserveWhitespaces 值为 false 时，从编译后的模板中移除可能多余的空白字符，为 true 时则保留，空白字符就是指那些能在 JavaScript 正则表达式中匹配 \\s 的字符。默认为 false。\ninterpolation Angular 默认模板插值器 {{}}。interpolation 属性可以用来指定插值器的符号。\n@Component({ template: ` \u003cdiv\u003e ((data)) \u003c/div\u003e `, // \"((\", \"))\" 代替 \"{{\", \"}}\" interpolation: [\"((\",\"))\"] }) export class AppComponent {} encapsulation 主要作用是控制样式的作用域和隔离性。在 Angular 中，组件的样式默认情况下是局部的，只有在该组件的模板中生效，但也可以通过配置不同的封装策略来改变这一行为。\nencapsulation 主要有三种取值：\nViewEncapsulation.Emulated（默认值）模拟浏览器原生的 Shadow DOM 来封装组件样式。Angular 会将组件的样式加上一些属性选择器（通常是基于组件的 ViewEncapsulation 设置），使得样式只作用于当前组件的模板。 ViewEncapsulation.None：使用此模式时，组件的样式将不受任何封装限制，样式会全局生效，任何在该组件中定义的样式都会作用于整个应用。 ViewEncapsulation.ShadowDom：此模式使用浏览器的原生 Shadow DOM 实现样式封装。组件的样式仅会应用于该组件的 Shadow DOM 内部，而不会影响外部或其他组件。 viewProviders 用于指定一个组件视图范围内的依赖注入（DI）提供者。它的作用是定义只在该组件的视图中可用的依赖，而不会影响到组件的父组件或其他地方。\n与 providers 的区别 providers 定义的是整个组件（包括视图和子视图）可以访问的服务，而 viewProviders 只在当前组件的视图中有效，作用范围较小。\nexportAs exportAs 是组件或指令的一个元数据属性，用于指定一个别名，使组件或指令可以通过模板中的 #templateReferenceVariable （模板引用变量）进行访问。\nimport { Directive } from '@angular/core'; @Directive({ selector: '[appHighlight]', exportAs: 'highlight' }) export class HighlightDirective { isHighlighted = false; toggleHighlight() { this.isHighlighted = !this.isHighlighted; } } 在模板中使用：\n\u003cdiv appHighlight #highlight=\"highlight\"\u003e Hover me to toggle highlight \u003c/div\u003e \u003cbutton (click)=\"highlight.toggleHighlight()\"\u003eToggle Highlight\u003c/button\u003e \u003cp\u003eHighlight Status: {{ highlight.isHighlighted }}\u003c/p\u003e host host 是组件或指令的一个元数据属性，用于设置宿主元素的行为和样式。它允许你在组件或指令的宿主元素上添加事件监听器、属性、类名和样式等。\nimport { Component } from '@angular/core'; @Component({ selector: 'app-example', template: `\u003cp\u003eHost Element Example\u003c/p\u003e`, host: { '[class.custom-class]': 'true', // 添加自定义类 '[attr.aria-label]': '\"Custom Label\"', // 设置属性 '(click)': 'onClick()', // 绑定 click 事件 '[style.background-color]': '\"lightblue\"', // 设置背景颜色 '[style.padding]': '\"10px\"' // 设置内边距 } }) export class ExampleComponent { onClick() { console.log('Host element clicked!'); } } HostBinding 和 HostListener @HostBinding、@HostListener 装饰器的功能和 host 属性类似，只不过使用方式不同。\n@HostBinding 用于将组件或指令的属性、样式、类等绑定到宿主元素。 @HostListener() 可以监听宿主元素上的事件。 官网的说明：\nHostBinding：用于把一个 DOM 属性标记为绑定到宿主的属性，并提供配置元数据。 Angular 在变更检测期间会自动检查宿主属性绑定，如果这个绑定变化了，它就会更新该指令所在的宿主元素。 HostListener：用于声明要监听的 DOM 事件，并提供在该事件发生时要运行的处理器方法。 import { Component, HostBinding } from '@angular/core'; @Component({ selector: 'app-example', template: `\u003cp\u003eHostBinding Example\u003c/p\u003e` }) export class ExampleComponent { @HostBinding('class.active') isActive = true; // 绑定宿主元素的类 @HostBinding('style.backgroundColor') backgroundColor = 'lightblue'; // 绑定背景色 @HostListener('click') onClick() { console.log('Host element clicked!'); } @HostListener('window:resize', ['$event']) onResize(event: Event) { console.log('Window resized', event); } } 使用 @HostBinding 和 @HostListener 可以提供更灵活的宿主元素交互，适用于需要动态响应事件或更改宿主元素样式和属性的场景。 使用 host 属性则更适合为宿主元素配置一些初始行为，如设置类、属性或事件监听器，但这些行为一旦定义就不会再变化。 ","事件绑定#事件绑定":" \u003cbutton (click)=\"onSave($event)\"\u003e按钮\u003c/button\u003e \u003c!-- 当按下回车键抬起的时候执行函数 --\u003e \u003cinput type=\"text\" (keyup.enter)=\"onKeyUp()\"/\u003e 事件对象是一个固定的名字就是 $event。","全局样式#全局样式":" /* 第一种方式 在 styles.css 文件中 */ @import \"~bootstrap/dist/css/bootstrap.css\"; /* ~ 相对node_modules文件夹 */ \u003c!-- 第二种方式 在 index.html 文件中 --\u003e \u003clink href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" rel=\"stylesheet\"/\u003e // 第三种方式 在 angular.json 文件中 \"styles\": [ \"./node_modules/bootstrap/dist/css/bootstrap.min.css\", \"src/styles.css\" ] ","内容投影#内容投影":" \u003c!-- app.component.html --\u003e \u003cbootstrap-panel\u003e \u003cdiv class=\"heading\"\u003e Heading \u003c/div\u003e \u003cdiv class=\"body\"\u003e Body \u003c/div\u003e \u003c/bootstrap-panel\u003e \u003c!-- panel.component.html --\u003e \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cng-content select=\".heading\"\u003e\u003c/ng-content\u003e \u003c/div\u003e \u003cdiv class=\"panel-body\"\u003e \u003cng-content select=\".body\"\u003e\u003c/ng-content\u003e \u003c/div\u003e \u003c/div\u003e 如果只有一个 ng-content，不需要 select 属性。直接 \u003cng-content\u003e\u003c/ng-content\u003e 就可以。\nng-content 在浏览器中会被 \u003cdiv class=\"heading\"\u003e\u003c/div\u003e 替代，如果不想要这个额外的 div，可以使用 ng-container 替代这个 div。\n\u003c!-- app.component.html --\u003e \u003cbootstrap-panel\u003e \u003cng-container class=\"heading\"\u003e Heading \u003c/ng-container\u003e \u003cng-container class=\"body\"\u003e Body \u003c/ng-container\u003e \u003c/bootstrap-panel\u003e ","双向数据绑定#双向数据绑定":"数据在组件类和组件模板中双向同步。\nAngular 将双向数据绑定功能放在了 @angular/forms 模块中，所以要实现双向数据绑定需要依赖该模块。\nimport {FormsModule} from \"@angular/forms\" @NgModule({ imports: [FormsModule], }) export class AppModule { } \u003cinput type=\"text\" [(ngModel)]=\"username\"/\u003e \u003cbutton (click)=\"change()\"\u003e在组件类中更改 username\u003c/button\u003e \u003cdiv\u003eusername: {{ username }}\u003c/div\u003e export class AppComponent { username: string = \"\" change() { this.username = \"hello Angular\" } } 双向绑定工作原理 为了使双向数据绑定生效，子组件必须包含：\n一个 @Input() 属性。 一个对应的 @Output() 事件发射器，其名称必须与输入属性相同，并在结尾加上 Change。该发射器还必须发射与输入属性相同类型的值。 例如，如果 @Input() 属性是 size，则 @Output() 属性必须是 sizeChange。 一个方法，该方法通过事件发射器发射更新后的 @Input() 值。 子组件：\n// './counter/counter.component.ts'; import { Component, EventEmitter, Input, Output } from '@angular/core'; @Component({ // Omitted for brevity }) export class CounterComponent { @Input() count: number; @Output() countChange = new EventEmitter\u003cnumber\u003e(); updateCount(amount: number): void { this.count += amount; this.countChange.emit(this.count); } } 父组件，使用双向绑定语法 [()] 包裹 @Input() 属性名称：\n// ./app.component.ts import { Component } from '@angular/core'; import { CounterComponent } from './counter/counter.component'; @Component({ selector: 'app-root', imports: [CounterComponent], template: ` \u003cmain\u003e \u003capp-counter [(count)]=\"initialCount\"\u003e\u003c/app-counter\u003e \u003c/main\u003e `, }) export class AppComponent { initialCount = 18; } ngModel 指令也是类似的原理来实现双向绑定的，底层是结合了属性绑定和事件绑定的机制：\n属性绑定 [ngModel] 事件绑定 (ngModelChange) Angular 内置的表单控件（如 \u003cinput\u003e、\u003ctextarea\u003e）支持直接使用 ngModel。而自定义控件需要显式地实现与 ngModel 的交互机制。","变更检测机制#变更检测机制":"Angular 的变更检测（Change Detection）机制用于检测组件的状态变化，并更新视图，使数据与 UI 保持同步。Angular 通过 Zone.js 监听异步任务（如事件、XHR、setTimeout等）来触发变更检测，并通过 View Hierarchy（视图层次结构）遍历组件树来检查数据变更。变更检测是 Angular 中的核心功能之一，它决定了应用的响应性和性能。\n变更检测的触发时机 变更检测是由 Angular 的变更检测机制触发的，主要触发时机包括：\n用户事件：如按钮点击、输入框文本变化等，都会触发变更检测。 异步操作：如 HTTP 请求返回数据，或者 setTimeout()、Promise 解决等，都可能触发变更检测。 手动触发：通过 ChangeDetectorRef.detectChanges() 或 ChangeDetectorRef.markForCheck()，手动通知 Angular 检查某个组件或视图。 变更检测策略 ChangeDetectionStrategy 提供了两种变更检测策略：\nChangeDetectionStrategy.Default：每次变更检测都会遍历组件树的所有组件（即使数据未变）。 ChangeDetectionStrategy.OnPush：使用 OnPush 策略时，只会在以下几种情况之一时检查组件的变化： 输入属性（@Input()）的值发生变化。 事件处理器被触发（如点击、输入等）。 手动调用 ChangeDetectorRef.detectChanges() 或 ChangeDetectorRef.markForCheck()。 ChangeDetectorRef 的使用 ChangeDetectorRef 提供了更精细的变更检测控制：\ndetectChanges() 方法用于手动触发变更检测。它会立即检查当前组件及其子组件的变更，并更新视图。 markForCheck() 方法用于标记当前组件或视图需要进行变更检测。它不会立即触发变更检测，而是将标记添加到变更检测队列中。在使用 OnPush 变更检测策略时，组件只会在特定条件下进行检测。如果希望在某些情况下让组件在下一次变更检测周期中被检查，可以使用 markForCheck() 。这样可以避免不必要的检测，提高应用性能。 detach()：停止当前组件的变更检测，提升性能（适用于高频率变化的组件，如股票数据）。 reattach()：恢复变更检测。 变更检测的执行流程 应用状态更新（事件、HTTP 响应等）。 触发 Zone.js，通知 Angular 运行变更检测。 遍历组件树，检查每个组件的 @Input 或本地状态。 更新视图，若检测到变化，则渲染 UI。 变更检测的性能优化 减少不必要的变更检测：使用 ChangeDetectionStrategy.OnPush 策略。 不可变数据结构：推荐使用不可变数据结构。当数据发生变化时，创建一个新的数据对象，而不是修改现有对象。这样，Angular 可以通过比较对象的引用，快速判断数据是否发生了变化。 避免在模板中使用复杂的表达式：在模板中使用复杂的表达式可能会导致变更检测的性能下降。尽量将复杂的逻辑移到组件类中进行处理。 使用 *ngIf 或 *ngFor 时，确保正确设置 trackBy 函数：提供 trackBy 函数可以帮助 Angular 跟踪每个列表项的身份，避免不必要的 DOM 操作。 减少不必要的事件绑定：在模板中使用事件绑定时，确保只绑定必要的事件。避免在模板中绑定不必要的事件，以减少变更检测的次数。 ℹ️ @Input() 修饰的对象如果其某个属性发生变化，不会自动触发变更检测，除非该对象的引用发生变化。这是因为 Angular 的变更检测机制在比较数据时，使用引用比较。这意味着当数据发生变化时，Angular 会检查对象的引用是否改变，而不是对象的内容。如果对象的引用没有改变，Angular 会认为数据没有发生变化，从而避免不必要的变更检测。 ","属性绑定#属性绑定":"普通属性 属性绑定分为两种情况，绑定 DOM 对象属性和绑定 HTML 标记属性。\n使用 [属性名称] 为元素绑定 DOM 对象属性。\n\u003cimg [src]=\"imgUrl\"/\u003e 使用 [attr.属性名称] 为元素绑定 HTML 标记属性\n\u003ctd [attr.colspan]=\"colSpan\"\u003e\u003c/td\u003e 在大多数情况下，DOM 对象属性和 HTML 标记属性是对应的关系，所以使用第一种情况。但是某些属性只有 HTML 标记存在，DOM 对象中不存在，此时需要使用第二种情况，比如 colspan 属性，在 DOM 对象中就没有，或者自定义 HTML 属性也需要使用第二种情况。\nclass 属性 \u003cbutton class=\"btn btn-primary\" [class.active]=\"isActive\"\u003e按钮\u003c/button\u003e \u003cdiv [ngClass]=\"{'active': true, 'error': true}\"\u003e\u003c/div\u003e ngClass 可以绑定多个类名。\nstyle 属性 \u003cbutton [style.backgroundColor]=\"isActive ? 'blue': 'red'\"\u003e按钮\u003c/button\u003e \u003cbutton [ngStyle]=\"{'backgroundColor': 'red'}\"\u003e按钮\u003c/button\u003e ngClass 可以绑定多个样式属性。","数据绑定#数据绑定":"数据绑定就是将组件类中的数据显示在组件模板中，当组件类中的数据发生变化时会自动被同步到组件模板中（数据驱动 DOM ）。\n在 Angular 中使用差值表达式进行数据绑定，即 {{ }}。\n\u003ch2\u003e{{message}}\u003c/h2\u003e \u003ch2\u003e{{getInfo()}}\u003c/h2\u003e \u003ch2\u003e{{a == b ? '相等': '不等'}}\u003c/h2\u003e \u003ch2\u003e{{'Hello Angular'}}\u003c/h2\u003e \u003cp [innerHTML]=\"htmlSnippet\"\u003e\u003c/p\u003e \u003c!-- 对数据中的代码进行转义 --\u003e ","数据绑定容错处理#数据绑定容错处理":"当绑定的对象数据层级比较深，并且对象中的某些属性是可选的。如果不做容错处理，当访问的属性不存在时，就会报错。\n// app.component.ts export class AppComponent { task = { person: { name: '张三' } } } \u003c!-- 方式一 --\u003e \u003cspan *ngIf=\"task.person\"\u003e{{ task.person.name }}\u003c/span\u003e \u003c!-- 方式二 --\u003e \u003cspan\u003e{{ task.person?.name }}\u003c/span\u003e ","获取原生-dom-对象#获取原生 DOM 对象":"在组件模板中获取 在模板中，可以用 # 来声明一个模板变量。模板变量，可以在组件模板中的任何地方引用。\n\u003cinput type=\"text\" (keyup.enter)=\"onKeyUp(username.value)\" #username/\u003e 在组件类中获取 使用 ViewChild 装饰器获取一个元素\n\u003cp #paragraph\u003ehome works!\u003c/p\u003e import {AfterViewInit, ElementRef, ViewChild} from \"@angular/core\" export class HomeComponent implements AfterViewInit { @ViewChild(\"paragraph\") paragraph: ElementRef\u003cHTMLParagraphElement\u003e | undefined ngAfterViewInit() { console.log(this.paragraph?.nativeElement) } } 使用 ViewChildren 获取一组元素\n\u003cul\u003e \u003cli #items\u003ea\u003c/li\u003e \u003cli #items\u003eb\u003c/li\u003e \u003cli #items\u003ec\u003c/li\u003e \u003c/ul\u003e import {AfterViewInit, QueryList, ViewChildren} from \"@angular/core\" @Component({ selector: \"app-home\", templateUrl: \"./home.component.html\", styles: [] }) export class HomeComponent implements AfterViewInit { @ViewChildren(\"items\") items: QueryList\u003cHTMLLIElement\u003e | undefined ngAfterViewInit() { console.log(this.items?.toArray()) // items 中的元素无法直接使用，需要先使用 toArray 转换成一个数组 } } ContentChild, ContentChildren ContentChildren 属性装饰器用来从通过 Content Projection 方式设置的视图中获取 ng-content 里面匹配的多个元素。 ContentChild 类似 ContentChildren，不过返回的是一个元素。 ContentChild 和 ViewChild 的区别：\nContentChild 用来从通过 Content Projection 方式 (ng-content) 设置的视图中获取匹配的元素。 ViewChild 匹配的元素在组件的模板中定义的内容，它是组件的一部分。 "},"title":"组件模板"},"/frontend-learn/docs/framework/angular/03_communication/":{"data":{"":"","向组件内部传递数据#向组件内部传递数据":"Input 装饰器 \u003capp-favorite [isFavorite]=\"true\"\u003e\u003c/app-favorite\u003e // favorite.component.ts import { Input } from '@angular/core'; export class FavoriteComponent { @Input() isFavorite: boolean = false; } 注意：在属性的外面加 [] 表示绑定动态值，对于布尔类型，不加 [] 表示绑定普通值，例如 true 在组件内接收后是字符串 \"true\"。\n\u003capp-favorite [is-Favorite]=\"true\"\u003e\u003c/app-favorite\u003e import { Input } from '@angular/core'; export class FavoriteComponent { @Input(\"is-Favorite\") isFavorite: boolean = false } 属性别名 通过给 @Input() 装饰器传递参数，可以重命名属性。\nimport { Component, Input } from '@angular/core'; @Component({ selector: 'app-child', template: `\u003cp\u003e{{ myValue }}\u003c/p\u003e`, }) export class ChildComponent { @Input('parentValue') myValue!: string; // 父组件使用 \"parentValue\" 绑定 } 父组件：\n\u003capp-child [parentValue]=\"'Hello'\"\u003e\u003c/app-child\u003e 使用别名可以避免某些属性名可能与 DOM 属性或全局对象名称冲突。例如：\n@Component({ selector: 'app-child', template: `\u003cp\u003e{{ id }}\u003c/p\u003e`, }) export class ChildComponent { @Input('customId') id!: string; // 避免与 DOM 的 id 属性冲突 } booleanAttribute @Input 装饰器可以传入参数 {transform: booleanAttribute}，用于将字符串类型的布尔属性（HTML 属性中传递的布尔值通常是字符串）转换为真正的 JavaScript 布尔值的机制。\n用途：\n在 HTML 中，布尔属性（如 disabled, checked, readonly）如果存在，则会被解析为字符串，即使没有显式赋值。例如：\n\u003cinput disabled /\u003e disabled 属性的值在 JavaScript 中是 \"true\"，而不是一个真正的布尔值 true。{transform: booleanAttribute} 可以自动将这种字符串值转换为布尔值。\n示例：\nimport { Component, Input } from '@angular/core'; @Component({ selector: 'app-boolean-example', template: `\u003cp\u003eThe button is {{ disabled ? 'Disabled' : 'Enabled' }}\u003c/p\u003e`, }) export class BooleanExampleComponent { @Input({ transform: booleanAttribute }) disabled = false; // 默认为 false } 父组件：\n\u003capp-boolean-example disabled\u003e\u003c/app-boolean-example\u003e 在父组件中传递 disabled，即使不显式赋值，它也会被识别为 true。 如果未传递 disabled 属性，子组件中的 disabled 属性值会保留默认值 false。 ","向组件外部传递数据#向组件外部传递数据":"Output 装饰器 \u003c!-- 子组件模板 --\u003e \u003cbutton (click)=\"onClick()\"\u003eclick\u003c/button\u003e // 子组件类 import { EventEmitter, Output } from \"@angular/core\" export class FavoriteComponent { @Output() change = new EventEmitter() onClick() { this.change.emit({ name: \"张三\" }) } } \u003c!-- 父组件模板 --\u003e \u003capp-favorite (change)=\"onChange($event)\"\u003e\u003c/app-favorite\u003e // 父组件类 export class AppComponent { onChange(event: { name: string }) { console.log(event) } } ","父组件与子组件通过本地变量互动#父组件与子组件通过本地变量互动":"父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法：\n子组件 CountdownTimerComponent：\n@Component({ selector: 'app-countdown-timer', template: '\u003cp\u003e{{message}}\u003c/p\u003e' }) export class CountdownTimerComponent implements OnDestroy { intervalId = 0; message = ''; seconds = 11; ngOnDestroy() { this.clearTimer(); } start() { this.countDown(); } stop() { this.clearTimer(); this.message = `Holding at T-${this.seconds} seconds`; } private clearTimer() { clearInterval(this.intervalId); } private countDown() { // ... } } 父组件 CountdownLocalVarParentComponent：\n@Component({ selector: 'app-countdown-parent-lv', template: ` \u003ch3\u003eCountdown to Liftoff (via local variable)\u003c/h3\u003e \u003cbutton type=\"button\" (click)=\"timer.start()\"\u003eStart\u003c/button\u003e \u003cbutton type=\"button\" (click)=\"timer.stop()\"\u003eStop\u003c/button\u003e \u003cdiv class=\"seconds\"\u003e{{timer.seconds}}\u003c/div\u003e \u003capp-countdown-timer #timer\u003e\u003c/app-countdown-timer\u003e `, styleUrls: ['../assets/demo.css'] }) export class CountdownLocalVarParentComponent { } 父组件不能通过数据绑定使用子组件的 start 和 stop 方法，也不能访问子组件的 seconds 属性。把本地变量(#timer)放到(\u003ccountdown-timer\u003e)标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，可以在父组件的模板中访问子组件的属性和方法。"},"title":"组件通讯"},"/frontend-learn/docs/framework/angular/04_lifecycle/":{"data":{"":"生命周期钩子执行顺序：\nngOnChanges：当组件的输入属性（@Input）发生变化时会调用。 ngOnInit：当组件初始化时被调用。这通常在 Angular 初始化组件并绑定所有输入属性后触发。 ngDoCheck：在每次 Angular 检查组件变化时被调用。它比 ngOnChanges 更加底层，允许自定义检测逻辑。 ngAfterContentInit：当组件的内容投影（\u003cng-content\u003e）初始化完成后触发。这个钩子在 Angular 投影内容进入组件后调用一次。 ngAfterContentChecked：当 Angular 完成对组件内容投影的变更检测后调用。 ngAfterViewInit：当组件的视图（包括子组件的视图）初始化完成后调用。也就是说，它在视图的所有子组件和模板内容都加载完毕后触发。 ngAfterViewChecked：每次视图（包括子视图）变更检测之后调用。它会在 Angular 每次更新视图之后触发。 ngOnDestroy：当组件销毁之前调用。可以用来执行清理工作，如取消订阅、清理定时器等。 ","卸载阶段#卸载阶段":" ngOnDestroy\n当组件被销毁之前调用, 用于清理操作。\nexport class HomeComponent implements OnDestroy { ngOnDestroy() { console.log(\"组件被卸载\") } } ","挂载阶段#挂载阶段":"挂载阶段的生命周期函数只在挂载阶段执行一次，数据更新时不再执行。\nconstructor\nAngular 在实例化组件类时执行, 可以用来接收 Angular 注入的服务实例对象。\nexport class ChildComponent { constructor (private test: TestService) { console.log(this.test) // \"test\" } } ngOnInit\nngOnInit 会在组件的输入属性被绑定之后被调用，适合在组件加载时执行需要的初始化工作。\n\u003capp-child name=\"张三\"\u003e\u003c/app-child\u003e export class ChildComponent implements OnInit { @Input(\"name\") name: string = \"\" ngOnInit() { console.log(this.name) // \"张三\" } } ngAfterContentInit\n组件的内容投影（\u003cng-content\u003e）初始化完成后触发。这个钩子在 Angular 投影内容进入组件后调用一次。适用于当你需要在内容投影完成后执行某些操作时。\n\u003capp-child\u003e \u003cdiv #box\u003eHello Angular\u003c/div\u003e \u003c/app-child\u003e export class ChildComponent implements AfterContentInit { @ContentChild(\"box\") box: ElementRef\u003cHTMLDivElement\u003e | undefined ngAfterContentInit() { console.log(this.box) // \u003cdiv\u003eHello Angular\u003c/div\u003e } } ngAfterViewInit\n当组件的视图（包括子组件的视图）初始化完成后调用。也就是说，它在视图的所有子组件和模板内容都加载完毕后触发。适用于你需要在组件视图完全初始化之后执行某些操作的场景。\n\u003c!-- app-child 组件模板 --\u003e \u003cp #p\u003eapp-child works\u003c/p\u003e export class ChildComponent implements AfterViewInit { @ViewChild(\"p\") p: ElementRef\u003cHTMLParagraphElement\u003e | undefined ngAfterViewInit () { console.log(this.p) // \u003cp\u003eapp-child works\u003c/p\u003e } } ","更新阶段#更新阶段":" ngOnChanges\n当输入属性值发生变化时执行，初始设置时也会执行一次，顺序优于 ngOnInit。 不论多少输入属性同时变化，钩子函数只会执行一次，变化的值会同时存储在参数中。 参数接收一个 SimpleChanges 对象，包含了所有已变更的输入属性的当前值和上一个值。 对于基本数据类型来说, 只要值发生变化就可以被检测到。 对于引用数据类型来说, 可以检测从一个对象变成另一个对象（引用地址发生了改变）, 但是检测不到同一个对象中属性值的变化，但是不影响组件模板更新数据。 基本数据类型值变化：\n\u003capp-child [name]=\"name\" [age]=\"age\"\u003e\u003c/app-child\u003e \u003cbutton (click)=\"change()\"\u003echange\u003c/button\u003e export class AppComponent { name: string = \"张三\"; age: number = 20 change() { this.name = \"李四\" this.age = 30 } } export class ChildComponent implements OnChanges { @Input(\"name\") name: string = \"\" @Input(\"age\") age: number = 0 ngOnChanges(changes: SimpleChanges) { console.log(\"基本数据类型值变化可以被检测到\") if (changes['name']) { const currentValue = changes['name'].currentValue; const previousValue = changes['name'].previousValue; const firstChange = changes['name'].firstChange; console.log(`Name changed from ${previousValue} to ${currentValue}`); if (firstChange) { console.log('This is the first change'); } } } } 引用数据类型变化：\n\u003capp-child [person]=\"person\"\u003e\u003c/app-child\u003e \u003cbutton (click)=\"change()\"\u003echange\u003c/button\u003e export class AppComponent { person = { name: \"张三\", age: 20 } change() { this.person = { name: \"李四\", age: 30 } } } export class ChildComponent implements OnChanges { @Input(\"person\") person = { name: \"\", age: 0 } ngOnChanges(changes: SimpleChanges) { console.log(\"对于引用数据类型, 只能检测到引用地址发生变化, 对象属性变化不能被检测到\") } } ngDoCheck：在每次 Angular 检查组件变化时被调用。它比 ngOnChanges 更加底层，允许自定义检测逻辑。主要用于调试，只要输入属性发生变化，不论是基本数据类型还是引用数据类型还是引用数据类型中的属性变化，都会执行。\nngAfterContentChecked：当 Angular 完成对组件内容投影的变更检测后调用。适用于检测投影内容的变化。\nngAfterViewChecked：每次视图（包括子视图）变更检测之后调用。它会在 Angular 每次更新视图之后触发。用于在视图检查之后执行一些操作，如处理视图上的 DOM 操作。"},"title":"组件生命周期"},"/frontend-learn/docs/framework/angular/05_directive/":{"data":{"":"指令是 Angular 提供的操作 DOM 的途径。指令分为属性指令和结构指令。\n属性指令：修改现有元素的外观或行为，selector 使用 [] 包裹。\n结构指令：增加、删除 DOM 节点以修改布局，使用 * 作为指令前缀。","内置指令#内置指令":"*ngIf 根据条件渲染 DOM 节点或移除 DOM 节点。\n\u003cdiv *ngIf=\"data.length == 0\"\u003e没有更多数据\u003c/div\u003e \u003cdiv *ngIf=\"data.length \u003e 0; then dataList else noData\"\u003e\u003c/div\u003e \u003cng-template #dataList\u003e课程列表\u003c/ng-template\u003e \u003cng-template #noData\u003e没有更多数据\u003c/ng-template\u003e [hidden] 根据条件显示 DOM 节点或隐藏 DOM 节点。\n\u003cdiv [hidden]=\"data.length == 0\"\u003e课程列表\u003c/div\u003e \u003cdiv [hidden]=\"data.length \u003e 0\"\u003e没有更多数据\u003c/div\u003e *ngFor 遍历数据生成HTML结构\ninterface List { id: number name: string age: number } list: List[] = [ { id: 1, name: \"张三\", age: 20 }, { id: 2, name: \"李四\", age: 30 } ] \u003cli *ngFor=\" let item of list; let i = index; // 下标 let isEven = even; // 是否是第偶数个元素 let isOdd = odd; // 是否是第奇数个元素 let isFirst = first; // 是否是第一个元素 let isLast = last; // 是否是最后一个元素 \" \u003e \u003c/li\u003e trackBy 在 Angular 中遍历数组时，会用到 ngFor 指令，如果数组中的数据改变了（新数组替换旧数组），Angular 会删除与数据关联的所有 DOM 元素，然后再次创建它们。这意味着将有很多 DOM 操作。\n使用 *ngFor 的 trackBy 属性，Angular 可以仅更改和重新渲染那些已更改的条目，而不是重新加载整个条目列表。\ntrackByItems(index: number, item: Item): number { return item.id; // 只需要返回一个唯一标识就好了 } \u003cdiv *ngFor=\"let item of items; trackBy: trackByItems\"\u003e ({{ item.id }}) {{ item.name }} \u003c/div\u003e 使用 trackBy 的好处是自定义返回跟踪结果，以比对上次的跟踪结果，如果不一样，那么就刷新变化的页面实例（减少不必要的 Dom 刷新而带来性能的提升）。\n自定义指令 需求：为元素设置默认背景颜色，鼠标移入时的背景颜色以及移出时的背景颜色。\n\u003cdiv [appHover]=\"{ bgColor: 'skyblue' }\"\u003eHello Angular\u003c/div\u003e import { AfterViewInit, Directive, ElementRef, HostListener, Input } from \"@angular/core\" // 接收参的数类型 interface Options { bgColor?: string } @Directive({ selector: \"[appHover]\" }) export class HoverDirective implements AfterViewInit { // 接收参数 @Input(\"appHover\") appHover: Options = {} // 要操作的 DOM 节点 element: HTMLElement // 获取要操作的 DOM 节点 constructor(private elementRef: ElementRef) { this.element = this.elementRef.nativeElement } // 组件模板初始完成后设置元素的背景颜色 ngAfterViewInit() { this.element.style.backgroundColor = this.appHover.bgColor || \"skyblue\" } // 为元素添加鼠标移入事件 @HostListener(\"mouseenter\") enter() { this.element.style.backgroundColor = \"pink\" } // 为元素添加鼠标移出事件 @HostListener(\"mouseleave\") leave() { this.element.style.backgroundColor = \"skyblue\" } } "},"title":"指令"},"/frontend-learn/docs/framework/angular/06_pipe/":{"data":{"":"管道的作用是转换组件模板数据。要在 HTML 模板中指定值的转换方式，使用管道操作符 |。","内置管道#内置管道":" date 日期格式化 currency 货币格式化 uppercase 转大写 lowercase 转小写 json 格式化 json 数据 {{ date | date: \"yyyy-MM-dd\" }} {{ num | currency: \"￥\" }} // ￥{num} ","自定义管道#自定义管道":"需求：指定字符串不能超过规定的长度\n// summary.pipe.ts import { Pipe, PipeTransform } from '@angular/core'; @Pipe({ name: 'summary' }); export class SummaryPipe implements PipeTransform { transform (value: string, limit?: number) { if (!value) return null; let actualLimit = (limit) ? limit : 50; return value.substr(0, actualLimit) + '...'; } } // app.module.ts import { SummaryPipe } from './summary.pipe' @NgModule({ declarations: [ SummaryPipe ] }); 使用管道：\n\u003cdiv\u003e {{ 'test' | summary: 100 }} \u003c/div\u003e 管道传参，使用 : 分隔，如果有多个参数，每个参数之间用 : 分隔（| summary: 100: 200）。"},"title":"管道"},"/frontend-learn/docs/framework/angular/07_di/":{"data":{"":"依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的耦合度。\nclass MailService { constructor(APIKEY) {} } class EmailSender { mailService: MailService constructor() { this.mailService = new MailService(\"APIKEY1234567890\") } sendMail(mail) { this.mailService.sendMail(mail) } } const emailSender = new EmailSender() emailSender.sendMail(mail) EmailSender 类运行时要依赖 MailService 类。\n以上写法的耦合度太高，代码并不健壮。如果 MailService 类改变了参数的传递方式，在 EmailSender 的构造函数中的写法也要跟着改变。\nclass EmailSender { mailService: MailService constructor(mailService: MailService) { this.mailService = mailService; } } const mailService = new MailService(\"APIKEY1234567890\") const emailSender = new EmailSender(mailService) 在实例化 EmailSender 类时将它的依赖项通过 constructor 构造函数参数的形式注入到类的内部，这种写法就是依赖注入。\n通过依赖注入降了代码之间的耦合度，增加了代码的可维护性。MailService 类中代码的更改再也不会影响 EmailSender 类。","di-框架#DI 框架":"Angular 有自己的 DI 框架，它将实现依赖注入的过程隐藏了，对于开发者来说只需使用很简单的代码就可以使用复杂的依赖注入功能。\n在 Angular 的 DI 框架中有四个核心概念：\nDependency：组件要依赖的实例对象，服务实例对象 Token：获取服务实例对象的唯一标识 Injector：注入器，负责创建维护服务类的实例对象并向组件中注入服务实例对象。 Provider：配置注入器的对象，指定创建服务实例对象的服务类和获取实例对象的标识。 注入器 Injectors 注入器负责创建服务类实例对象，并将服务类实例对象注入到需要的组件中。\n创建注入器\nimport { ReflectiveInjector } from \"@angular/core\" // 服务类 class MailService {} // 创建注入器并传入服务类 // 服务实例对象的标识，默认就是类的名字 const injector = ReflectiveInjector.resolveAndCreate([MailService]) 获取注入器中的服务类实例对象\nconst mailService = injector.get(MailService) 服务实例对象为单例模式，注入器在创建服务实例后会对其进行缓存\nconst mailService1 = injector.get(MailService) const mailService2 = injector.get(MailService) console.log(mailService1 === mailService2) // true 不同的注入器返回不同的服务实例对象\nconst injector = ReflectiveInjector.resolveAndCreate([MailService]) // 创建一个子注入器 const childInjector = injector.resolveAndCreateChild([MailService]) const mailService1 = injector.get(MailService) const mailService2 = childInjector.get(MailService) console.log(mailService1 === mailService2) // false 服务实例的查找类似函数作用域链，当前级别可以找到就使用当前级别，当前级别找不到去父级中查找\nconst injector = ReflectiveInjector.resolveAndCreate([MailService]) // 创建一个子注入器 const childInjector = injector.resolveAndCreateChild([]) const mailService1 = injector.get(MailService) // 由于子级注入器没有 MailService，就会去父级注入器查找，所以这里拿到的 MailService 是属于父级注入器的 const mailService2 = childInjector.get(MailService) console.log(mailService1 === mailService2) // true 提供者 Provider 配置注入器的对象，通过 Provider 就可以让注入器知道使用哪个类来创建实例对象，访问这个实例对象的唯一标识是什么。\nconst injector = ReflectiveInjector.resolveAndCreate([ { provide: MailService, useClass: MailService } ]) useClass：创建实例对象所使用的类。 provide：Token 访问实例对象的唯一标识 访问依赖对象的标识也可以是字符串类型\nconst injector = ReflectiveInjector.resolveAndCreate([ { provide: \"mail\", useClass: MailService } ]) const mailService = injector.get(\"mail\") useValue 允许将一个静态值与 DI 令牌关联起来。\nconst injector = ReflectiveInjector.resolveAndCreate([ { provide: \"Config\", // Object.freeze 冻结对象，不允许外部修改 useValue: Object.freeze({ APIKEY: \"API1234567890\", APISCRET: \"500-400-300\" }) } ]) const Config = injector.get(\"Config\") useFactory 允许通过调用工厂函数创建一个依赖对象。通过这种方式，你可以基于 DI 和应用中可用的信息创建一个动态值。\nconst heroServiceFactory = (logger: Logger, userService: UserService) =\u003e new HeroService(logger, userService.user.isAuthorized); export const heroServiceProvider = { provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService] }; deps 属性是一个提供者令牌数组。 Logger 和 UserService 类作为它们自身类提供者的令牌。 注入器会根据指定的顺序将相应的服务注入到匹配的 heroServiceFactory 工厂函数参数中。\n将实例对象和外部的引用建立了松耦合关系，外部通过标识获取实例对象，只要标识保持不变，内部代码怎么变都不会影响到外部。\nInjectionToken InjectionToken 对象的使用场景：\n来为非类的依赖选择一个提供者令牌。 自定义注入行为或提供动态值。 语法：\nconst MY_TOKEN = new InjectionToken\u003cT\u003e('描述信息', { factory?: () =\u003e T; // 默认值的工厂函数 providedIn?: 'root' | 'platform' | 'any' | null; // 提供范围 }); factory：如果没有在 providers 中显式提供值，则注入时会使用该工厂函数返回的默认值。 定义了一个类型为 InjectionToken 的 APP_CONFIG：\nimport { InjectionToken } from '@angular/core'; export const APP_CONFIG = new InjectionToken\u003cAppConfig\u003e('app.config'); 参数类型是可选的 \u003cAppConfig\u003e，'app.config' 是令牌的描述，指明了此令牌的用途。\n接着，在组件中注册这个依赖提供者：\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }] 最后，借助参数装饰器 @Inject()，你可以把这个配置对象注入到构造函数中：\nconstructor(@Inject(APP_CONFIG) config: AppConfig) { this.title = config.title; } @Inject 装饰器 @Inject 装饰器用于显式地指定要注入的依赖项。虽然 Angular 的依赖注入（DI）通常是通过构造函数注入来自动推断类型的，但是这是基于类的类型进行注入的。 在某些情况下，Angular 无法自动推断要注入的类型或参数（比如非类的依赖项，常量，值，接口等），这时就需要使用 @Inject 装饰器。\n注入值：\n@NgModule({ providers: [ { provide: 'myValue', useValue: 28 } ] }) export class AppModule {} 这里注入的值是 hardcode 的，如果需要动态值可以使用 InjectionToken。\n@Injectable() export class MyService { constructor(@Inject('myValue') private value: number) { console.log(this.value); // 28 } } 注入接口：\ninterface User { name: string; age: number; } @Injectable({ providedIn: 'root' }) export class MyService { constructor(@Inject('user') private user: User) { console.log(this.user.name); } } 提供 user 时可以使用 useValue 或者其他方式提供接口类型：\nconst user = { name: 'John', age: 30 }; @NgModule({ providers: [ { provide: 'user', useValue: user } ] }) export class AppModule {} inject() 函数 在 Angular 中，依赖注入（DI）有两种常见的方式：\n通过构造函数注入依赖 通过 inject() 函数来注入依赖 虽然两者都实现了依赖注入的目标，但它们在使用方式、场景和目的上有所不同。\n通过构造函数注入依赖 构造函数注入是 Angular 中最常见的依赖注入方式。在类的构造函数中，Angular 会自动分析参数的类型，并从应用程序的依赖注入容器中查找并注入匹配的依赖项。\n更符合 Angular 的编程模型和规范。 这种方式必须在类中使用：构造函数注入只能用于类（比如组件、服务等），不适用于其他类型（如普通函数）。 inject() inject() 函数是 Angular 9 中引入的一个新的 API，通常用于不依赖类构造函数注入的场景中使用。例如某些功能函数、工厂函数或外部注入的场景。\n对于无法直接使用构造函数注入时，它非常有用。"},"title":"依赖注入"},"/frontend-learn/docs/framework/angular/08_service/":{"data":{"":"","创建服务#创建服务":" import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class TestService { } 使用：\nexport class AppComponent { // 这里的 TestService 实际上就是获取示例对象的 Token（唯一标识） constructor (private _test: TestService) {} } ","服务的作用域#服务的作用域":"使用服务可以轻松实现跨模块跨组件共享数据，这取决于服务的作用域。\n在根注入器中注册服务，所有模块使用同一个服务实例对象。\nimport { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class CarListService { } 在模块级别注册服务，该模块中的所有组件使用同一个服务实例对象。\n新语法：\nimport { Injectable } from '@angular/core'; import { CarModule } from './car.module'; @Injectable({ providedIn: CarModule, }) export class CarListService { } 老语法：\nimport { CarListService } from './car-list.service'; @NgModule({ providers: [CarListService], }) export class CarModule { } 在组件级别注册服务，该组件及其子组件使用同一个服务实例对象。\nimport { Component } from '@angular/core'; import { CarListService } from '../car-list.service.ts' @Component({ selector: 'app-car-list', templateUrl: './car-list.component.html', providers: [CarListService] }) ℹ️ providedIn: 'root' 只是指明服务是全局单例的，这意味着整个应用中只有一个服务实例，通常用于跨多个组件和服务共享的场景。 但是，providedIn: 'root' 仍然可以在组件或模块的 providers 数组中重新提供该服务，这样它在该组件或模块中会有一个单独的实例， 其他地方仍然会使用全局单例实例。 "},"title":"服务"},"/frontend-learn/docs/framework/angular/09_form/":{"data":{"":"在 Angular 中，表单有两种类型，分别为模板驱动表单和响应式表单。","响应式表单#响应式表单":"概述 表单的控制逻辑写在组件类中，对验证逻辑拥有更多的控制权，适合复杂的表单的类型。\n在响应式表单中，表单字段需要是 FormControl 类的实例，实例对象可以验证表单字段中的值，值是否被修改过等等。\n一组表单字段构成整个表单，整个表单需要是 FormGroup 类的实例，它可以对表单进行整体验证。\nFormControl：表单组中的一个表单项 FormGroup：表单组，表单至少是一个 FormGroup FormArray：用于复杂表单，可以动态添加表单项或表单组，在表单验证时，FormArray 中有一项没通过，那么整体就不会通过。 快速上手 引入 ReactiveFormsModule\nimport { ReactiveFormsModule } from \"@angular/forms\" @NgModule({ imports: [ReactiveFormsModule] }) export class AppModule {} 在组件类中创建 FormGroup 表单控制对象\nimport { FormControl, FormGroup } from \"@angular/forms\" export class AppComponent { contactForm: FormGroup = new FormGroup({ name: new FormControl(), phone: new FormControl() }) } 使用 formGroup 来绑定一组表单控件，使用 formControlName 来绑定每个表单控件。\n\u003cform [formGroup]=\"contactForm\" (submit)=\"onSubmit()\"\u003e \u003cinput type=\"text\" formControlName=\"name\" /\u003e \u003cinput type=\"text\" formControlName=\"phone\" /\u003e \u003cbutton\u003e提交\u003c/button\u003e \u003c/form\u003e 获取表单值\nexport class AppComponent { onSubmit() { console.log(this.contactForm.value) } } 设置表单默认值\ncontactForm: FormGroup = new FormGroup({ name: new FormControl(\"默认值\"), phone: new FormControl(15888888888) }) 表单分组\ncontactForm: FormGroup = new FormGroup({ fullName: new FormGroup({ firstName: new FormControl(), lastName: new FormControl() }), phone: new FormControl() }) \u003cform [formGroup]=\"contactForm\" (submit)=\"onSubmit()\"\u003e \u003cdiv formGroupName=\"fullName\"\u003e \u003cinput type=\"text\" formControlName=\"firstName\" /\u003e \u003cinput type=\"text\" formControlName=\"lastName\" /\u003e \u003c/div\u003e \u003cinput type=\"text\" formControlName=\"phone\" /\u003e \u003cbutton\u003e提交\u003c/button\u003e \u003c/form\u003e onSubmit() { // 下面两种方式都可以获取到表单项的值 console.log(this.contactForm.value.name.username) console.log(this.contactForm.get([\"name\", \"username\"])?.value) } formControl 指令用于将一个单独的 FormControl 实例绑定到模板中的表单控件。通常在没有 FormGroup 的情况下使用，适合单独处理一个控件，而不需要嵌套在表单组中。\n\u003cinput [formControl]=\"nameControl\" /\u003e import { Component } from '@angular/core'; import { FormControl } from '@angular/forms'; @Component({ selector: 'app-my-form', templateUrl: './my-form.component.html', }) export class MyFormComponent { nameControl = new FormControl(''); // 创建 FormControl 实例 } formControlName 指令用于将一个 FormControl 实例绑定到 FormGroup 中的表单控件。这个指令只能用于响应式表单（ReactiveForms），并且必须与 FormGroup 一起使用。\n\u003cform [formGroup]=\"form\"\u003e \u003cinput formControlName=\"name\" /\u003e \u003c/form\u003e import { Component } from '@angular/core'; import { FormControl, FormGroup } from '@angular/forms'; @Component({ selector: 'app-my-form', templateUrl: './my-form.component.html', }) export class MyFormComponent { form = new FormGroup({ name: new FormControl(''), // 将 'name' 字段添加到 FormGroup 中 }); } FormArray FormArray 是一种特殊类型的 FormGroup，用于管理一组表单控件，通常用于处理动态数量的控件，它允许你动态地添加、移除或更新表单控件。例如，当你需要让用户添加多个相似项（如动态添加多个电子邮件地址、电话号码、或者一组购物车项目）时，FormArray 是理想的选择。\n例如实现一个表单，允许用户输入多个电子邮件地址：\nimport { Component, OnInit } from '@angular/core'; import { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms'; @Component({ selector: 'app-dynamic-form', templateUrl: './dynamic-form.component.html' }) export class DynamicFormComponent implements OnInit { emailForm: FormGroup; constructor(private fb: FormBuilder) {} ngOnInit(): void { this.emailForm = this.fb.group({ emails: this.fb.array([this.createEmailControl()]) }); } // 创建单个电子邮件控件 createEmailControl(): FormGroup { return this.fb.group({ email: ['', [Validators.required, Validators.email]] }); } // 获取 FormArray get emailControls(): FormArray { return this.emailForm.get('emails') as FormArray; } // 添加新的电子邮件控件 addEmail() { this.emailControls.push(this.createEmailControl()); } // 删除指定索引的电子邮件控件 removeEmail(index: number) { this.emailControls.removeAt(index); } // 提交表单数据 onSubmit() { if (this.emailForm.valid) { console.log(this.emailForm.value); } else { console.log('Form is invalid'); } } } emailForm 是一个包含 emails 的表单组，emails 是一个 FormArray。 createEmailControl() 是一个方法，用来创建一个带有电子邮件验证的 FormGroup。 emailControls 是一个 getter，用来获取 FormArray。 addEmail() 方法用于动态添加新的电子邮件控件到 FormArray。 removeEmail(index) 方法用于删除指定索引的控件。\n\u003cform [formGroup]=\"emailForm\" (ngSubmit)=\"onSubmit()\"\u003e \u003cdiv formArrayName=\"emails\"\u003e \u003cdiv *ngFor=\"let email of emailControls.controls; let i = index\" [formGroupName]=\"i\"\u003e \u003clabel for=\"email{{ i }}\"\u003eEmail {{ i + 1 }}:\u003c/label\u003e \u003cinput id=\"email{{ i }}\" formControlName=\"email\" /\u003e \u003cbutton type=\"button\" (click)=\"removeEmail(i)\"\u003eRemove\u003c/button\u003e \u003cdiv *ngIf=\"email.get('email').invalid \u0026\u0026 email.get('email').touched\"\u003e \u003csmall *ngIf=\"email.get('email').hasError('required')\"\u003eEmail is required.\u003c/small\u003e \u003csmall *ngIf=\"email.get('email').hasError('email')\"\u003eInvalid email format.\u003c/small\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cbutton type=\"button\" (click)=\"addEmail()\"\u003eAdd Email\u003c/button\u003e \u003cbutton type=\"submit\" [disabled]=\"emailForm.invalid\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e formArrayName=\"emails\"：将 FormArray 与模板中的对应部分绑定。 *ngFor：遍历 FormArray 中的每个表单控件。 formControlName=\"email\"：为每个表单控件（电子邮件输入框）绑定一个 FormControl。 addEmail()：点击 “Add Email” 按钮时，调用 addEmail() 方法来向表单中添加一个新的电子邮件输入框。 removeEmail(i)：点击 “Remove” 按钮时，调用 removeEmail() 方法来从表单中删除指定的电子邮件输入框。 内置表单验证器 使用内置验证器提供的验证规则验证表单字段\nimport { FormControl, FormGroup, Validators } from \"@angular/forms\" contactForm: FormGroup = new FormGroup({ name: new FormControl(\"默认值\", [ Validators.required, Validators.minLength(2) ]) }) 获取整体表单是否验证通过\nonSubmit() { console.log(this.contactForm.valid) } \u003c!-- 表单整体未验证通过时禁用表单按钮 --\u003e \u003cbutton [disabled]=\"contactForm.invalid\"\u003e提交\u003c/button\u003e 在组件模板中显示为验证通过时的错误信息\nget name() { return this.contactForm.get(\"name\")! } \u003cform [formGroup]=\"contactForm\" (submit)=\"onSubmit()\"\u003e \u003cinput type=\"text\" formControlName=\"name\" /\u003e \u003cdiv *ngIf=\"name.touched \u0026\u0026 name.invalid \u0026\u0026 name.errors\"\u003e \u003cdiv *ngIf=\"name.errors.required\"\u003e请填写姓名\u003c/div\u003e \u003cdiv *ngIf=\"name.errors.maxlength\"\u003e 姓名长度不能大于 {{ name.errors.maxlength.requiredLength }} 实际填写长度为 {{ name.errors.maxlength.actualLength }} \u003c/div\u003e \u003c/div\u003e \u003c/form\u003e 自定义同步表单验证器 自定义验证器的类型是 TypeScript 类 类中包含具体的验证方法，验证方法必须为静态方法 验证方法有一个参数 control，类型为 AbstractControl。其实就是 FormControl 类的实例对象的类型 如果验证成功，返回 null 如果验证失败，返回对象，对象中的属性即为验证标识，值为 true，标识该项验证失败 验证方法的返回值为 ValidationErrors | null import { AbstractControl, ValidationErrors } from \"@angular/forms\" export class NameValidators { // 字段值中不能包含空格 static cannotContainSpace(control: AbstractControl): ValidationErrors | null { // 验证未通过 if (/\\s/.test(control.value)) return { cannotContainSpace: true } // 验证通过 return null } } import { NameValidators } from \"./Name.validators\" contactForm: FormGroup = new FormGroup({ name: new FormControl(\"\", [ Validators.required, NameValidators.cannotContainSpace ]) }) \u003cdiv *ngIf=\"name.touched \u0026\u0026 name.invalid \u0026\u0026 name.errors\"\u003e \u003cdiv *ngIf=\"name.errors.cannotContainSpace\"\u003e姓名中不能包含空格\u003c/div\u003e \u003c/div\u003e 自定义异步表单验证器 异步验证器函数：\nimport { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable, of } from 'rxjs'; import { debounceTime, map, catchError, switchMap, take } from 'rxjs/operators'; import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms'; @Injectable({ providedIn: 'root' }) export class EmailValidatorService { constructor(private http: HttpClient) {} // 异步验证器：检查邮箱是否已注册 emailExistsValidator(): AsyncValidatorFn { return (control: AbstractControl): Observable\u003cValidationErrors | null\u003e =\u003e { if (!control.value) { return of(null); // 如果控件值为空，不做验证 } // 返回 Observable，模拟 HTTP 请求 return this.http.get\u003cany\u003e(`/api/check-email?email=${control.value}`).pipe( debounceTime(500), // 防止发送过多请求 map(response =\u003e { // 假设 response 存在 `exists` 字段，表示邮箱是否已经存在 return response.exists ? { emailExists: true } : null; }), catchError(() =\u003e of(null)) // 如果发生错误（如网络请求失败），返回 null ); }; } } AsyncValidatorFn：这是异步验证器的类型，它返回一个 Observable 或 Promise，并且必须解析为 ValidationErrors（验证失败时）或 null（验证通过）。 debounceTime：这是防止发送过多请求的技巧，尤其是在用户输入过程中。通常，在输入停止一段时间后再发起验证请求。 catchError：如果网络请求失败或出现错误，返回 null 表示验证成功。 在组件中使用异步验证器：\nimport { Component, OnInit } from '@angular/core'; import { FormBuilder, FormGroup, Validators } from '@angular/forms'; import { EmailValidatorService } from './email-validator.service'; @Component({ selector: 'app-user-form', templateUrl: './user-form.component.html' }) export class UserFormComponent implements OnInit { userForm: FormGroup; constructor( private fb: FormBuilder, private emailValidator: EmailValidatorService ) {} ngOnInit(): void { this.userForm = this.fb.group({ email: [ '', [Validators.required, Validators.email], [this.emailValidator.emailExistsValidator()] ] }); } onSubmit(): void { if (this.userForm.valid) { console.log(this.userForm.value); } else { console.log('Form is invalid'); } } } emailExistsValidator()：这是在 EmailValidatorService 中定义的异步验证器，用于验证用户输入的电子邮件地址是否已存在。 [this.emailValidator.emailExistsValidator()]：将异步验证器作为第三个参数传递给 FormControl，它会在表单控件的值变化时触发。 FormControl 的验证顺序：Validators.required 和 Validators.email 是同步验证器，而 emailExistsValidator() 是异步验证器。 模板代码：\n\u003cform [formGroup]=\"userForm\" (ngSubmit)=\"onSubmit()\"\u003e \u003cdiv\u003e \u003clabel for=\"email\"\u003eEmail:\u003c/label\u003e \u003cinput id=\"email\" formControlName=\"email\" /\u003e \u003c!-- 错误消息 --\u003e \u003cdiv *ngIf=\"userForm.get('email').hasError('required') \u0026\u0026 userForm.get('email').touched\"\u003e Email is required. \u003c/div\u003e \u003cdiv *ngIf=\"userForm.get('email').hasError('email') \u0026\u0026 userForm.get('email').touched\"\u003e Invalid email format. \u003c/div\u003e \u003cdiv *ngIf=\"userForm.get('email').hasError('emailExists') \u0026\u0026 userForm.get('email').touched\"\u003e This email address is already registered. \u003c/div\u003e \u003c/div\u003e \u003cbutton type=\"submit\" [disabled]=\"userForm.invalid\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e FormBuilder FormBuilder 是一个辅助工具，用于简化和减少 FormControl 和 FormGroup 的冗长创建过程，特别是在需要创建大量表单控件时。通过 FormBuilder，可以更简洁、更易读地构建表单。\nthis.fb.control：表单项 this.fb.group：表单组，表单至少是一个 FormGroup this.fb.array：用于复杂表单，可以动态添加表单项或表单组，在表单验证时，FormArray 中有一项没通过，那么整体就不会通过。 this.form = this.fb.group({ name: ['', Validators.required], email: ['', [Validators.required, Validators.email]], }); 其他 setValue 用于将整个表单控件的值设置为一个新的值。如果你使用 setValue，必须提供一个完整的对象，该对象必须包含所有控件的值，且顺序和控件名必须与原始表单控件匹配。\nformGroup.setValue(value: { [key: string]: any }, options?: { onlySelf?: boolean, emitEvent?: boolean }) value：一个包含所有控件的值的对象，必须包含表单中所有控件的值。 onlySelf（可选）：如果为 true，则只会更新当前控件的值，不会影响父表单。 emitEvent（可选）：如果为 false，则不会触发控件的 valueChanges 事件。 patchValue patchValue 方法与 setValue 类似，也用于更新表单控件的值。但是，patchValue 允许部分更新表单控件的值。你只需要提供你希望更新的控件的值，而不必提供整个表单控件的值。这对于动态表单或者只需更新部分控件的场景非常有用。\nformGroup.patchValue(value: { [key: string]: any }, options?: { onlySelf?: boolean, emitEvent?: boolean }) value：一个包含部分控件值的对象，更新该对象中的字段，不需要提供所有控件的值。 onlySelf（可选）：如果为 true，则只会更新当前控件的值，不会影响父表单。 emitEvent（可选）：如果为 false，则不会触发控件的 valueChanges 事件。 reset 方法用于将表单恢复到初始状态。可以通过它将控件值重置为初始值，并恢复表单的有效性。\nvalid、invalid 这两个属性用来检查表单是否有效。valid 返回 true 如果表单是有效的，invalid 返回 true 如果表单是无效的。\ndirty、pristine dirty：如果控件的值已经被修改，则返回 true，否则返回 false。 pristine：与 dirty 相反，如果控件的值从未被修改过，则返回 true。 touched、untouched touched：如果控件已经被触摸（即用户离开了该控件），则返回 true。 untouched：如果控件未被触摸，则返回 true。 markAsTouched()、markAsUntouched() markAsTouched()：将所有控件标记为已触摸。 markAsUntouched()：将所有控件标记为未触摸。 markAsDirty()、markAsPristine() markAsDirty()：将所有控件标记为已修改。 markAsPristine()：将所有控件标记为未修改。 enable()、disable() enable()：启用表单控件。 disable()：禁用表单控件。 hasError() hasError() 用于检查控件是否存在特定的验证错误。\nif (this.formGroup.get('email').hasError('required')) { console.log('Email is required'); } setErrors() setErrors() 将控件设置错误，并且可以指定一个错误对象。\nformGroup.setErrors(errors: ValidationErrors | null, options?: { emitEvent?: boolean }): void errors：一个包含错误信息的对象，或者为 null，表示清除所有错误。ValidationErrors 是一个键值对对象，键是错误的名称，值是错误的描述信息。 options.emitEvent（可选）：一个布尔值，表示是否触发 statusChanges 和 valueChanges 事件。默认为 true，即触发事件。 this.formGroup.setErrors({ invalidForm: 'The form is invalid' }); valueChanges、statusChanges valueChanges：当表单控件的值发生变化时（例如 setValue()），会触发该 Observable。 statusChanges：当表单控件的状态发生变化时（例如从 valid 到 invalid，或者调用 setErrors()），会触发该 Observable。 this.formGroup.valueChanges.subscribe(value =\u003e { console.log('Form value changed:', value); }); this.formGroup.statusChanges.subscribe(status =\u003e { console.log('Form status changed:', status); }); updateValueAndValidity 用于更新表单控件的值和有效性。它会触发控件的验证过程，重新评估控件的值是否有效，并更新控件的验证状态（如 valid、invalid、pending、touched 等）。\n这个方法在你手动修改控件的值或验证器时特别有用，确保控件的状态得到重新评估。\nformControl.updateValueAndValidity(options?: { onlySelf?: boolean, emitEvent?: boolean }): void onlySelf（可选）：如果为 true，仅会更新当前控件，而不会影响父表单。默认为 false，即更新当前控件及其父控件。 emitEvent（可选）：如果为 false，则不会触发 valueChanges 或 statusChanges 事件。默认为 true，即会触发这些事件。 ","模板驱动表单#模板驱动表单":"概述 表单的控制逻辑写在组件模板中，适合简单的表单类型。\n快速上手 引入依赖模块 FormsModule\nimport { FormsModule } from \"@angular/forms\" @NgModule({ imports: [FormsModule], }) export class AppModule {} 将 DOM 表单转换为 ngForm\n\u003cform #f=\"ngForm\" (submit)=\"onSubmit(f)\"\u003e\u003c/form\u003e 声明表单字段为 ngModel\n\u003cform #f=\"ngForm\" (submit)=\"onSubmit(f)\"\u003e \u003cinput type=\"text\" name=\"username\" ngModel /\u003e \u003cbutton\u003e提交\u003c/button\u003e \u003c/form\u003e 获取表单字段值\nimport { NgForm } from \"@angular/forms\" export class AppComponent { onSubmit(form: NgForm) { console.log(form.value) } } 表单分组\n当你的表单的表单项比较多，可以把相关的表单项分组。\n\u003cform #f=\"ngForm\" (submit)=\"onSubmit(f)\"\u003e \u003cdiv ngModelGroup=\"user\"\u003e \u003cinput type=\"text\" name=\"username\" ngModel /\u003e \u003c/div\u003e \u003cdiv ngModelGroup=\"contact\"\u003e \u003cinput type=\"text\" name=\"phone\" ngModel /\u003e \u003c/div\u003e \u003cbutton\u003e提交\u003c/button\u003e \u003c/form\u003e 分组后，访问表单数据，例如 username，就是 form.user.username。\n表单验证 required 必填字段 minlength 字段最小长度 maxlength 字段最大长度 pattern 验证正则 例如：pattern=\"\\d\" 匹配一个数值 \u003cform #f=\"ngForm\" (submit)=\"onSubmit(f)\"\u003e \u003cinput type=\"text\" name=\"username\" ngModel required pattern=\"\\d\" /\u003e \u003cbutton\u003e提交\u003c/button\u003e \u003c/form\u003e export class AppComponent { onSubmit(form: NgForm) { // 查看表单整体是否验证通过 console.log(form.valid) } } \u003c!-- 表单整体未通过验证时禁用提交表单 --\u003e \u003cbutton type=\"submit\" [disabled]=\"f.invalid\"\u003e提交\u003c/button\u003e 在组件模板中显示表单项未通过时的错误信息。\n\u003cform #f=\"ngForm\" (submit)=\"onSubmit(f)\"\u003e \u003cinput #username=\"ngModel\" /\u003e \u003c!-- touched 为 true 表示用户操作过该表单项 --\u003e \u003cdiv *ngIf=\"username.touched \u0026\u0026 !username.valid \u0026\u0026 username.errors\"\u003e \u003cdiv *ngIf=\"username.errors.required\"\u003e请填写用户名\u003c/div\u003e \u003cdiv *ngIf=\"username.errors.pattern\"\u003e不符合正则规则\u003c/div\u003e \u003c/div\u003e \u003c/form\u003e dirty 和 touched 都可以用来判断表单控件是否被用户操作过：\ndirty：如果用户修改了表单控件的值，则该控件的 dirty 状态会被设置为 true。如果控件的值没有被修改，dirty 状态为 false。 touched：如果控件失去焦点（即用户点击过该控件并离开），则控件的 touched 状态会被设置为 true。 指定表单项未通过验证时的样式。\ninput.ng-touched.ng-invalid { border: 2px solid red; } "},"title":"表单"},"/frontend-learn/docs/framework/angular/10_custom_form/":{"data":{"":"","ng_value_accessor-和-ng_validators#NG_VALUE_ACCESSOR 和 NG_VALIDATORS":" NG_VALUE_ACCESSOR：NG_VALUE_ACCESSOR 令牌指向一个实现了 ControlValueAccessor 接口的组件，允许 Angular 在处理表单时使用该组件。 表单绑定：NG_VALUE_ACCESSOR 让自定义控件能够与 Angular 表单控件（FormControl, ngModel 等）进行数据绑定。 双向数据绑定：它允许自定义控件接收表单模型的数据，并将用户的输入传递回表单模型。 自定义控件集成：通过实现 ControlValueAccessor 接口并提供 NG_VALUE_ACCESSOR，可以将自定义控件集成到 Angular 的表单框架中，享受 Angular 表单系统提供的功能（如验证、状态管理等）。 NG_VALIDATORS 主要用于在表单控件上添加自定义的验证逻辑。可以将自定义验证器与 Angular 表单控件（如 FormControl, ngModel）一起使用。 ","实现-controlvalueaccessor-接口#实现 ControlValueAccessor 接口":"ControlValueAccessor 接口允许自定义控件与 Angular 的表单控件（FormControl, ngModel）进行交互。需要实现以下方法：\nwriteValue(value: any): void：这个方法会将父组件的表单值写入自定义控件。 registerOnChange(fn: any): void：当自定义控件的值发生变化时，调用该方法通知父组件。 registerOnTouched(fn: any): void：当控件被触摸时（比如失去焦点），会调用这个方法通知父组件。通常来说，将 onBlur() 事件会绑定到控件的 blur 事件上，并在 onBlur() 方法中调用它。。 setDisabledState(isDisabled: boolean): void：用于设置控件的禁用状态。可以根据 isDisabled 值来禁用或启用自定义控件。 writeValue 和 setDisabledState 通常在父组件中调用 CustomFormControl.setValue() 和 CustomFormControl.disable() 方法时会执行。父组件初始化控件时也会执行，例如：\nthis.myCustomCtrl = new FormControl({value: '', disabled: true}); 实现 ControlValueAccessor 接口示例：\nimport { Component, forwardRef } from '@angular/core'; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms'; @Component({ selector: 'app-custom-input', template: `\u003cinput [value]=\"value\" (input)=\"onInput($event)\" /\u003e`, providers: [ { provide: NG_VALUE_ACCESSOR, // 注册到 Angular 表单系统 useExisting: forwardRef(() =\u003e CustomInputComponent), // 指向当前组件 multi: true // 表示可以有多个实现 } ] }) export class CustomInputComponent implements ControlValueAccessor { value: string = ''; onChange: any = () =\u003e {}; onTouched: any = () =\u003e {}; // 实现 ControlValueAccessor 接口 registerOnChange(fn: any): void { this.onChange = fn; // 也可以直接监听 valueChanges，并通知父组件 // this.control.valueChanges.subscribe(fn); // 当 FormControl 的值变化时，调用回调 } registerOnTouched(fn: any): void { this.onTouched = fn; } writeValue(value: any): void { if (value !== undefined) { this.value = value; } } setDisabledState(isDisabled: boolean): void { // 可以在这里设置控件的禁用状态 } onInput(event: Event): void { const input = event.target as HTMLInputElement; this.value = input.value; this.onChange(this.value); // 通知 Angular 表单模型控件值已经变化 } } ","实现-validator-接口#实现 Validator 接口":"Validator 接口用于添加自定义的验证逻辑。它定义了一个 validate() 方法，这个方法返回一个 ValidationErrors 对象，或者是 null（表示没有验证错误）。\nValidationErrors 是一个键值对对象，其中每个键表示一个错误类型，值表示错误的详细信息。\nimport { AbstractControl, ValidationErrors, Validator } from '@angular/forms'; @Component({ selector: 'app-custom-input', template: `\u003cinput [value]=\"value\" (input)=\"onInput($event)\" /\u003e`, providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =\u003e CustomInputComponent), multi: true }, { provide: NG_VALIDATORS, useExisting: forwardRef(() =\u003e CustomInputComponent), multi: true // 表示可以有多个验证器 } ] }) export class CustomInputComponent implements ControlValueAccessor, Validator { // ControlValueAccessor 接口实现 ... // 实现 Validator 接口 validate(control: AbstractControl): ValidationErrors | null { // 例如，验证输入值是否为数字 const value = control.value; if (value \u0026\u0026 isNaN(value)) { return { 'invalidNumber': 'The value must be a number.' }; } return null; // 返回 null 表示验证通过 } } 使用自定义表单控件：\n\u003cform [formGroup]=\"myForm\"\u003e \u003capp-custom-input formControlName=\"customInput\"\u003e\u003c/app-custom-input\u003e \u003cdiv *ngIf=\"myForm.get('customInput').hasError('invalidNumber')\"\u003e Value must be a number! \u003c/div\u003e \u003c/form\u003e ","自定义表单控件#自定义表单控件":"创建自定义表单控件时，通常需要三步：\n实现 ControlValueAccessor 接口：使自定义控件能够与 Angular 表单框架配合使用。 实现 Validator 接口：提供自定义的验证逻辑。 注册自定义控件为 Angular 表单控件。 "},"title":"自定义表单控件"},"/frontend-learn/docs/framework/angular/11_router/":{"data":{"":"","命名插座#命名插座":"命名路由插座使得在同一页面中渲染多个视图变得更加灵活，常用于复杂的布局或多个区域显示不同内容的场景。。\n命名插座使用 outlet 属性来指定。\nconst routes: Routes = [ { path: 'dashboard', component: DashboardComponent }, { path: 'user-profile', component: UserProfileComponent, outlet: 'sidebar' } ]; 模板布局：\n\u003cdiv class=\"main-content\"\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003c!-- 默认插座显示 dashboard 或其他组件 --\u003e \u003c/div\u003e \u003cdiv class=\"sidebar\"\u003e \u003crouter-outlet name=\"sidebar\"\u003e\u003c/router-outlet\u003e \u003c!-- 命名插座显示 user-profile --\u003e \u003c/div\u003e 可以在路由链接中指定插座名称：\n\u003ca [routerLink]=\"[{ outlets: { primary: ['dashboard'], sidebar: ['user-profile'] } }]\"\u003e Go to Dashboard and User Profile \u003c/a\u003e ","导航路由#导航路由":"在 JS 中通过 Router.navigate 方法跳转路由：\n\u003c!-- app.component.html --\u003e \u003cbutton (click)=\"jump()\"\u003e跳转到发展历史\u003c/button\u003e // app.component.ts import { Router } from \"@angular/router\" export class HomeComponent { constructor(private router: Router) {} jump() { this.router.navigate([\"/about/history\"], { queryParams: { name: \"Kitty\" } }) } } ","快速上手#快速上手":" 创建页面组件、Layout 组件以及 Navigation 组件，供路由使用\n创建首页页面组件ng g c pages/home 创建关于我们页面组件ng g c pages/about 创建布局组件ng g c pages/layout 创建导航组件ng g c pages/navigation 创建路由规则\n// app.module.ts import { Routes } from \"@angular/router\" const routes: Routes = [ { path: \"home\", component: HomeComponent }, { path: \"about\", component: AboutComponent } ] 引入路由模块并启动\n// app.module.ts import { RouterModule, Routes } from \"@angular/router\" @NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], }) export class AppModule {} 添加路由插座\n路由插座 \u003crouter-outlet\u003e 即占位组件 匹配到的路由组件将会显示在这个地方\n\u003c!-- --\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e 在导航组件中定义链接\n\u003ca routerLink=\"/home\"\u003e首页\u003c/a\u003e \u003ca routerLink=\"/about\"\u003e关于我们\u003c/a\u003e ","路由事件#路由事件":"路由事件 (RouterEvent) 是指与路由相关的各种操作发生时触发的事件。通过监听这些事件，可以执行一些特定的操作，如路由开始时的动画效果、在路由切换时获取日志信息、监控路由生命周期等。\n常用的路由事件：\nNavigationStart: 当路由开始导航时触发。 NavigationEnd: 当路由导航完成时触发。 NavigationCancel: 如果导航被取消时触发。 NavigationError: 如果导航出错时触发。 RoutesRecognized: 当路由的目标路径已经解析完毕时触发。 ChildActivationStart: 当子路由激活开始时触发。 ChildActivationEnd: 当子路由激活结束时触发。 ActivationStart: 当路由激活开始时触发。 ActivationEnd: 当路由激活结束时触发。 DeactivationStart: 当路由停用开始时触发。 DeactivationEnd: 当路由停用结束时触发。 显示加载指示器 如果要实现在导航开始时显示一个加载器，并在导航完成时隐藏它。可以通过订阅 NavigationStart 和 NavigationEnd 事件来实现。\nimport { Component, OnInit } from '@angular/core'; import { Router, NavigationStart, NavigationEnd } from '@angular/router'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent implements OnInit { loading: boolean = false; constructor(private router: Router) {} ngOnInit(): void { this.router.events.subscribe((event) =\u003e { if (event instanceof NavigationStart) { this.loading = true; // 显示加载指示器 } if (event instanceof NavigationEnd) { this.loading = false; // 隐藏加载指示器 } }); } } ","路由传参#路由传参":"查询参数 通过 queryParams 添加查询参数：\n\u003ca routerLink=\"/about\" [queryParams]=\"{ name: 'kitty' }\"\u003e关于我们\u003c/a\u003e 访问 url 路径是：/about?name=kitty。\nimport { ActivatedRoute } from \"@angular/router\" export class AboutComponent implements OnInit { constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.queryParamMap.subscribe(query =\u003e { query.get(\"name\") }) } } 动态参数 const routes: Routes = [ { path: \"home\", component: HomeComponent }, { path: \"about/:name\", component: AboutComponent } ] about/:name 中的 :name 就是一个动态参数。\n\u003ca [routerLink]=\"['/about', 'zhangsan']\"\u003e关于我们\u003c/a\u003e 访问 url 路径是：/about/zhangsan。\nimport { ActivatedRoute } from \"@angular/router\" export class AboutComponent implements OnInit { constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.route.paramMap.subscribe(params =\u003e { params.get(\"name\") }) } } 配置路由数据 Angular 可以在路由配置中使用 data 属性来定义数据。data 属性接受一个对象，可以在组件中通过 ActivatedRoute 获取这些数据。\nimport { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { HomeComponent } from './home/home.component'; import { AboutComponent } from './about/about.component'; const routes: Routes = [ { path: '', component: HomeComponent, data: { title: 'Home Page' } // 配置数据 }, { path: 'about', component: AboutComponent, data: { title: 'About Us' } // 配置数据 } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule { } 通过 ActivatedRoute 来访问路由数据：\nimport { Component, OnInit } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; @Component({ selector: 'app-home', template: `\u003ch1\u003e{{ title }}\u003c/h1\u003e` }) export class HomeComponent implements OnInit { title: string = ''; constructor(private route: ActivatedRoute) {} ngOnInit(): void { // 获取路由配置中的数据 this.title = this.route.snapshot.data['title']; // 也可以订阅数据变化 this.route.data.subscribe(data =\u003e { this.title = data['title']; }); } } state 路由状态对象 state 适用于不希望数据出现在 URL 中的情况。\n传递数据：\nimport { Router } from '@angular/router'; constructor(private router: Router) {} navigateWithState() { this.router.navigateByUrl('/details', { state: { productId: 123, name: 'Laptop' } }); } 接收数据：\nimport { Component } from '@angular/core'; import { Router } from '@angular/router'; @Component({ selector: 'app-details', template: `\u003ch1\u003eProduct: {{ product?.name }}\u003c/h1\u003e` }) export class DetailsComponent { product: any; constructor(private router: Router) { this.product = this.router.getCurrentNavigation()?.extras.state; } } ⚠️ state 数据仅在当前会话的导航过程中有效。如果用户刷新页面 (F5)、直接访问该 URL，或者在新的浏览器标签页打开该链接，state 数据就会丢失。 snapshot ActivatedRoute.snapshot 是一个用于获取当前路由状态的快照对象。它包含了与当前路由相关的所有信息，包括路由参数、查询参数、数据等。snapshot 主要用于同步获取路由信息。\n当你需要在路由切换时读取静态的路由信息时，而不需要响应路由变化。 不需要监听路由变化，而是只需要在组件初始化时获取一次路由参数和其他信息时使用。 import { Component, OnInit } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; @Component({ selector: 'app-product-detail', templateUrl: './product-detail.component.html', styleUrls: ['./product-detail.component.css'] }) export class ProductDetailComponent implements OnInit { productId: string; category: string; constructor(private route: ActivatedRoute) {} ngOnInit() { // 获取路由参数 this.productId = this.route.snapshot.paramMap.get('id'); // 获取查询参数 this.category = this.route.snapshot.queryParamMap.get('category'); // 获取完整的 URL console.log(this.route.snapshot.url); // 返回 URL 数组 console.log(this.route.snapshot.url.join('/')); // 返回 URL 字符串 } } 它适用于你只需要在组件加载时读取一次路由信息，并且不需要响应路由参数变化的场景。如果需要响应路由的变化（例如，路由参数的改变），则应该使用 route.params 或 route.queryParams 并订阅它们。\nroute.parent 多层嵌套的路由配置，其中 parent 路由包含一个 id 参数，child 路由是 parent 路由的子路由，grandchild 是 child 路由的孙子级路由。\nconst routes: Routes = [ { path: 'parent', component: ParentComponent, children: [ { path: ':id', // 父路由的参数 component: ChildComponent, children: [ { path: ':subId', // 孙子路由的参数 component: GrandchildComponent } ] } ] } ]; 使用 route.parent 可以获取到父路由的参数。\nimport { ActivatedRoute } from '@angular/router'; export class GrandchildComponent { constructor(private route: ActivatedRoute) { // 获取父路由的参数 const parentId = this.route.parent?.snapshot.paramMap.get('id'); console.log('Parent id:', parentId); // 获取孙子路由的参数 const subId = this.route.snapshot.paramMap.get('subId'); console.log('Sub id:', subId); } } 设置页面标题 应用中的每个页面都应该有一个唯一的标题，以便在浏览器历史记录中识别它们。可以配置 Route 的 title 属性来设置页面标题：\nconst routes: Routes = [ { path: 'first-component', title: 'First component', component: FirstComponent, // this is the component with the \u003crouter-outlet\u003e in the template children: [ { path: 'child-a', // child route path title: resolvedChildATitle, component: ChildAComponent, // child route component that the router renders }, { path: 'child-b', title: 'child b', component: ChildBComponent, // another child route component that the router renders }, ], }, ]; const resolvedChildATitle: ResolveFn\u003cstring\u003e = () =\u003e Promise.resolve('child a'); ","路由守卫#路由守卫":"路由守卫（Route Guards）用于在用户导航到路由之前、或者离开路由时，控制访问权限或执行某些逻辑。\n路由守卫可以帮助你做很多事情，例如：权限控制、登录验证、数据预加载等。\n常用的路由守卫类型：\nCanActivate: 在导航到某个路由时进行检查，控制是否允许该路由激活。 CanDeactivate: 在导航离开当前路由时进行检查，控制是否允许离开该路由（例如，防止丢失未保存的表单数据）。 CanLoad: 在懒加载模块时进行检查，控制是否允许加载该模块。 Resolve: 在路由激活前加载数据，确保数据在路由激活之前就被加载。 路由可以应用多个守卫，所有守卫方法都允许，路由才被允许访问，有一个守卫方法不允许，则路由不允许被访问。\nCanActivate CanActivate 守卫用于控制进入路由时的权限，比如检查用户是否已经登录，或者是否有权限访问某个页面。CanActivate 会在路由激活之前执行。即便是懒加载模块，CanActivate 也会在模块加载之前执行。\n创建路由守卫：ng generate guard auth\n// auth.guard.ts import { Injectable } from '@angular/core'; import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router'; import { Observable } from 'rxjs'; import { AuthService } from './auth.service'; // 假设你有一个 AuthService 用于检查登录状态 @Injectable({ providedIn: 'root' }) export class AuthGuard implements CanActivate { constructor(private authService: AuthService, private router: Router) {} canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot ): Observable\u003cboolean\u003e | Promise\u003cboolean\u003e | boolean { if (this.authService.isAuthenticated()) { return true; } else { // 如果未认证，重定向到登录页面 this.router.navigate(['/login']); return false; } } } 然后，在路由配置中使用该守卫：\n// app-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { AuthGuard } from './auth.guard'; // 引入守卫 const routes: Routes = [ { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] // 使用守卫 }, { path: 'login', component: LoginComponent }, { path: '', redirectTo: '/dashboard', pathMatch: 'full' } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} 当用户尝试访问 /dashboard 路由时，AuthGuard 会先执行，如果用户已经认证（authService.isAuthenticated() 返回 true），则允许导航；否则，导航会被重定向到 /login 页面。\nCanActivateChild CanActivateChild 路由守卫用于控制 子路由 的访问权限。它与 CanActivate 类似，但 CanActivateChild 主要针对的是父路由的所有子路由的访问控制。通过使用 CanActivateChild，可以统一管理子路由的权限控制，而不需要在每个子路由上单独配置守卫。\n// auth.guard.ts import { Injectable } from '@angular/core'; import { CanActivateChild, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router'; import { Observable } from 'rxjs'; import { AuthService } from './auth.service'; // 假设你有一个 AuthService 用于检查用户登录状态 @Injectable({ providedIn: 'root' }) export class AuthGuard implements CanActivateChild { constructor(private authService: AuthService, private router: Router) {} canActivateChild( next: ActivatedRouteSnapshot, state: RouterStateSnapshot ): Observable\u003cboolean\u003e | Promise\u003cboolean\u003e | boolean { // 判断用户是否已认证 if (this.authService.isAuthenticated()) { return true; // 允许访问子路由 } else { // 如果未认证，重定向到登录页面 this.router.navigate(['/login']); return false; // 拒绝访问 } } } 在路由配置中使用 CanActivateChild 守卫。CanActivateChild 需要被配置在父路由上，而不是每个子路由。\n// app-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { AuthGuard } from './auth.guard'; // 引入守卫 import { DashboardComponent } from './dashboard/dashboard.component'; import { SettingsComponent } from './settings/settings.component'; import { ProfileComponent } from './profile/profile.component'; const routes: Routes = [ { path: 'dashboard', component: DashboardComponent, canActivateChild: [AuthGuard], // 使用 CanActivateChild 守卫 children: [ { path: 'settings', component: SettingsComponent }, { path: 'profile', component: ProfileComponent } ] }, { path: 'login', component: LoginComponent }, { path: '', redirectTo: '/dashboard', pathMatch: 'full' } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} CanDeactivate CanDeactivate 守卫用于在离开当前路由时进行检查，通常用于防止用户丢失未保存的表单数据或者在离开当前页面时提示用户。\n// can-deactivate.guard.ts import { Injectable } from '@angular/core'; import { CanDeactivate } from '@angular/router'; import { Observable } from 'rxjs'; // 守卫可以适用于多个组件，通常会创建一个接口来约束组件 export interface CanComponentDeactivate { canDeactivate: () =\u003e Observable\u003cboolean\u003e | Promise\u003cboolean\u003e | boolean; } @Injectable({ providedIn: 'root' }) export class CanDeactivateGuard implements CanDeactivate\u003cCanComponentDeactivate\u003e { canDeactivate( component: CanComponentDeactivate ): Observable\u003cboolean\u003e | Promise\u003cboolean\u003e | boolean { return component.canDeactivate ? component.canDeactivate() : true; } } 在组件中实现 canDeactivate 方法：\n// form.component.ts import { Component } from '@angular/core'; import { CanComponentDeactivate } from './can-deactivate.guard'; @Component({ selector: 'app-form', templateUrl: './form.component.html' }) export class FormComponent implements CanComponentDeactivate { formIsDirty = false; // 假设这是表单是否已更改的状态 canDeactivate(): boolean { if (this.formIsDirty) { return window.confirm('You have unsaved changes. Do you really want to leave?'); } return true; } } 配置路由守卫：\n// app-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { CanDeactivateGuard } from './can-deactivate.guard'; // 引入守卫 import { FormComponent } from './form.component'; const routes: Routes = [ { path: 'form', component: FormComponent, canDeactivate: [CanDeactivateGuard] // 使用守卫 } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} CanLoad CanLoad 守卫用于在懒加载模块时进行检查，确保只有在满足某些条件下才允许加载该模块。它通常用于懒加载模块的权限控制。如果用户没有权限或未登录，CanLoad 可以阻止模块加载，避免加载不必要的资源。\n// can-load.guard.ts import { Injectable } from '@angular/core'; import { CanLoad, Route, UrlSegment, Router } from '@angular/router'; import { Observable } from 'rxjs'; import { AuthService } from './auth.service'; @Injectable({ providedIn: 'root' }) export class CanLoadGuard implements CanLoad { constructor(private authService: AuthService, private router: Router) {} canLoad( route: Route, segments: UrlSegment[] ): Observable\u003cboolean\u003e | Promise\u003cboolean\u003e | boolean { if (this.authService.isAuthenticated()) { return true; } else { this.router.navigate(['/login']); return false; } } } 然后在懒加载模块的路由配置中使用 CanLoad 守卫：\n// app-routing.module.ts import { Routes, RouterModule } from '@angular/router'; const routes: Routes = [ { path: 'admin', loadChildren: () =\u003e import('./admin/admin.module').then(m =\u003e m.AdminModule), canLoad: [CanLoadGuard] // 使用 CanLoad 守卫 } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} Resolve Resolve 守卫用于在路由激活之前预先加载数据，确保组件渲染之前数据已经准备好。\n通常会调用一个服务来获取数据，然后在服务中实现 Resolve 接口：\n// data-resolver.service.ts import { Injectable } from '@angular/core'; import { Resolve } from '@angular/router'; import { Observable } from 'rxjs'; import { DataService } from './data.service'; // 假设有一个服务提供数据 @Injectable({ providedIn: 'root' }) export class DataResolver implements Resolve\u003cany\u003e { constructor(private dataService: DataService) {} resolve(): Observable\u003cany\u003e { return this.dataService.getData(); // 返回需要加载的数据 } } 配置路由时使用 resolve：\n// app-routing.module.ts import { Routes, RouterModule } from '@angular/router'; import { DataResolver } from './data-resolver.service'; import { DashboardComponent } from './dashboard/dashboard.component'; const routes: Routes = [ { path: 'dashboard', component: DashboardComponent, resolve: { data: DataResolver // 使用 resolve 守卫 } } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} 在组件中，通过 ActivatedRoute 来访问预加载的数据：\n// dashboard.component.ts import { Component, OnInit } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; @Component({ selector: 'app-dashboard', templateUrl: './dashboard.component.html' }) export class DashboardComponent implements OnInit { data: any; constructor(private route: ActivatedRoute) {} ngOnInit(): void { this.data = this.route.snapshot.data['data']; // 获取 resolve 中的数据 } } ","路由嵌套#路由嵌套":"路由嵌套指的是如何定义子级路由。\nconst routes: Routes = [ { path: \"about\", component: AboutComponent, children: [ { path: \"introduce\", component: IntroduceComponent }, { path: \"history\", component: HistoryComponent } ] } ] 下面是父级组件模板：\n\u003c!-- about.component.html --\u003e \u003capp-layout\u003e \u003cp\u003eabout works!\u003c/p\u003e \u003ca routerLink=\"/about/introduce\"\u003e公司简介\u003c/a\u003e \u003ca routerLink=\"/about/history\"\u003e发展历史\u003c/a\u003e \u003cdiv\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003c/div\u003e \u003c/app-layout\u003e 父级模板中添加了 \u003crouter-outlet\u003e，用来显示子级路由的组件。","路由懒加载#路由懒加载":"Angular 最新的版本推荐使用 Standalone 组件，可以通过 loadComponent 来进行懒加载配置。和常规的模块懒加载不同，Standalone 组件的懒加载是基于组件的，而不是模块。\nimport { Routes, RouterModule } from '@angular/router'; const routes: Routes = [ { path: 'dashboard', loadComponent: () =\u003e import('./dashboard/dashboard.component').then(m =\u003e m.DashboardComponent) // 懒加载 Standalone 组件 }, { path: '', redirectTo: '/dashboard', pathMatch: 'full' } ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {} 在 Angular 中，Standalone 组件配置了懒加载，其子组件不会自动成为懒加载组件。懒加载是基于路由配置的，当你在路由配置中指定某个组件使用 loadComponent 来进行懒加载时，只有该组件本身被懒加载。其子组件仍然会像常规组件一样，在加载父组件时一并加载。\n路由懒加载的好处 减小初始包体积：只有在用户访问某个路由时，相关的 Standalone 组件才会被加载，这样可以减小应用的初始包体积，提升性能。 按需加载：用户只加载他们需要的部分，这对于大型应用来说是一个显著的性能优化。 简单配置：与传统的模块懒加载相比，Standalone 组件的懒加载配置更加简洁，因为不再需要为每个懒加载的组件创建单独的模块。 ","路由规则#路由规则":"重定向 const routes: Routes = [ { path: \"home\", component: HomeComponent }, { path: \"about\", component: AboutComponent }, { path: \"\", // 重定向 redirectTo: \"home\", // 完全匹配 pathMatch: \"full\" } ] 404 页面 const routes: Routes = [ { path: \"home\", component: HomeComponent }, { path: \"about\", component: AboutComponent }, { path: \"**\", component: NotFoundComponent } ] "},"title":"路由"},"/frontend-learn/docs/framework/angular/12_http/":{"data":{"":"该模块用于发送 Http 请求，用于发送请求的方法都返回 Observable 对象。","快速开始#快速开始":" 引入 HttpClientModule 模块\n// app.module.ts import { httpClientModule } from '@angular/common/http'; imports: [ httpClientModule ] 注入 HttpClient 服务实例对象，用于发送请求\n// app.component.ts import { HttpClient } from '@angular/common/http'; export class AppComponent { constructor(private http: HttpClient) {} } 发送请求\nimport { HttpClient } from \"@angular/common/http\" export class AppComponent implements OnInit { constructor(private http: HttpClient) {} ngOnInit() { this.getUsers().subscribe(console.log) } getUsers() { return this.http.get(\"https://jsonplaceholder.typicode.com/users\") } } ","拦截器#拦截器":"多个拦截器是按顺序执行的，顺序从上到下，即先注册的拦截器会先执行。\n请求拦截器：先处理请求 响应拦截器：先处理响应 如果你有多个拦截器，它们会按顺序依次处理请求和响应。\n创建拦截器：ng g interceptor \u003cname\u003e。\n请求拦截 一个拦截器用来记录每个请求和响应的日志：\n// logging-interceptor.service.ts import { Injectable } from '@angular/core'; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http'; import { Observable } from 'rxjs'; @Injectable() export class LoggingInterceptor implements HttpInterceptor { intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e { console.log('Request:', req); // 继续传递请求 return next(req).pipe( tap( event =\u003e console.log('Response:', event), error =\u003e console.error('Error:', error) ) ); } } 为每个 HTTP 请求中自动附加一个身份验证令牌：\n// auth-interceptor.service.ts import { Injectable } from '@angular/core'; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http'; import { Observable } from 'rxjs'; import { AuthService } from './auth.service'; // 假设你有一个 AuthService 来获取 token @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(private authService: AuthService) {} intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e { // 获取存储的 token const authToken = this.authService.getToken(); // 如果 token 存在，修改请求头，添加 Authorization if (authToken) { const clonedRequest = req.clone({ setHeaders: { Authorization: `Bearer ${authToken}` } }); // 将修改后的请求传递给下一个处理程序 return next(clonedRequest); } // 如果没有 token，直接传递原始请求 return next(req); } } 响应拦截 // response-interceptor.service.ts import { Injectable } from '@angular/core'; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http'; import { Observable } from 'rxjs'; import { tap } from 'rxjs/operators'; @Injectable() export class ResponseInterceptor implements HttpInterceptor { intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e { return next(req).pipe( tap(event =\u003e { if (event instanceof HttpResponse) { // 在响应到达时修改响应数据 console.log('Response body:', event.body); // 你可以在这里修改响应数据，比如做一些转换 } }) ); } } 使用拦截器来集中处理 HTTP 错误，比如统一处理 401 错误（未授权）或 500 错误（服务器错误）：\n// error-interceptor.service.ts import { Injectable } from '@angular/core'; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http'; import { Observable } from 'rxjs'; import { catchError } from 'rxjs/operators'; import { throwError } from 'rxjs'; @Injectable() export class ErrorInterceptor implements HttpInterceptor { intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e { return next(req).pipe( catchError(error =\u003e { if (error.status === 401) { console.error('Unauthorized request. Redirecting to login...'); // 处理 401 错误：例如跳转到登录页 } else if (error.status === 500) { console.error('Internal server error:', error); // 处理 500 错误：例如弹出错误提示 } return throwError(error); // 重新抛出错误 }) ); } } 拦截器注入 @NgModule({ providers: [ { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true } ] }) export class AppModule {} 拦截器的顺序 在 Angular 中，HttpInterceptor 的执行顺序是由它们在应用中提供的顺序来决定的。\n请求拦截器：按照它们在 HTTP_INTERCEPTORS 数组中的提供顺序执行。 响应拦截器：按照提供顺序的倒序执行。 示例：\n@Injectable() export class InterceptorA implements HttpInterceptor { intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler) { console.log('Interceptor A - Request'); return next.handle(req); } } @Injectable() export class InterceptorB implements HttpInterceptor { intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler) { console.log('Interceptor B - Request'); return next.handle(req); } } @Injectable() export class InterceptorC implements HttpInterceptor { intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler) { console.log('Interceptor C - Request'); return next.handle(req); } } 提供这些拦截器：\nprovideHttpClient( withInterceptors([ InterceptorA, InterceptorB, InterceptorC ]) ) 执行顺序：\n请求发送时，顺序为：A → B → C（根据它们在 providers 中的顺序）。 响应返回时，顺序为：C → B → A（顺序是反向的）。 这种顺序安排可以灵活地控制拦截器的执行逻辑，比如先进行认证验证，再进行日志记录，或者先进行某种处理，最后做错误处理等。\nHttpContext 在 Angular 中，HttpInterceptor 提供了拦截和修改 HTTP 请求的机制，从 Angular 15 开始，HttpClient 添加了 context 属性，可以携带额外的上下文信息供拦截器或服务使用。这为拦截器在不依赖全局状态或修改请求头的情况下提供了传递数据的方式。\n定义 HttpContextToken HttpContextToken 是用来定义和获取上下文值的工具：\nimport { HttpContextToken } from '@angular/common/http'; // 定义一个上下文 Token export const MY_CONTEXT_TOKEN = new HttpContextToken\u003cstring\u003e(() =\u003e null); // 默认值为 null 在请求中设置 context 在发起请求时，通过 HttpClient 的 context 属性设置值：\nimport { HttpClient, HttpContext } from '@angular/common/http'; import { Component } from '@angular/core'; import { MY_CONTEXT_TOKEN } from './context-token'; @Component({ selector: 'app-root', template: `\u003cp\u003eCheck Console\u003c/p\u003e` }) export class AppComponent { constructor(private http: HttpClient) { // 创建一个带有 context 的 HttpContext 对象 const context = new HttpContext().set(MY_CONTEXT_TOKEN, 'CustomHeaderValue'); // 发起请求时附加 context this.http.get('/api/data', { context }).subscribe(response =\u003e { console.log(response); }); } } 拦截器设置 在拦截器中，可以使用 request.context.get() 获取 HttpContext 中的值：\nimport { Injectable } from '@angular/core'; import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http'; import { Observable } from 'rxjs'; @Injectable() export class CustomInterceptor implements HttpInterceptor { intercept(request: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e { // 获取 context 中的值 const customValue = request.context.get(MY_CONTEXT_TOKEN); if (customValue) { console.log('Context value:', customValue); // 可以基于 context 的值修改请求，例如添加自定义 header request = request.clone({ headers: req.headers.append('X-Custom-Header', customValue), }); } return next(request); } } ","请求方法#请求方法":" this.http.get(url [, options]); this.http.post(url, data [, options]); this.http.delete(url [, options]); this.http.put(url, data [, options]); this.http.get\u003cPost[]\u003e('/getAllPosts') .subscribe(response =\u003e console.log(response)) ","请求的配置选项#请求的配置选项":"请求参数 import { HttpParams } from '@angular/common/http'; const params = new HttpParams().set('page', '1').set('limit', '10'); this.http.get('url', { params }).subscribe(response =\u003e console.log(response)); 请求头 import { HttpHeaders } from '@angular/common/http'; const headers = new HttpHeaders().set('Authorization', 'Bearer token'); this.http.get('url', { headers }).subscribe(response =\u003e console.log(response)); 响应内容 declare type HttpObserve = 'body' | 'response'; // response 读取完整响应体 // body 读取服务器端返回的数据 this.http.get( \"https://jsonplaceholder.typicode.com/users\", { observe: \"body\" } ).subscribe(console.log) "},"title":"HttpClient"},"/frontend-learn/docs/framework/angular/13_other/":{"data":{"":"","angular-操作-dom#Angular 操作 DOM":"","app_initializer#APP_INITIALIZER":"","attribute-装饰器#Attribute 装饰器":"","cdk#cdk":"@angular/cdk/dialog @angular/cdk/dialog 提供了一种轻量级的方式来创建对话框。\n基本用法：\n在 app.module.ts 或 feature module 中导入 DialogModule，imports: [BrowserModule, DialogModule]。\n创建对话框组件\nimport { Component, Inject } from '@angular/core'; import { DialogRef, DIALOG_DATA } from '@angular/cdk/dialog'; @Component({ selector: 'app-my-dialog', template: ` \u003ch2\u003e对话框\u003c/h2\u003e \u003cp\u003e传递的数据: {{ data }}\u003c/p\u003e \u003cbutton (click)=\"close()\"\u003e关闭\u003c/button\u003e `, }) export class MyDialogComponent { constructor( public dialogRef: DialogRef\u003cMyDialogComponent\u003e, // DialogRef 允许控制对话框（如关闭） @Inject(DIALOG_DATA) public data: any // IALOG_DATA 用于接收打开对话框时传递的数据。 ) {} close() { this.dialogRef.close('Dialog 关闭了'); } } 打开对话框\nimport { Component } from '@angular/core'; import { Dialog } from '@angular/cdk/dialog'; import { MyDialogComponent } from './my-dialog.component'; @Component({ selector: 'app-root', template: `\u003cbutton (click)=\"openDialog()\"\u003e打开对话框\u003c/button\u003e`, }) export class AppComponent { constructor(private dialog: Dialog) {} openDialog() { const dialogRef = this.dialog.open(MyDialogComponent, { data: 'Hello from parent component!', }); // 监听对话框关闭事件 dialogRef.closed.subscribe(result =\u003e { console.log('对话框关闭:', result); }); } } @angular/cdk/overlay @angular/cdk/overlay 是 Angular CDK 提供的一个强大的工具，用于创建浮动层（overlay），它可以用于构建自定义的模态框、下拉菜单、工具提示（tooltip）等。\n基本用法:\n在 app.module.ts 或 feature module 中导入 OverlayModule，imports: [BrowserModule, OverlayModule]。\n创建浮层组件：\nimport { Component } from '@angular/core'; @Component({ selector: 'app-tooltip', template: `\u003cdiv class=\"tooltip-content\"\u003e这是一个浮层\u003c/div\u003e`, styles: [ ` .tooltip-content { background: black; color: white; padding: 8px; border-radius: 4px; } `, ], }) export class TooltipComponent {} 在 AppComponent（或任何组件）中使用 Overlay：\nimport { Component, ElementRef, ViewChild } from '@angular/core'; import { Overlay, OverlayRef } from '@angular/cdk/overlay'; import { ComponentPortal } from '@angular/cdk/portal'; @Component({ selector: 'app-root', template: ` \u003cbutton #trigger (click)=\"openOverlay()\"\u003e打开浮层\u003c/button\u003e `, }) export class AppComponent { @ViewChild('trigger') trigger!: ElementRef; private overlayRef!: OverlayRef; constructor(private overlay: Overlay) {} openOverlay() { // 获取按钮的位置信息 const positionStrategy = this.overlay .position() .flexibleConnectedTo(this.trigger) .withPositions([{ originX: 'center', originY: 'bottom', overlayX: 'center', overlayY: 'top' }]); // 创建 OverlayRef this.overlayRef = this.overlay.create({ positionStrategy, hasBackdrop: true, // 添加背景（点击外部关闭） backdropClass: 'cdk-overlay-transparent-backdrop', }); // 监听背景点击事件，关闭浮层 this.overlayRef.backdropClick().subscribe(() =\u003e this.overlayRef.dispose()); // 将浮层附加到 Overlay const tooltipPortal = new ComponentPortal(TooltipComponent); this.overlayRef.attach(tooltipPortal); // 使用 TemplatePortal 将 ng-template 渲染到 Overlay // const portal = new TemplatePortal(template, this.viewContainerRef); // this.overlayRef.attach(portal); } } 高级用法：\n添加 scroll 和 resize 监听。默认情况下，Overlay 不会监听滚动事件。如果需要在滚动或窗口大小变化时关闭浮层，可以使用 closeOnScroll()：\nthis.overlayRef = this.overlay.create({ positionStrategy, scrollStrategy: this.overlay.scrollStrategies.close(), }); 如果希望浮层始终跟随目标元素（如 Dropdown），可以使用 RepositionScrollStrategy：\nthis.overlayRef = this.overlay.create({ positionStrategy, scrollStrategy: this.overlay.scrollStrategies.reposition(), }); 这样，在滚动时浮层不会消失，而是重新计算位置。\n如果需要浮层固定在屏幕中央（如 Modal），可以使用 GlobalPositionStrategy：\nconst positionStrategy = this.overlay.position().global().centerHorizontally().centerVertically(); this.overlayRef = this.overlay.create({ positionStrategy }); ","computed#computed":"在 Angular 17+ 版本中，@angular/core 提供了 computed() 方法，它是 Angular Signals 系统的一部分，用于创建计算属性（类似 Vue 的 computed）。\nimport { Component, computed, signal } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', }) export class AppComponent { // 创建信号 firstName = signal('John'); lastName = signal('Doe'); // 使用 computed 创建计算属性 fullName = computed(() =\u003e `${this.firstName()} ${this.lastName()}`); updateFirstName(value: string) { this.firstName.set(value); } updateLastName(value: string) { this.lastName.set(value); } } 使用：\n\u003cp\u003eFull Name: {{ fullName() }}\u003c/p\u003e \u003cinput (input)=\"updateFirstName($event.target.value)\" placeholder=\"First Name\"\u003e \u003cinput (input)=\"updateLastName($event.target.value)\" placeholder=\"Last Name\"\u003e 只有当依赖项发生变化时，computed() 才会重新计算，从而提高性能。\n与 getter 的区别 在传统 Angular 变更检测中，每次变更检测都会重新执行 getter，即使数据没有变化。而 computed() 只会在依赖项变化时重新计算，这样能显著提高性能。\n结合 effect() 监听 computed 值 如果需要在 computed() 值变化时执行某些副作用（比如日志记录、调用 API 等），可以使用 effect()。\nimport { Component, computed, effect, signal } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', }) export class AppComponent { firstName = signal('John'); lastName = signal('Doe'); fullName = computed(() =\u003e `${this.firstName()} ${this.lastName()}`); constructor() { // 监听 fullName 变化 effect(() =\u003e { console.log('Full name updated:', this.fullName()); }); } } effect() 会自动追踪 computed() 的变化，无需手动订阅。","document#DOCUMENT":"","domsanitizer#DomSanitizer":"","environment_initializer#ENVIRONMENT_INITIALIZER":"","host-host-contextng-deep#\u003ccode\u003e:host\u003c/code\u003e 、\u003ccode\u003e:host-context\u003c/code\u003e、\u003ccode\u003e::ng-deep\u003c/code\u003e":"Angular 操作 DOM ElementRef ElementRef 是一个包装器，提供了对原生 DOM 元素的引用，通常是通过 @ViewChild 或 @ContentChild 来访问模板中的元素，但也可以直接注入 ElementRef 来操作宿主元素。\n当你直接注入 ElementRef 时，Angular 会自动将组件或指令的宿主元素传递给你。你可以通过 ElementRef 访问宿主元素，并执行一些 DOM 操作：\nimport { Component, ElementRef, OnInit } from '@angular/core'; @Component({ selector: 'app-example', template: `\u003cp\u003eThis is an example component!\u003c/p\u003e` }) export class ExampleComponent implements OnInit { constructor(private elementRef: ElementRef) {} ngOnInit() { // 通过 ElementRef 访问宿主元素 console.log(this.elementRef.nativeElement); // 打印宿主元素 this.elementRef.nativeElement.style.backgroundColor = 'lightblue'; // 动态修改背景色 } } 直接注入 ElementRef 虽然可以直接通过 nativeElement 操作 DOM，但更推荐使用 Renderer2 来确保代码的跨平台兼容性、安全性和稳定性。\nViewRef ViewRef 是 Angular 视图 (View) 的抽象。在 Angular 中，View 是应用程序的基本构建块。它是在一起被创建或者销毁的最小元素组单位。Angular 哲学鼓励开发者将 UI 界面 看作 View 的聚合。而不要看作标准的 HTML 元素树。\nAngular 支持两种 View:\nEmbedded View，指 Template Host View，指 Component ViewContainerRef 用于动态地管理视图（View）的 Service。它允许你在运行时向应用程序中添加、移除或更改视图（模板），从而实现动态组件加载、条件渲染等功能。\n动态创建组件 import { Component } from '@angular/core'; @Component({ selector: 'app-dynamic', template: `\u003cp\u003eThis is a dynamically loaded component!\u003c/p\u003e` }) export class DynamicComponent {} 父组件：\nimport { Component, ViewChild, ViewContainerRef, ComponentFactoryResolver, OnInit } from '@angular/core'; import { DynamicComponent } from './dynamic.component'; @Component({ selector: 'app-parent', template: `\u003cng-container #container\u003e\u003c/ng-container\u003e` }) export class ParentComponent implements OnInit { @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; constructor(private componentFactoryResolver: ComponentFactoryResolver) {} ngOnInit() { // 创建并插入动态组件 const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent); this.container.clear(); // 清除之前的视图（如果有的话） this.container.createComponent(componentFactory); // 动态加载组件 } } 使用 @ViewChild('container', { read: ViewContainerRef }) 获取 ViewContainerRef。 通过 ComponentFactoryResolver 创建 DynamicComponent 的工厂，并使用 ViewContainerRef 将组件插入视图。 clear() 方法用于清除容器中的所有现有视图（可选，防止插入多个相同组件）。 动态插入模板 ViewContainerRef 还可以与 TemplateRef 配合使用，用于动态插入模板。\nimport { Component, ViewChild, ViewContainerRef, TemplateRef, OnInit } from '@angular/core'; @Component({ selector: 'app-parent', template: ` \u003cng-template #template\u003e \u003cp\u003eThis is a dynamically inserted template!\u003c/p\u003e \u003c/ng-template\u003e \u003cng-container #container\u003e\u003c/ng-container\u003e ` }) export class ParentComponent implements OnInit { @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; @ViewChild('template') template: TemplateRef\u003cany\u003e; ngOnInit() { // 动态插入模板 this.container.createEmbeddedView(this.template); } } 条件渲染 ViewContainerRef 可以通过动态加载组件和模板来实现条件渲染。\nimport { Component, ViewChild, ViewContainerRef, ComponentFactoryResolver, OnInit } from '@angular/core'; import { DynamicComponent } from './dynamic.component'; @Component({ selector: 'app-parent', template: ` \u003cbutton (click)=\"toggleComponent()\"\u003eToggle Component\u003c/button\u003e \u003cng-container #container\u003e\u003c/ng-container\u003e ` }) export class ParentComponent implements OnInit { @ViewChild('container', { read: ViewContainerRef }) container: ViewContainerRef; private componentCreated = false; constructor(private componentFactoryResolver: ComponentFactoryResolver) {} ngOnInit() {} toggleComponent() { if (this.componentCreated) { this.container.clear(); // 移除组件 this.componentCreated = false; } else { const componentFactory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent); this.container.createComponent(componentFactory); // 动态创建组件 this.componentCreated = true; } } } 在上面的代码中：\n点击按钮会动态插入或删除 DynamicComponent。 通过 ViewContainerRef.clear() 方法移除组件或视图。 Renderer2 Renderer2 是一个用于与 DOM 进行交互的服务，它提供了一些安全的、平台无关的 API 来操作 DOM 元素。\nRenderer2 的主要目的是提供跨平台的兼容性，使得 Angular 应用可以在浏览器、服务器端渲染（Angular Universal）等环境下正常工作，同时也提高了代码的安全性（例如避免直接操作 DOM 引发 XSS 攻击）。\nimport { Component, Renderer2, ElementRef, OnInit } from '@angular/core'; @Component({ selector: 'app-example', templateUrl: './example.component.html' }) export class ExampleComponent implements OnInit { constructor(private renderer: Renderer2, private el: ElementRef) {} ngOnInit() { // 使用 Renderer2 操作 DOM } } setProperty：用于设置指定元素的属性，第二个参数是要设置的值。\nthis.renderer.setProperty(this.el.nativeElement, 'textContent', 'Hello World!'); setStyle：用于设置元素的样式，第一个参数是 DOM 元素，第二个参数是 CSS 属性名称，第三个参数是样式的值。\nremoveStyle：移除元素的指定样式。\nthis.renderer.setStyle(this.el.nativeElement, 'color', 'red'); this.renderer.removeStyle(this.el.nativeElement, 'color'); addClass：给元素添加指定的 CSS 类。\nremoveClass：从元素中移除指定的 CSS 类。\nthis.renderer.addClass(this.el.nativeElement, 'highlight'); this.renderer.removeClass(this.el.nativeElement, 'highlight'); listen：用于监听 DOM 事件\nconst unsubscribe = this.renderer.listen(this.el.nativeElement, 'click', (event) =\u003e { console.log('Element clicked'); }); createElement：用于创建一个 DOM 元素。\ncreateText：用于创建一个文本节点。\nappendChild：用于将子元素添加到父元素。\nremoveChild：`方法，用于从父元素中移除子元素。\nconst div = this.renderer.createElement('div'); const text = this.renderer.createText('Hello Renderer2!'); this.renderer.appendChild(div, text); this.renderer.appendChild(this.el.nativeElement, div); this.renderer.removeChild(this.el.nativeElement, div); Title Title 标签是一个 HTML 元素，用于指定网页标题。Title 标签作为给定结果的可点击标题，显示在搜索引擎结果页面（SERP）上。它们对于可用性、SEO 和社交共享而言至关重要。\nAngular 在 @angular/platform-browser 中有一个 Title 服务。只需将 Title 服务注入到组件中，然后使用 setTitle 方法设置标题。\nimport { Title } from \"@angular/platform-browser\" @Component({ ... }) export class LoginComponent implements OnInit { constructor(private title: Title) {} ngOnInit() { title.setTitle(\"Login\") } } Meta Angular 在 @angular/platform-browser 中有一个 Meta 服务，使我们能够从组件中设置 meta 标签。\nMeta 元素提供有关网页的信息，搜索引擎可以在这些信息的帮助下正确地分类网页。\nimport { Meta } from \"@angular/platform-browser\" @Component({ ... }) export class BlogComponent implements OnInit { constructor(private meta: Meta) {} ngOnInit() { meta.updateTag({name: \"title\", content: \"\"}) meta.updateTag({name: \"description\", content: \"Lorem ipsum dolor\"}) meta.updateTag({name: \"image\", content: \"./assets/blog-image.jpg\"}) meta.updateTag({name: \"site\", content: \"My Site\"}) } } DOCUMENT DOCUMENT 是一个注入令牌（token），它是一个用于获取和操作浏览器 document 对象的服务。直接使用 window.document 只能在浏览器环境中工作，而 Angular 提供的 DOCUMENT 是通过依赖注入来提供的，可以在浏览器和其他环境（如服务器端渲染）之间自动适配。\nimport { Component, Inject, OnInit } from '@angular/core'; import { DOCUMENT } from '@angular/common'; @Component({ selector: 'app-document-example', template: `\u003ch1\u003eCheck the document title in the console!\u003c/h1\u003e` }) export class DocumentExampleComponent implements OnInit { constructor(@Inject(DOCUMENT) private document: Document) {} ngOnInit() { // 访问和操作 document 对象 console.log('Document title:', this.document.title); this.document.title = 'New Document Title'; // 修改文档标题 } } Location Location 是一个提供访问和操作浏览器 URL 的服务。它允许在不重新加载页面的情况下操作浏览器的历史记录和 URL。这使得你能够在单页面应用（SPA）中实现 URL 路由和导航，同时避免浏览器刷新。\n不要直接修改 window.location，使用 Location 或 Router 来保证跨平台兼容性。并且 Location 支持服务端渲染（SSR），可以在 Node.js 环境中模拟操作。\n与 window.location 的区别 功能 Angular Location window.location 修改 URL 可以修改 URL，不会刷新页面 修改 URL 时通常会导致页面刷新 支持单页面应用（SPA） 是专为单页面应用设计的工具 通常用于传统的页面导航和跳转 操作历史记录 提供 back 和 forward 方法 使用 history.back() 等实现 获取和解析 URL 提供 path() 等方法获取路径部分 提供 window.location.pathname 等 不触发页面刷新 支持通过 go() 和 replaceState() 修改 URL 而不刷新页面 大部分操作都会导致页面刷新 适用场景：\n场景 Angular Location window.location 单页面应用（SPA） 推荐使用，用于导航和历史记录管理 不推荐，会导致页面刷新 传统页面跳转 不适用 推荐使用 操作浏览器历史记录 提供方便的方法，如 back()、forward() 可以通过 window.history 操作 URL 操作与刷新行为 不刷新页面，适合动态导航 大多数情况下刷新页面 NgZone NgZone 是 Angular 提供的一个服务，用于与 Angular 的变更检测机制进行交互，帮助你控制异步操作和变更检测的行为。\nNgZone 允许你在执行异步操作时明确控制是否触发变更检测，避免不必要的性能开销。\nNgZone 是 Angular 基于 zone.js 库的一个封装，zone.js 是一个 JavaScript 库，帮助开发者追踪异步任务的执行。通过 NgZone，Angular 可以追踪和管理异步任务（如定时器、HTTP 请求、用户输入事件等），并确保这些任务在执行后会触发 Angular 的变更检测机制。\nrunOutsideAngular 函数 runOutsideAngular 内执行的代码不会触发变更检测。\nimport { Component, NgZone } from '@angular/core'; @Component({ selector: 'app-ngzone-example', template: `\u003ch1\u003e{{ message }}\u003c/h1\u003e` }) export class NgZoneExampleComponent { message: string = 'Hello'; constructor(private ngZone: NgZone) {} startLongRunningTask() { // 在 Angular Zone 外部运行代码，不触发变更检测 this.ngZone.runOutsideAngular(() =\u003e { setInterval(() =\u003e { // 假设这是一个非常频繁的操作 console.log('Running outside Angular zone'); }, 1000); }); } } run run 方法的目的与 runOutsideAngular 正好相反。任何写在 run 里的方法，都会进入 Angular Zone 的管辖范围，确保变更检测被触发。\nimport { Component, NgZone } from '@angular/core'; @Component({ selector: 'app-ngzone-example', template: `\u003ch1\u003e{{ message }}\u003c/h1\u003e` }) export class NgZoneExampleComponent { message: string = 'Hello'; constructor(private ngZone: NgZone) {} updateMessage() { // 在 Angular Zone 内运行，确保变更检测被触发 this.ngZone.run(() =\u003e { this.message = 'Updated Message'; }); } } onStable onStable：是一个 Observable，它会在 Angular 完成所有异步任务并且变更检测稳定后触发。这在需要确保所有变更检测已经完成之后执行某些操作时非常有用。\nimport { Component, NgZone, OnInit } from '@angular/core'; @Component({ selector: 'app-ngzone-example', template: `\u003ch1\u003e{{ message }}\u003c/h1\u003e` }) export class NgZoneExampleComponent implements OnInit { message: string = 'Hello'; constructor(private ngZone: NgZone) {} ngOnInit() { // 监听 Angular Zone 的稳定事件 this.ngZone.onStable.subscribe(() =\u003e { console.log('All asynchronous tasks have completed.'); }); } } hasPendingMacrotasks 和 hasPendingMicrotasks hasPendingMacrotasks 和 hasPendingMicrotasks 用于检查 Angular Zone 内是否还有待处理的宏任务和微任务。这在调试时可以非常有用，帮助你确定是否还有异步任务在执行。\nimport { Component, NgZone, OnInit } from '@angular/core'; @Component({ selector: 'app-ngzone-example', template: `\u003ch1\u003e{{ message }}\u003c/h1\u003e` }) export class NgZoneExampleComponent implements OnInit { message: string = 'Hello'; constructor(private ngZone: NgZone) {} ngOnInit() { console.log('Has pending macro tasks:', this.ngZone.hasPendingMacrotasks); console.log('Has pending micro tasks:', this.ngZone.hasPendingMicrotasks); } } DomSanitizer 用于帮助开发者安全地处理动态 HTML、样式、URL、资源等。它的主要作用是防止 跨站脚本攻击（XSS），通过对可能不安全的内容进行清理和消毒，确保它们在渲染时不会带来安全风险。\nimport { Component } from '@angular/core'; import { DomSanitizer, SafeHtml, SafeStyle, SafeUrl, SafeResourceUrl } from '@angular/platform-browser'; @Component({ selector: 'app-example', template: ` \u003cdiv [innerHTML]=\"trustedHtml\"\u003e\u003c/div\u003e \u003cimg [src]=\"trustedUrl\" /\u003e `, }) export class ExampleComponent { trustedHtml: SafeHtml; trustedUrl: SafeUrl; constructor(private sanitizer: DomSanitizer) { // 使用 DomSanitizer 处理不安全的内容 this.trustedHtml = this.sanitizer.bypassSecurityTrustHtml('\u003cp\u003eUnsafe HTML content\u003c/p\u003e'); this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl('javascript:alert(\"XSS Attack\")'); } } DomSanitizer 常用方法：\nbypassSecurityTrustHtml：将不安全的 HTML 内容标记为“可信”，以便 Angular 渲染。这个方法通常用于插入动态 HTML 内容。\nbypassSecurityTrustUrl：将 URL 标记为可信的 URL，通常用于动态绑定 href、src 或其他需要 URL 的属性。\nbypassSecurityTrustStyle：将 CSS 样式标记为可信，允许动态添加不安全的样式到组件中。\nimport { DomSanitizer } from '@angular/platform-browser'; export class ExampleComponent { constructor(private sanitizer: DomSanitizer) {} getTrustedStyle() { const unsafeStyle = 'background-color: red;'; return this.sanitizer.bypassSecurityTrustStyle(unsafeStyle); } } bypassSecurityTrustResourceUrl：用于将不安全的资源 URL（如 iframe 的 src）标记为可信资源。可以用于动态加载嵌入式资源（如视频、音频等）。\nAttribute 装饰器 @Attribute 装饰器用于读取宿主元素的属性，而不是组件或指令的输入属性。 它主要用于访问那些静态的 HTML 属性（如 id, class, aria-label 等），并且这些属性是直接应用在宿主元素上的。\n\u003capp-example data-id=\"12345\"\u003e\u003c/app-example\u003e import { Component, Attribute } from '@angular/core'; @Component({ selector: 'app-example', template: `\u003cp\u003e{{ dataId }}\u003c/p\u003e` }) export class ExampleComponent { constructor(@Attribute('data-id') public dataId: string) { console.log('Data ID:', dataId); // 12345 } } APP_INITIALIZER 有时候我们需要在 Angular 应用启动时运行一段代码，这段代码可能会加载一些设置，比如加载缓存，加载配置。可以使用 APP_INITIALIZER。\nAPP_INITIALIZER：初始化应用时执行的函数。如果这些函数中的任何一个返回一个 Promise 或 Observable，初始化就不会完成，直到 Promise 被解析或 Observable 被完成。\n只需要 AppModule 中添加 APP_INITIALIZER 即可：\nfunction runSettingsOnInit() { ... } @NgModule({ providers: [ { provide: APP_INITIALIZER, useFactory: runSettingsOnInit } ] }) Angular 支持多个 APP_INITIALIZER，多个 APP_INITIALIZER 是并行执行的。如果某些初始化逻辑是异步的（例如返回 Promise 或 Observable），Angular 会等待所有异步操作完成后，再继续引导（bootstrap）应用程序。\nENVIRONMENT_INITIALIZER ENVIRONMENT_INITIALIZER 是 Angular 14 引入的，用于在 Angular 应用启动期间运行长时间任务。它允许开发者在环境注入器中注入一个或多个初始化函数，这些函数在环境准备阶段执行。这个特性特别适用于那些需要在应用程序启动时完成的初始化工作，但又不适合放在 APP_INITIALIZER 中执行的场景。比如设置全局的服务或配置，这些工作通常需要在应用程序完全启动之前完成。\n提高应用性能：通过在环境级别进行初始化，可以减少应用启动时的延迟，因为这些初始化任务可以在应用程序完全启动之前完成，从而提高应用的性能和响应速度。\nPLATFORM_INITIALIZER PLATFORM_INITIALIZER 是用于初始化 Angular 平台的机制。这个机制允许开发者在 Angular 平台（例如在浏览器中）完全启动之前执行一些初始化逻辑。\nPLATFORM_INITIALIZER 通常用于执行那些需要在 Angular 平台完全启动之前完成的初始化任务，比如设置全局的提供者和服务。这个初始化器与 APP_INITIALIZER 和 ENVIRONMENT_INITIALIZER 的主要区别在于它的执行时机和作用范围，它更侧重于平台级别的初始化。\n:host 、:host-context、::ng-deep :host :host 是一个伪类选择器，用于选中当前组件的宿主元素（即 \u003cmy-component\u003e\u003c/my-component\u003e）。它可以用于定义组件根元素的样式。该选择器允许你从组件的样式文件中访问组件外部的宿主元素，而不是组件内部的子元素。\n\u003c!-- my-component.component.html --\u003e \u003cdiv class=\"inner\"\u003e \u003cp\u003eContent inside component\u003c/p\u003e \u003c/div\u003e 在组件的样式中，使用 :host 来修改宿主元素的样式：\n/* my-component.component.css */ :host { display: block; border: 1px solid red; padding: 20px; } :host(.highlight) { background-color: yellow; } 在这个例子中 :host 选择器作用于组件的宿主元素 \u003cmy-component\u003e\u003c/my-component\u003e。\n:host 只能影响宿主元素（组件标签）。 适用于修改组件根元素的样式。 :host-context :host-context 是另一个伪类选择器，作用于宿主元素及其外部上下文。它允许你根据宿主元素的外部环境（即外部父组件或全局样式）来修改组件的样式。\n:host-context 选择器类似于 :host，但它可以应用样式时依赖宿主元素的某些父元素的样式或类。\n示例，一个父组件：\n\u003c!-- parent.component.html --\u003e \u003capp-my-component class=\"special\"\u003e\u003c/app-my-component\u003e 在 MyComponent 的样式中：\n/* my-component.component.css */ :host-context(.special) { background-color: lightblue; } :host-context(.another-class) { background-color: lightgreen; } 在这个例子中：\n当 app-my-component 的外部元素（父元素）有 special 类时，MyComponent 会获得 background-color: lightblue 的样式。 当父元素有 another-class 时，background-color 会变为 lightgreen。 ::ng-deep ::ng-deep 是一个 Angular 特有的伪类选择器，用于穿透组件的样式封装，允许你修改子组件或深层子元素的样式，即使这些子元素位于封装的视图中。\n由于 Angular 使用的是 视图封装（View Encapsulation），通常，组件的样式只会影响该组件内部的元素，不会影响到其子组件或外部元素。::ng-deep 允许你突破这种封装，影响子组件内部的样式。\n示例：一个子组件 ChildComponent，并且你想在父组件中修改 ChildComponent 的样式。可以使用 ::ng-deep：\n\u003c!-- parent.component.html --\u003e \u003capp-child\u003e\u003c/app-child\u003e 在父组件的样式中：\n/* parent.component.css */ ::ng-deep app-child .child-element { color: red; } 即使 app-child 有自己的封装样式，父组件仍然可以通过 ::ng-deep 来修改 app-child 内部的 .child-element 元素的样式。","location#Location":"","meta#Meta":"","ngzone#NgZone":"","platform_initializer#PLATFORM_INITIALIZER":"","title#Title":""},"title":"其他"},"/frontend-learn/docs/framework/rxjs/01_overview/":{"data":{"":"RxJS：Think of RxJS as Lodash for events。也就是说，RxJS 是一个类似 lodash 的工具库，不过处理的对象是 Events。这里的 Events，可以称之为流。\n什么是流？例如，代码中每秒会输出一个数据，或者用户每一次对元素的点击，就像是在时间这个维度上，产生了一个数据集。这个数据集不像数组那样，它不是一开始都存在的，而是随着时间的流逝，一个一个数据被输出出来。这种异步行为产生的数据，就可以被称之为一个流，在 Rxjs 中，称之为 Observalbe（本质其实就是一个数据集合，只是这些数据不一定是一开始就设定好的，而是随着时间而不断产生的）。而 Rxjs，就是为了处理这种流而产生的工具，比如流与流的合并，流的截断，延迟，消抖等等操作。\nimport {interval, map} from 'rxjs'; const sub = interval(1000).pipe( map(second =\u003e second + 's') ).subscribe(res =\u003e { console.log(res); }); // Output: // 0s // 2s // 3s // 4s // 5s // ... 利用 interval 返回一个 Observable 流，每 1 秒产生一个数据，然后交给 map 操作符将内容进行转换，最后交过观察者打印结果。","observable-的核心#Observable 的核心":"创建 import { Observable } from 'rxjs'; const observable = new Observable(function subscribe(subscriber) { const timer = setInterval(() =\u003e { // 可以多次调用 next 方法向外发送数据 subscriber.next('hi'); subscriber.next('hello'); // 当所有数据发送完成以后，可以调用 complete 方法终止数据发送 subscriber.complete(); clearInterval(timer); }, 1000); }); 通常会使用创建操作符, of、from、interval 等来创建。\nimport { of, from, fromEvent, fromPromise, bindCallback, bindNodeCallback } from 'rxjs'; // 将一个或多个值转为 Observable of('foo', 'bar'); // 将数组转为 Observable from([1, 2, 3]); // 将事件转为 Observable fromEvent(document.querySelector('button'), 'click'); // 将 Promise 转为 Observable fromPromise(fetch('/users')); // 将回调函数 (最后一个参数是回调函数，比如下面的 cb) 转为 Observable // fs.exists = (path, cb(exists)) var exists = bindCallback(fs.exists); exists('file.txt').subscribe(exists =\u003e console.log('Does file exist?', exists)); // 将回调函数(最后一个参数得是回调函数，比如下面的 cb) 转为 Observable // fs.rename = (pathA, pathB, cb(err, result)) var rename = bindNodeCallback(fs.rename); rename('file.txt', 'else.txt').subscribe(() =\u003e console.log('Renamed!')); 订阅 observable.subscribe((x) =\u003e console.log(x)); 订阅 Observable 可以理解为启动这个 Observable 流，并提供接收数据的回调函数。\n同一个 Observable 可以被多次订阅，并且每个观察这都是独立的。每个 subscribe 会启动一个独立的流，并向观察者传递数据。流与流相互独立，互不干扰。\n执行 Observable 执行可以传递三种类型的值：\nnext 通知：发送一个值，比如数字、字符串、对象，等等。 error 通知：发送一个错误或异常。 complete 通知：不再发送任何值。 在 Observable 执行中, 可能会发送无穷个 next 通知。如果发送的是 error 或 complete 通知的话，那么之后不会再发送任何通知了。\nimport { Observable } from 'rxjs'; const observable = new Observable(function subscribe(subscriber) { try { subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete(); subscriber.next(3); // 不会发送 } catch (err) { subscriber.error(err); // 如果捕获到异常会发送一个错误 } }); 清理 因为 Observable 执行可能会是无限的，并且观察者通常希望能在有限的时间内中止执行，它必须要一种方法来停止执行，以避免浪费计算能力或内存资源。\nobservable.subscribe 会返回一个 Subscription 可以用来取消订阅。\nimport { from } from 'rxjs'; const observable = from([10, 20, 30]); const subscription = observable.subscribe((x) =\u003e console.log(x)); // Later: subscription.unsubscribe(); 可观察对象的命名约定 通常以 $ 符号结尾。","observer#Observer":"Observer 观察者只是一组回调函数的集合，用来消费 Observable 发送的数据。\nconst observer = { next: x =\u003e console.log('Observer got a next value: ' + x), error: err =\u003e console.error('Observer got an error: ' + err), complete: () =\u003e console.log('Observer got a complete notification'), }; observable.subscribe(observer); ","subscription#Subscription":"Subscription 通常是 Observable 的执行。Subscription 有一个重要的方法，即 unsubscribe，用来取消 Observable 执行。\nSubscription 还可以合在一起：\nimport { interval } from 'rxjs'; const observable1 = interval(400); const observable2 = interval(300); const subscription = observable1.subscribe(x =\u003e console.log('first: ' + x)); const childSubscription = observable2.subscribe(x =\u003e console.log('second: ' + x)); subscription.add(childSubscription); setTimeout(() =\u003e { // subscription 和 childSubscription 都会取消订阅 subscription.unsubscribe(); }, 1000); Subscriptions 还有一个 remove(otherSubscription) 方法，用来撤销一个已添加的子 Subscription。"},"title":"概念"},"/frontend-learn/docs/framework/rxjs/02_operators/":{"data":{"":"操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。并且前面的 Observable 保持不变。\n操作符有两类：\nPipeable 操作符：是指可以使用 observable.pipe(operator) 或更常用的 observable.pipe(operatorFactory()) 语法将操作符管道化的操作符。操作符工厂函数包括 filter(...) 和 mergeMap(...) 等。 创建操作符可以作为独立函数调用，可以创建一个新的 Observable。例如：of(1, 2, 3)。 ","pipeable-操作符#Pipeable 操作符":"转换操作符 map map：对数据流进行转换，基于原有值进行转换。\nimport { interval } from \"rxjs\" import { map } from \"rxjs/operators\" interval(1000) .pipe(map(n =\u003e n * 2)) .subscribe(n =\u003e console.log(n)) reduce、scan reduce: 用于将源 Observable 发出的所有的值累计成一个单一的结果。它类似于的数组 reduce 方法，但它是处理流的每个值，而不是数组。\nimport { of } from 'rxjs'; import { reduce } from 'rxjs/operators'; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4, 5); // 使用 reduce 操作符计算数字的总和 const sum$ = source$.pipe( reduce((acc, value) =\u003e acc + value, 0) ); // 订阅并打印输出 sum$.subscribe(result =\u003e console.log(result)); // 15 reduce(accumulator, [seed]) 接受两个参数：\naccumulator 是一个函数，接受两个参数： acc（累计值）：上一次迭代的结果，或者是初始值（如果提供了 seed）。 value：当前发出的值。 该函数需要返回新的累计值。 seed：可选。acc 的初始值。如果未提供，acc 会默认是流中的第一个值，从第二个值开始累计。 当 reduce 接收到源 Observable 的每个值时，会使用 accumulator 函数对当前值和累计值进行计算。 等到源 Observable 完成发射所有值时，reduce 会将最终的累计值作为结果发射出来。\nscan：类似 reduce，进行累计操作，但执行时机不同，数据源每次发出数据流 scan 都会执行。reduce 是发送出最终计算的结果，而 scan 是发出每次计算的结果。\nimport { of } from 'rxjs'; import { scan } from 'rxjs/operators'; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4, 5); // 使用 scan 操作符逐步计算总和 const sum$ = source$.pipe( scan((acc, value) =\u003e acc + value, 0) ); // 订阅并打印输出 sum$.subscribe(result =\u003e console.log(result)); // 1 // 3 // 6 // 10 // 15 groupBy 用于将源 Observable 发出的数据根据某个条件分组，并返回一个 GroupedObservable。groupBy 根据给定的键（通常是某个属性值）将数据分组（例如按用户 ID、地区、日期等对流中的数据进行分组），每个分组会返回一个新的 Observable，这些新的 Observable 会在后续操作符中被处理。\nimport { of } from 'rxjs'; import { groupBy, mergeMap, map } from 'rxjs/operators'; const source$ = of(1, 2, 3, 4, 5, 6, 7, 8, 9); source$.pipe( groupBy(value =\u003e value % 2 === 0 ? 'even' : 'odd'), // 按奇偶分组 mergeMap(group =\u003e group.pipe( map(value =\u003e `${group.key}: ${value}`) // 为每个组的元素加上标识 )) ).subscribe(console.log); // odd: 1 // odd: 3 // odd: 5 // odd: 7 // odd: 9 // even: 2 // even: 4 // even: 6 // even: 8 按对象属性分组：\nimport { of } from 'rxjs'; import { groupBy, mergeMap, map } from 'rxjs/operators'; const source$ = of( { name: 'Apple', category: 'Fruit' }, { name: 'Carrot', category: 'Vegetable' }, { name: 'Banana', category: 'Fruit' }, { name: 'Broccoli', category: 'Vegetable' } ); source$.pipe( groupBy(item =\u003e item.category), // 按类别分组 mergeMap(group =\u003e group.pipe( map(item =\u003e `${group.key}: ${item.name}`) // 对每个组的项进行处理 )) ).subscribe(console.log); // Fruit: Apple // Fruit: Banana // Vegetable: Carrot // Vegetable: Broccoli 过滤操作符 filter 对数据流进行过滤。\nimport {range} from \"rxjs\" import {filter} from \"rxjs/operators\" range(1, 10).pipe(filter((n) =\u003e n \u003e 5)) .subscribe((even) =\u003e console.log(even)); // Output: // 6 // 7 // 8 // 9 // 10 first 获取数据流中的第一个值或者查找数据流中第一个符合条件的值，类似数组中的 find 方法。获取到值以后终止行为。\nimport {interval} from \"rxjs\" import {first} from \"rxjs/operators\" interval(1000) .pipe(first()) .subscribe(n =\u003e console.log(n)) interval(1000) .pipe(first(n =\u003e n === 3)) .subscribe(n =\u003e console.log(n)) last 获取数据流中的最后一个。不可以用于不会终止的流。\nimport {range} from \"rxjs\" import {last} from \"rxjs/operators\" range(1, 10).pipe(last()).subscribe(console.log) // 10 如果数据源不变成完成状态，则没有最后一个。\nimport {interval} from \"rxjs\" import {last} from \"rxjs/operators\" interval(1000).pipe(last()).subscribe(console.log) // 不会有输出，程序会 hang 住 take、takeWhile、takeUtil、takeLast take：获取数据流中的前几个\nimport { range } from \"rxjs\" import { take } from \"rxjs/operators\" range(1, 10).pipe(take(3)).subscribe(console.log) // 1 // 2 // 3 takeWhile：只要数据源发出的值满足 takeWhile 中的条件，就发出该值，一旦不满足，就结束发射。\nimport {range} from \"rxjs\" import {takeWhile} from \"rxjs/operators\" range(1, 10) .pipe(takeWhile(n =\u003e n \u003c 5)) .subscribe(console.log) // 1 // 2 // 3 // 4 takeUntil：接收一个可观察对象，当接收的可观察对象发出值时，终止主数据源。\nimport {interval, timer} from \"rxjs\" import {takeUntil} from \"rxjs/operators\" interval(1000) .pipe(takeUntil(timer(5000))) .subscribe(console.log) // 0 // 1 // 2 // 3 takeLast：获取数据流中最后的一个值，takeLast 会将值缓存在内存中，等到流结束时取最后的值。\n它不可以用于不会终止的流，在无尽的流上使用 takeLast 永远不会发出数据。\nrange(1, 100).pipe(takeLast(3)).subscribe(x =\u003e console.log(x)); skip、skipWhile、skipUntil、skipLast skip：跳过前几个数据流。\nimport {range} from \"rxjs\" import {skip} from \"rxjs/operators\" range(1, 10).pipe(skip(8)).subscribe(console.log) // 9 // 10 skipWhile：只要数据源发出的值满足 skipWhile 中的条件，就跳过该值。\nimport {range} from \"rxjs\" import {skipWhile} from \"rxjs/operators\" range(1, 10) .pipe(skipWhile(n =\u003e n \u003c 5)) .subscribe(console.log) // 5 // 6 // 7 // 8 // 9 // 10 skipUntil：接收一个可观察对象，并跳过主数据源发出的值，直到接收的可观察对象发出值，主数据源的值才能发出。\nimport {timer, interval} from \"rxjs\" import {skipUntil} from \"rxjs/operators\" interval(500) .pipe(skipUntil(timer(2000))) .subscribe(console.log) // 3 // 4 // 5 // ... skipLast：跳过后面几个值，它的实现和 takeLast 类似，当数据发送完成后跳过最后的值发出其他的值。不可以用于不会终止的流。\nof(1, 2, 3, 4, 5).pipe(skipLast(2)).subscribe(x =\u003e console.log(x)); // 1 // 2 // 3 elementAt elementAt 类似数组的下标索引，获取源 Observable 中指定索引位置的元素。\nelementAt(index, [defaultValue]) 接受两个参数：\nindex: 要获取的元素的索引。 defaultValue（可选）：如果索引超出范围，可以指定一个默认值。在没有提供默认值时，默认行为是发出一个错误通知。 import { of } from 'rxjs'; import { elementAt } from 'rxjs/operators'; // 定义一个源 Observable 发出一些数字 const source$ = of(10, 20, 30, 40, 50); // 使用 elementAt 获取索引为 2 的元素（即第三个元素，值为 30） const element$ = source$.pipe( elementAt(2) ); // 订阅并打印输出 element$.subscribe({ next: value =\u003e console.log(value), error: err =\u003e console.error(err) }); // 30 ignoreElements 忽略源 Observable 发出的所有值，只传递异常和结束信息，可以用于不关注数据只关注异常的场景。\nimport { of } from 'rxjs'; import { ignoreElements } from 'rxjs/operators'; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4, 5); // 使用 ignoreElements 操作符 const ignored$ = source$.pipe( ignoreElements() ); // 订阅并打印输出 ignored$.subscribe({ next: value =\u003e console.log('Next:', value), // 不会打印任何值 error: err =\u003e console.error('Error:', err), // 如果有错误会打印 complete: () =\u003e console.log('Completed!') // 会打印 \"Completed!\" }); // Completed! debounceTime 常用于处理输入框等需要等待用户停止输入的场景。debounceTime 会延迟发出值，直到观察源 Observable 发出新的值后经过指定的时间，只有在这段时间内没有其他值发出时，它才会发出最新的值。\nimport { fromEvent } from \"rxjs\" import { debounceTime } from \"rxjs/operators\" fromEvent(document, \"click\") .pipe(debounceTime(1000)) .subscribe(x =\u003e console.log(x)) distinctUntilChanged 用于过滤重复值。它会比较相邻的值，如果当前的值与上一个值不同，则允许这个值通过，否则会被忽略。\nimport { of } from \"rxjs\" import { distinctUntilChanged } from \"rxjs/operators\" of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4) .pipe(distinctUntilChanged()) .subscribe(x =\u003e console.log(x)) // 1, 2, 1, 2, 3, 4 自定义的比较函数 import { of } from 'rxjs'; import { distinctUntilChanged } from 'rxjs/operators'; const source$ = of( { id: 1, name: 'John' }, { id: 1, name: 'John' }, { id: 2, name: 'Alice' }, { id: 2, name: 'Alice' }, { id: 3, name: 'Bob' } ); source$.pipe( distinctUntilChanged((prev, curr) =\u003e prev.id === curr.id) // 自定义比较逻辑，比较 id 字段 ).subscribe(value =\u003e { console.log(value); }); throttleTime 节流，它能够控制源 Observable 发出的值的频率。throttleTime 会在指定的时间间隔内只允许第一次发出的值通过，其他值会被丢弃，直到这个时间间隔过去，才允许下一个值通过。\nimport { interval } from 'rxjs'; import { throttleTime } from 'rxjs/operators'; const source$ = interval(100); // 每 100ms 发出一个数值 source$.pipe( throttleTime(500) // 只允许每 500ms 发出一个值 ).subscribe(value =\u003e { console.log(value); }); // 0 // 5 // 10 // 15 // ... throttleTime 与 debounceTime 的区别 throttleTime：每个时间窗口内发出第一个值，之后的值会被丢弃，直到时间窗口结束。 debounceTime：在时间间隔结束之前，所有的值都会被丢弃，只有最后一个值会被发出。 连接操作符 startWith 创建一个新的 Observable 对象并将参数值发送出去，然后再发送源 Observable 对象发出的值。\n在异步编程中提供默认值的时候非常有用。将 startWith 发出的值当做默认值。\nimport {interval} from \"rxjs\" import {map, startWith} from \"rxjs/operators\" interval(1000) .pipe( map(n =\u003e n + 100), startWith(505) ) .subscribe(n =\u003e console.log(n)) // 505 // 100 // 101 // 102 // ... withLatestFrom withLatestFrom 适用于：\n你需要从另一个流（可能是一个状态流）获取最新的数据，并将其与源 Observable 的当前数据结合处理。 用于处理那些只关心最新状态的情况，而不需要每次都处理整个流的每个值。 将点击事件与最新的计数结合：\nimport { fromEvent, interval } from 'rxjs'; import { withLatestFrom, map } from 'rxjs/operators'; const button = document.getElementById('button'); const counter$ = interval(1000); // 每 1000 毫秒发出一个递增的计数值 fromEvent(button, 'click').pipe( withLatestFrom(counter$), // 将点击事件与当前计数值结合 map(([clickEvent, counterValue]) =\u003e `Button clicked! Current counter: ${counterValue}`) ).subscribe(console.log); // Button clicked! Current counter: 2 // Button clicked! Current counter: 3 // Button clicked! Current counter: 4 // ... 工具操作符 tap tap 用来查看 Observable 流中的数据，同时不会对数据流产生任何影响。通常用来打印日志。\nimport {of, tap, map} from 'rxjs'; of(Math.random()).pipe( tap(console.log), map(n =\u003e n \u003e 0.5 ? 'big' : 'small') ).subscribe(console.log); import { of } from 'rxjs'; import { tap, map } from 'rxjs/operators'; const source = of(1, 2, 3, 4, 5); const example = source .pipe( map(val =\u003e val + 10), tap({ next: val =\u003e { console.log('on next', val); }, error: error =\u003e { console.log('on error', error.message); }, complete: () =\u003e console.log('on complete') }) ) .subscribe(val =\u003e console.log(val)); // 输出： // on next 11 // 11 // on next 12 // 12 // on next 13 // 13 // on next 14 // 14 // on next 15 // 15 // on complete delay、delayWhen delay：对 Observable 发出的值延迟指定的时间，只执行一次。\nimport {interval, take} from \"rxjs\" import {delay} from \"rxjs/operators\" const start = new Date(); interval(500) .pipe( take(5), delay(3000) ) .subscribe((v) =\u003e { console.log('val', v); console.log(new Date() - start); }) // 3500ms 之后发出值，接下来每 500ms 发出一个值 delayWhen：将源 Observable 发出的值延迟一段时间，这个延迟时间由另一个 Observable 来决定。源 Observable 发出多少值，传入的回调函数就会执行多少次。\nimport { of, timer } from 'rxjs'; import { delayWhen } from 'rxjs/operators'; // 定义一个源 Observable 发出一些数字 const source$ = of(1, 2, 3, 4); const delayed$ = source$.pipe( delayWhen(value =\u003e { // 根据每个值决定延迟的时间 // 比如这里是每个值的延迟时间都基于 1000ms + 当前数字 * 500ms return timer(1000 + value * 500); }) ); // 订阅并打印输出 delayed$.subscribe(console.log); every every 操作符用于判断源 Observable 发出的每个值是否都符合某个条件。返回布尔值。类似数组的 every 方法。\nimport { range } from \"rxjs\" import { every, map } from \"rxjs/operators\" range(1, 9) .pipe( every(n =\u003e n \u003e 5) ) .subscribe(console.log) // false，因为源 Observable 发出的值只有 6，7，8，9 大于 5 range(1, 9) .pipe( every(n =\u003e n \u003e 0) ) .subscribe(console.log) // true 错误处理 catchError catchError 用于捕获 Observable 流中的错误，并返回一个新的 Observable 来替代原来的错误流。这个操作符允许你处理错误并继续执行流，而不是直接终止整个 Observable。\nimport { of, throwError } from 'rxjs'; import { catchError } from 'rxjs/operators'; // 模拟一个会抛出错误的 Observable const source$ = throwError(() =\u003e new Error('Something went wrong!')); // 使用 catchError 捕获错误并返回替代的 Observable const result$ = source$.pipe( catchError(err =\u003e { console.error('Caught error:', err.message); return of('Fallback value'); // 重新抛出一个新的错误 // return throwError(() =\u003e new Error('Re-thrown error')); }) ); // 订阅并打印输出 result$.subscribe({ next: value =\u003e console.log(value), error: err =\u003e console.error('Final error:', err), complete: () =\u003e console.log('Completed!') }); // Caught error: Something went wrong! // Fallback value // Completed! retry retry 操作符用于自动重新订阅源 Observable，并重试失败的操作。当源 Observable 发出错误通知时，retry 会尝试重新发起新的订阅，直到达到指定的重试次数为止。如果重试次数超过了指定次数，则会将错误传递给观察者。\nimport { of, throwError } from 'rxjs'; import { retry } from 'rxjs/operators'; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u003e new Error('Something went wrong!')); // 使用 retry 操作符，最多重试 3 次 const retried$ = source$.pipe( retry(3) // 重试 3 次 ); // 订阅并打印输出 retried$.subscribe({ next: value =\u003e console.log(value), error: err =\u003e console.error('Error:', err.message), // 在尝试了 3 次后，错误通知会被最终发出 complete: () =\u003e console.log('Completed!') }); // Error: Something went wrong! 如果 count 参数未指定，retry 会无限次重试，直到成功或手动取消订阅。\n重试指定条件的错误：\nretryWhen 操作符已被弃用，使用 retry({ delay: () =\u003e notify$ }) 来替代 retryWhen(() =\u003e notify$)。\n通过传递一个带有 delay 选项的对象给 retry，来控制每次重试之间的延迟时间。\ndelay：可以是一个数字，表示延迟时间。 delay：可以是一个函数 delay: () =\u003e notify$，返回一个 Observable。每次重试之前会等待 notify$ 发出的值。 import { of, throwError, timer } from 'rxjs'; import { retry } from 'rxjs/operators'; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u003e new Error('Network Error')); // 定义一个控制延迟的 Observable const notify$ = timer(1000); // 每次重试之前等待 1 秒 // 使用 retry 操作符并指定 delay 属性 const retried$ = source$.pipe( retry({ count: 3, delay: () =\u003e notify$ // 每次重试之间延迟 1 秒 }) ); // 订阅并打印输出 retried$.subscribe({ next: value =\u003e console.log(value), error: err =\u003e console.error('Error:', err.message), complete: () =\u003e console.log('Completed!') }); // Error: Network Error 动态延迟，指数退避：\nimport { of, throwError, timer } from 'rxjs'; import { retry } from 'rxjs/operators'; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u003e new Error('Network Error')); // 动态计算每次重试的延迟：指数退避（Exponential Backoff） const retryDelay = (attempt: number) =\u003e timer(Math.pow(2, attempt) * 1000); // 每次重试间隔 2^attempt 秒 // 使用 retry 操作符并指定延迟策略 const retried$ = source$.pipe( retry({ count: 3, delay: (error, attempt) =\u003e retryDelay(attempt) // 基于尝试次数来计算延迟 }) ); // 订阅并打印输出 retried$.subscribe({ next: value =\u003e console.log(value), error: err =\u003e console.error('Error:', err.message), complete: () =\u003e console.log('Completed!') }); // Error: Network Error 根据不同错误类型重试：\nimport { of, throwError, timer } from 'rxjs'; import { retry, delay } from 'rxjs/operators'; // 模拟一个会发出错误的 Observable const source$ = throwError(() =\u003e new Error('Network Error')); // 条件重试 const retryDelay = (err: any) =\u003e { if (err.message === 'Network Error') { // 如果是网络错误，延迟 1 秒 console.log('Network Error: Retrying...'); return of(err).pipe(delay(1000)); } else if (err.message === 'Timeout Error') { // 如果是超时错误，延迟 2 秒 console.log('Timeout Error: Retrying...'); return of(err).pipe(delay(2000)); } else { // 其他错误直接抛出 return throwError(() =\u003e err); } } // 使用 retry 操作符并指定 delay 属性 const retried$ = source$.pipe( retry({ count: 3, delay: (error, attempt) =\u003e retryDelay(error) }) ); // 订阅并打印输出 retried$.subscribe({ next: value =\u003e console.log(value), error: err =\u003e console.error('Error:', err.message), complete: () =\u003e console.log('Completed!') }); 高阶操作符 所谓的高阶操作符（Higher Order Observable）就是指一个 Observable 发送出的值还是一个 Observable。\nconcatAll、concatMap concatAll：用于将一个包含多个内部 Observables 的高阶 Observable（即 Observable 的 Observable）“展平”（flatten）为一个单一的 Observable，并按顺序依次合并这些内部 Observables。\nconcatAll 确保它按顺序执行每个内部 Observable，前一个 Observable 完成后才会处理下一个。 import { of } from 'rxjs'; import { concatAll } from 'rxjs/operators'; // 创建多个内部 Observables const source$ = of( of('A', 'B', 'C'), of('D', 'E'), of('F', 'G') ); // 使用 concatAll 将其展平为一个流 const result$ = source$.pipe(concatAll()); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // A // B // C // D // E // F // G 处理异步：\nimport { of, timer } from 'rxjs'; import { concatAll, map } from 'rxjs/operators'; // 模拟异步操作（例如：HTTP 请求） const simulateHttpRequest = (id) =\u003e { return timer(1000 * id).pipe(map(() =\u003e `Request ${id} completed`)); }; // 创建一个包含多个 HTTP 请求的 Observable const source$ = of(1, 2, 3).pipe( map(id =\u003e simulateHttpRequest(id)) // 为每个请求返回一个内部 Observable ); // 使用 concatAll 依次处理这些 HTTP 请求 const result$ = source$.pipe(concatAll()); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // Request 1 completed // Request 2 completed // Request 3 completed concatMap：用于将源 Observable 发出的每个值映射为一个内部 Observable，并按顺序依次处理这些内部 Observables。\n每次只会处理一个内部 Observable，前一个 Observable 完成后才会处理下一个。 保证了顺序，不会并发执行内部 Observables。 import { of, timer } from 'rxjs'; import { concatMap, map } from 'rxjs/operators'; // 模拟异步操作（例如 HTTP 请求） const simulateHttpRequest = (id) =\u003e { return timer(1000 * id).pipe(map(() =\u003e `Request ${id} completed`)); }; // 创建一个 Observable 发出请求 ID const source$ = of(1, 2, 3); // 使用 concatMap 按顺序执行 HTTP 请求 const result$ = source$.pipe( concatMap(id =\u003e simulateHttpRequest(id)) ); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // Request 1 completed // Request 2 completed // Request 3 completed mergeAll、mergeMap mergeAll：用于将高阶 Observable（即一个发出多个内部 Observable 的 Observable）展平（flatten），并将所有内部 Observable 合并为一个单一的输出流。\nmergeAll 会立即订阅所有内部 Observable，然后并发地发出它们的值，而不会按顺序等待每个内部 Observable 完成。 mergeAll(concurrent: number = Infinity) 有一个可选参数 concurrent 可以用来控制并发数量。\nimport { of } from 'rxjs'; import { mergeAll } from 'rxjs/operators'; // 创建一个包含多个内部 Observables 的高阶 Observable const source$ = of( of('A', 'B', 'C'), of('D', 'E'), of('F', 'G') ); // 使用 mergeAll 将这些内部 Observables 合并为一个单一的流 const result$ = source$.pipe(mergeAll()); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // A // B // C // D // E // F // G mergeMap：允许将源 Observable 发出的每一个值映射为一个内部 Observable（或称为“内部流”），并将这些内部 Observable 合并到一个单一的输出流中。\n不同于 concatMap，mergeMap 会并发地处理多个内部 Observable，并不会等待前一个内部 Observable 完成后再处理下一个。 mergeMap(project: (value: T) =\u003e ObservableInput, concurrent: number = Infinity)，接受两个参数\nproject：一个函数，接收源 Observable 发出的每个值，并返回一个内部 Observable（或其他类型的值）。这个内部 Observable 会被合并到输出流中。 concurrent（可选）：指定最多可以同时订阅多少个内部 Observable，默认为 Infinity，表示无限制并发。 import { of } from 'rxjs'; import { mergeMap, delay } from 'rxjs/operators'; // 模拟异步操作 const simulateAsyncTask = (value) =\u003e { return of(`Task ${value} completed`).pipe(delay(1000 * value)); // 延时模拟异步操作 }; // 创建一个源 Observable const source$ = of(1, 2, 3); // 使用 mergeMap 来并发处理多个异步任务 // 任务 Task 1, Task 2, 和 Task 3 会同时开始处理 const result$ = source$.pipe( mergeMap(value =\u003e simulateAsyncTask(value)) ); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // Task 1 completed // Task 2 completed // Task 3 completed 限制并发数量：\nimport { of } from 'rxjs'; import { mergeMap, delay } from 'rxjs/operators'; // 模拟异步操作 const simulateAsyncTask = (value) =\u003e { return of(`Task ${value} completed`).pipe(delay(1000 * value)); // 延时模拟异步操作 }; // 创建一个源 Observable const source$ = of(1, 2, 3, 4, 5); // 使用 mergeMap 并限制并发数为 2 const result$ = source$.pipe( mergeMap(value =\u003e simulateAsyncTask(value), 2) // 这里限制并发数为 2 ); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // Task 1 completed // Task 2 completed // Task 3 completed // Task 4 completed // Task 5 completed switchMap 用于将源 Observable 发出的每个值映射为一个新的 Observable，并且在接收到新的值时，取消订阅当前的内部 Observable，并订阅新的内部 Observable。\n这意味着只有最后一个内部 Observable 的值会被发出，其它之前的内部 Observable 会被自动取消订阅。\nimport { fromEvent, fromPromise } from 'rxjs'; import { switchMap, debounceTime, map } from 'rxjs/operators'; // 模拟网络请求 const fakeApiRequest = (query) =\u003e { return new Promise((resolve) =\u003e { setTimeout(() =\u003e resolve(`Result for: ${query}`), 1000); }); }; // 获取搜索框元素 const searchInput = document.getElementById('search'); // 用户输入事件流 const search$ = fromEvent(searchInput, 'input').pipe( map(event =\u003e event.target.value), // 提取输入的值 debounceTime(300), // 防抖，避免每次输入都发出请求 switchMap(query =\u003e { if (query) { return fromPromise(fakeApiRequest(query)); // 返回一个新的 Observable } else { return of(''); // 如果没有输入，返回一个空字符串 } }) ); // 订阅并打印搜索结果 search$.subscribe(result =\u003e console.log(result)); fakeApiRequest(query) 模拟一个异步请求，switchMap 会发出该请求，并在新的输入发生时取消之前的请求。\nexhaustAll, exhaustMap exhaustMap：映射源 Observable 发出的每个值为一个内部 Observable，并且忽略在内部 Observable 完成之前发出的所有新值。\nexhaustMap 会等待当前的内部 Observable 完成。 在当前的内部 Observable 执行期间，任何新的源值都会被忽略。 只有在内部 Observable 完成后，才会处理源 Observable 中的下一个值。 这种行为通常用于限制并发任务的数量，尤其是在处理需要等待的异步操作时，例如避免用户频繁点击按钮触发多个请求。\nimport { fromEvent } from 'rxjs'; import { exhaustMap, map, debounceTime } from 'rxjs/operators'; // 模拟异步搜索请求 const simulateSearchRequest = (query) =\u003e { console.log(`Searching for: ${query}`); return new Promise(resolve =\u003e { setTimeout(() =\u003e { resolve(`Search results for: ${query}`); }, 1500); // 模拟请求延时 }); }; // 获取搜索框元素 const searchInput = document.getElementById('searchBox'); // 用户输入事件流 const search$ = fromEvent(searchInput, 'input').pipe( debounceTime(500), // 防抖，避免每次输入都发出请求 map(event =\u003e event.target.value), // 提取输入的值 exhaustMap(query =\u003e { if (query) { return from(simulateSearchRequest(query)); // 返回一个新的 Observable } else { return of(''); // 如果没有输入，返回空字符串 } }) ); // 订阅并打印搜索结果 search$.subscribe(result =\u003e console.log(result)); exhaustMap 会确保每次用户输入时只处理最后一次的请求，而忽略在请求进行中产生的其他输入。\nexhaustAll：类似于 exhaustMap，但它的用途稍有不同。exhaustAll 用于将源 Observable 发出的每个值（这些值本身通常是 Observable）转换为内部 Observable，并且在当前内部 Observable 完成之前，会忽略所有新的值，直到当前内部 Observable 完成。\nexhaustAll 监听源 Observable 中发出的每个值，这些值通常是 Observable。 当源 Observable 发出一个新的 Observable 时，exhaustAll 会订阅该内部 Observable。 如果当前的内部 Observable 还没有完成，exhaustAll 会忽略源 Observable 发出的所有后续值，直到当前的内部 Observable 完成。 一旦当前的内部 Observable 完成，exhaustAll 会继续处理源 Observable 中的下一个值（如果存在）。 import { of, interval } from 'rxjs'; import { exhaustAll, map, take } from 'rxjs/operators'; // 模拟内部 Observable（例如 HTTP 请求） const simulateAsyncTask = (id) =\u003e { return of(`Request ${id} completed`).pipe( // 模拟任务延迟 map(val =\u003e val), take(1) // 模拟每个请求只会发出一个值，然后完成 ); }; // 创建一个源 Observable，发出多个 Observable const source$ = of( simulateAsyncTask(1), simulateAsyncTask(2), simulateAsyncTask(3), simulateAsyncTask(4) ); // 使用 exhaustAll 来处理内部 Observable const result$ = source$.pipe( exhaustAll() // 忽略当前任务未完成时的其他任务 ); // 订阅并打印输出 result$.subscribe(value =\u003e console.log(value)); // Request 1 completed // Request 2 completed // Request 3 completed // Request 4 completed ","创建操作符#创建操作符":"range range(start, length)，调用方法后返回 Observable 对象，被订阅后会发出指定范围的数值。\nimport { range } from \"rxjs\" range(0, 5).subscribe(n =\u003e console.log(n)) // Output: // 0 // 1 // 2 // 3 // 4 of 将参数列表作为数据流返回。\nof(\"a\", \"b\", [], {}, true, 20).subscribe(v =\u003e console.log(v)) // Output: // a // b // [] // {｝ // true // 20 from, fromEvent, fromPromise // 将数组转为 Observable from([\"a\", \"b\", \"c\"]).subscribe(v =\u003e console.log(v)) // Output: // a // b // c // 将事件转为 Observable fromEvent(document.querySelector('button'), 'click'); // 将 Promise 转为 Observable function p() { return new Promise(function (resolve) { resolve([100, 200]) }) } fromPromise(p()).subscribe(v =\u003e console.log(v)) // Output: // [100, 200] fromPromise(fetch('/users')); interval、timer interval每隔一段时间发出一个数值，数值递增。\nimport {interval, take} from 'rxjs'; const numbers = interval(1000); const takeFourNumbers = numbers.pipe(take(4)); takeFourNumbers.subscribe(x =\u003e console.log('Next: ', x)); // Output: // Next: 0 // Next: 1 // Next: 2 // Next: 3 timer间隔时间过去以后发出数值，行为终止，或间隔时间发出数值后，继续按第二个参数的时间间隔继续发出值\nimport { timer } from \"rxjs\" timer(2000).subscribe(n =\u003e console.log(n)) timer(0, 1000).subscribe(n =\u003e console.log(n)) concat 合并数据流，先让第一个数据流发出值，结束后再让第二个数据流发出值，进行整体合并。\nimport {interval, take, range, concat} from 'rxjs'; const timer = interval(1000).pipe(take(4), map(x =\u003e `${x}s`)); const sequence = range(1, 10); const result = concat(timer, sequence); result.subscribe(x =\u003e console.log(x)); // Output: // 0s-\u003e 1s-\u003e 2s -\u003e 3s -\u003e 1 -\u003e 2 ... -\u003e 10 const timer = interval(1000).pipe(take(2)); concat(timer, timer) // concatenating the same Observable! .subscribe({ next: value =\u003e console.log(value), complete: () =\u003e console.log('...and it is done!') }); // Logs: // 0 after 1s // 1 after 2s // 0 after 3s // 1 after 4s // '...and it is done!' also after 4s merge 合并数据流，多个参数一起发出数据流，按照时间线进行交叉合并。\nimport {merge, interval, take, map} from \"rxjs\"; const timer = interval(1000).pipe(take(3), map(v =\u003e 'timer1: ' + v + 's')); const timer2 = interval(1000).pipe(take(3), map(v =\u003e 'timer2: ' + v + 's')); merge(timer, timer2).subscribe(console.log); // Output: // timer1: 0s // timer2: 0s // timer1: 1s // timer2: 1s // timer1: 2s // timer2: 2s combineLatest 将两个 Observable 中最新发出的数据流进行组合成新的数据流，其值由每个输入观测值的最新值计算得出。\nimport { combineLatest, timer } from \"rxjs\" const firstTimer = timer(0, 1000) // emit 0, 1, 2... after every second, starting from now const secondTimer = timer(500, 1000) // emit 0, 1, 2... after every second, starting 0,5s from now combineLatest(firstTimer, secondTimer).subscribe(console.log) // Output: // [0, 0] after 0.5s // [1, 0] after 1s // [1, 1] after 1.5s // [2, 1] after 2s 传入字典参数：\nimport { of, delay, startWith, combineLatest } from 'rxjs'; const observables = { a: of(1).pipe(delay(1000), startWith(0)), b: of(5).pipe(delay(5000), startWith(0)), c: of(10).pipe(delay(10000), startWith(0)) }; const combined = combineLatest(observables); combined.subscribe(value =\u003e console.log(value)); // Output: // { a: 0, b: 0, c: 0 } immediately // { a: 1, b: 0, c: 0 } after 1s // { a: 1, b: 5, c: 0 } after 5s // { a: 1, b: 5, c: 10 } after 10s zip 将多个 Observable 中的数据流进行组合。其值按顺序从每个输入 Observable 的值中计算得出。\nimport { zip, of } from \"rxjs\" import { map } from \"rxjs/operators\" let age = of(27, 25, 29) let name = of(\"Foo\", \"Bar\", \"Beer\") let isDev = of(true, true, false) zip(name, age, isDev) .pipe(map(([name, age, isDev]) =\u003e ({ name, age, isDev }))) .subscribe(console.log) // { name: 'Foo', age: 27, isDev: true } // { name: 'Bar', age: 25, isDev: true } // { name: 'Beer', age: 29, isDev: false } forkJoin forkJoin 是 RxJS 版本的 Promise.all()，即表示等到所有的 Observable 都完成后，才一次性返回值。\n传入字典参数：\nimport {forkJoin, of, timer} from 'rxjs'; const observable = forkJoin({ foo: of(1, 2, 3, 4), bar: Promise.resolve(8), baz: timer(4000) }); observable.subscribe({ next: value =\u003e console.log(value), complete: () =\u003e console.log('This is how it ends!'), }); // Logs: // { foo: 4, bar: 8, baz: 0 } after 4 seconds // 'This is how it ends!' immediately after 传入数组参数：\nconst observable = forkJoin([ of(1, 2, 3, 4), Promise.resolve(8), timer(4000) ]); observable.subscribe({ next: value =\u003e console.log(value), complete: () =\u003e console.log('This is how it ends!'), }); // Logs: // [4, 8, 0] after 4 seconds // 'This is how it ends!' immediately after ℹ️ forkJoin 是用于等待多个 Observable 完成，并且只会在所有 Observable 都完成后发出最后的值。意味着有一些操作符是不可以 和 forkJoin 一起使用。\n例如 fromEvent，它返回的是一个 Observable，该对象会持续监听某个事件（例如鼠标点击、键盘输入等），也就是说 fromEvent 是不会“完成”的，所以 forkJoin 永远不会触发。\nthrowError 返回可观察对象并向订阅者抛出错误。\nimport { throwError } from \"rxjs\" throwError(\"unknown error\").subscribe({ error: console.log }) race 接收并同时执行多个可观察对象，只将最快发出的数据流传递给订阅者。\nimport {interval, map, race} from 'rxjs'; const obs1 = interval(7000).pipe(map(() =\u003e 'slow one')); const obs2 = interval(3000).pipe(map(() =\u003e 'fast one')); const obs3 = interval(5000).pipe(map(() =\u003e 'medium one')); race(obs1, obs2, obs3) .subscribe(winner =\u003e console.log(winner)); // Outputs // a series of 'fast one' "},"title":"操作符"},"/frontend-learn/docs/framework/rxjs/03_subject/":{"data":{"":"RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，这意味着 Subject 确保每个观察者之间共享 Observable 的值。\n而普通的 Observable 是单播的，它会为每一个观察者创建一次新的、独立的执行。当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。\n在 RxJS 中有四种 Subject 分别是：Subject，BehaviorSubject，AsyncSubject，ReplaySubject；这四种 Subject 都是特殊的 Observable。\nSubject 既是 Observable 也是 Observer。","subject#Subject":"Subject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，它会把订阅者添加到观察者列表中，每当有接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next 方法，把值一一送出。\nimport { Subject } from 'rxjs'; const subject$ = new Subject\u003cnumber\u003e(); subject$.next(1); subject$.subscribe({ next: (v) =\u003e console.log(`observerA: ${v}`), }); subject$.next(2); subject$.subscribe({ next: (v) =\u003e console.log(`observerB: ${v}`), }); subject$.next(3); // Output: // observerA: 2 // observerA: 3 // observerB: 3 创建了一个 Subject 发出了一个值 1，但由于此时并没有订阅者，所以这个值不会被订阅到 创建了 observerA 又发出一个值 2，这时候 observerA 会接收到这个值 又创建一个 observerB 最后发出一个值 3，这时候已经订阅的都会接收到这个值 BehaviorSubject BehaviorSubject，它有一个当前值的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到最后发出的值。\n在定义一个 BehaviorSubject 时需要有初始值。\nimport { BehaviorSubject } from 'rxjs'; const behavior$ = new BehaviorSubject(0); // 0 is the initial value behavior$.subscribe({ next: (v) =\u003e console.log(`observerA: ${v}`), }); behavior$.next(1); behavior$.subscribe({ next: (v) =\u003e console.log(`observerB: ${v}`), }); behavior$.next(2); // Output: // observerA: 0 // observerA: 1 // observerB: 1 // observerA: 2 // observerB: 2 创建了一个 BehaviorSubject 的实例 behavior$，初始值为 0。 然后订阅了这个 behavior$，由于 BehaviorSubject 的特点是把最新的值发布给订阅者，observerA 会得到初始值 0，所以会输出 observerA: 0 behavior$ 发出一个新的值 1，这时候 observerA 将会收到新的值，输出 observerA: 1 增加一个订阅者 observerB，这时候它会得到最新的值 1，所以输出 observerB: 1， 最后再一次发出一个新的值 2，这个时候有两个订阅者 observerA 和 observerB，它们都会接收到新的值 2，所以会输出 observerA: 2 和 observerB: 2 ReplaySubject ReplaySubject 有点像 BehaviorSubject，区别是不仅是当前值，之前的旧值也可以发送给新的订阅者。ReplaySubject 会记录多个值，并重放给新的订阅者。\n它的第一个参数 bufferSize 指定了缓存的大小，默认为 Infinity，即缓存所有发出的值。还可以向其传递第二个参数 windowTime，指定缓存的时间限制，默认为 Infinity，即不限制值的失效时间。\nimport { ReplaySubject } from 'rxjs'; const replay$ = new ReplaySubject(2); // buffer 2 values for new subscribers replay$.subscribe({ next: (v) =\u003e console.log(`observerA: ${v}`), }); replay$.next(1); replay$.next(2); replay$.next(3); replay$.subscribe({ next: (v) =\u003e console.log(`observerB: ${v}`), }); replay$.next(4); // Output: // observerA: 1 // observerA: 2 // observerA: 3 // observerB: 2 // observerB: 3 // observerA: 4 // observerB: 4 创建了一个 ReplaySubject 的实例 replay$，并设置缓存为 2. 创建了一个订阅者 observerA 调用三次的 next 方法，把值发布给订阅者。这时订阅者 observerA 会输出三次 创建一个新的订阅者 observerB，由于 ReplaySubject 缓存了两个值，因此它将直接向订阅者 observerB 发出这两个值，订阅者 observerB 打印这两个值。 发出另外一个值 4，这时候 observerA 和 observerB 都接收到值的改变，分别打印这个值。 指定一个以毫秒为单位的窗口时间，示例：\nimport { ReplaySubject } from 'rxjs'; const replay$ = new ReplaySubject(2, 100 /* windowTime 100ms */); replay$.subscribe({ next: (v) =\u003e console.log(`observerA: ${v}`), }); let i = 1; setInterval(() =\u003e replay$.next(i++), 200); setTimeout(() =\u003e { replay$.subscribe({ next: (v) =\u003e console.log(`observerB: ${v}`), }); }, 1000); // Output: // observerA: 0 // observerA: 1 // observerA: 2 // observerA: 3 // observerA: 4 // observerB: 4 // observerA: 5 // observerB: 5 // ... 创建 ReplaySubject并设置缓存为 2，缓存时间不超过 100ms 创建一个 observerA 每 200ms 发出一个新的值。observerA 会接收到发出的所有值 创建一个 observerB，由于是在 1000ms 后进行订阅。这意味着在开始订阅之前，replay$ 已经发出了 5 个值。在创建 ReplaySubject 时，指定最多存储 2 个值，并且不能超过 100ms。这意味着在 1000ms 后，observerB 开始订阅时，由于 replay$ 是 200ms 发出一个值，因此 observerB 只会接收到 1 个值。 AsyncSubject 只有当 Observable 执行完成时(执行 complete())，它才会将执行的最后一个值发送给观察者。 类似 last() 操作符。\nimport { AsyncSubject } from 'rxjs'; const async$ = new AsyncSubject(); async$.subscribe({ next: (v) =\u003e console.log(`observerA: ${v}`), }); async$.next(1); async$.next(2); async$.subscribe({ next: (v) =\u003e console.log(`observerB: ${v}`), }); async$.next(3); async$.complete(); // Logs: // observerA: 3 // observerB: 3 创建 AsyncSubject 的实例 创建一个 observerA async$ 发出 2 个值，但是 observerA 不会有输出。 创建一个 observerB 发出新的值，但是 observerA 和 observerB 都不会有输出。 执行 complate 完成，这时候将最后一个值发送给所有订阅者 Void subject 有时，subject 的值并不重要，重要的是有一个事件被触发了。\n可以声明一个 void subject，表示这个值是不相关的。只有事件本身才是重要的。\nimport { Subject } from 'rxjs'; const subject = new Subject(); // Shorthand for Subject\u003cvoid\u003e subject.subscribe({ next: () =\u003e console.log('One second has passed'), }); setTimeout(() =\u003e subject.next(), 1000); "},"title":"Subject"},"/frontend-learn/docs/framework/rxjs/04_practice/":{"data":{"":"","优雅的资源释放#优雅的资源释放":"对于无限值必须要取消订阅，反之可以不需要。例如监听 DOM 元素的事件：\nObservable.fromEvent(node, 'input') .subscribe(value =\u003e { console.log(value); }); 因为如果不取消订阅，事件所关联的方法会一直被占用，导致内存泄露。\n传统方式 @Component({ selector: 'app-demo', template: ` \u003cdiv\u003eHello, world!\u003c/div\u003e ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = new Subject\u003cvoid\u003e(); private timer; constructor() { this.timer = interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } 上面的在组件中定义了一个私有变量 _destroy$，是一个 Subject 对象，用于在组件销毁时发出信号以释放资源。通过 takeUntil(this._destroy$) 操作符来限制 Observable 的生命周期，在 _destroy$ 发出信号时停止发出值。\n这种方式虽然使用了 takeUntil 来限制 Observable 的生命周期，但是仍然需要在 ngOnDestroy 钩子中手动调用 _destroy$.next() 和 _destroy$.complete() 来确保释放资源。容易遗漏而引发错误。\n继承方式 @Directive() export class BaseComponent implements OnDestroy { // protected, not private protected readonly _destroy$ = new Subject\u003cvoid\u003e(); ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } @Component({ selector: 'app-demo', template: ` \u003cdiv\u003eHello, world!\u003c/div\u003e ` }) export class GeneralComponent extends BaseComponent { constructor() { super(); interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } } 继承方式可以减少了在每个组件中手动管理资源释放的重复性工作。但是导致了派生组件与基类紧密耦合。一个派生类只能继承自一个基类。如果要在不同的组件中共享不同的基础逻辑，就会受到继承单一基类的限制。而且继承方式导致代码的可读性和可维护性下降。\nDestroyRef 机制 function destroyRefFactory() { const destroy$ = new Subject\u003cvoid\u003e(); const destroyRef = inject(DestroyRef); destroyRef.onDestroy(() =\u003e { destroy$.next(); destroy$.complete(); }) return destroy$; } @Component({ selector: 'app-demo', template: ` \u003cdiv\u003eHello, world!\u003c/div\u003e ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = destroyRefFactory(); constructor() { interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log) } } 基于 DestroyRef 机制，不需要在组件中手动释放资源。而且不仅限于单一订阅场景，它在多个订阅场景中同样适用。\n自定义操作符 基于 DestroyRef 机制的实现方式简洁灵活，但是仍然需要在组件中声明 _destroy$。通过自定义操作符可以将释放资源的逻辑封装在操作符内部，让代码更加整洁，使资源释放与业务逻辑解耦。\nfunction takeUntilDestroyed\u003cT\u003e(destroyRef?: DestroyRef): MonoTypeOperatorFunction\u003cT\u003e { if (!destroyRef) { destroyRef = inject(DestroyRef); } const destroy$ = new Observable\u003cvoid\u003e(observer =\u003e { return destroyRef!.onDestroy(() =\u003e { observer.next(); observer.complete(); }); }) return \u003cT\u003e(source: Observable\u003cT\u003e) =\u003e { return source.pipe(takeUntil(destroy$)) } } @Component({ selector: 'app-demo', template: ` \u003cdiv\u003eHello, world!\u003c/div\u003e ` }) export class GeneralComponent implements OnDestroy { constructor() { interval(1000).pipe(takeUntilDestroyed()).subscribe(console.log) } } @angular/core/rxjs-interop 中已经提供了 takeUntilDestroyed 操作符。"},"title":"实践"},"/frontend-learn/docs/framework/vue/basic/command/":{"data":{"vue-指令#Vue 指令":"Vue 指令前面我们知道了 Vue 中可以使用前缀是v-的指令。 简单的学习了v-bind和v-on，缩写是:和@，v-bind可以绑定html的属性，v-on用来监听事件， 使用v-html插入HTML，使用v-pre跳过元素和子元素的编译过程，可以显示双括号\n先来学习v-bind来绑定class和style，动态地切换 class 和 style。","其它指令#其它指令":"`v-cloak 这个指令不需要表达式，会在Vue 实例结束编译时从绑定的HTML 元素上移除，一般和 CSS 规则如 [v-cloak] { display: none } 一起使用时。 这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。\n\u003cdiv id=\"app\"\u003e \u003cspan v-cloak\u003e{{ message }}\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { message: \"Hello, Vue.\" } }); \u003c/script\u003e 上面的代码虽然加了v-cloak指令，但是当网速慢，vue问价文件未加载完成时，页面上还是会显示：\n{{ message }} 直到创建vue实例，编译模板时，才会替换DOM，所以这个过程页面会有闪动。解决这个问题只要加上：\n[v-cloak] { display: none } v-once 这个指令不需要表达式，作用是只渲染元素和组件一次。第一次渲染后，不会再随数据变化重新渲染。\n\u003cdiv id=\"app\"\u003e \u003cspan v-once\u003e{{ message }}\u003c/span\u003e \u003cdiv v-once\u003e \u003cspan\u003e{{message}}\u003c/span\u003e \u003c/div\u003e \u003cspan\u003e{{message}}\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { message: \"Hello, Vue.\" } }); setInterval(function () { app.message = \"hello\" },1000) \u003c/script\u003e 可用来优化性能。","列表渲染#列表渲染":"遍历数组 列表渲染指令v-for，它的表达式需结合in来使用，类似item in items的形式：\n\u003cdiv id=\"app\"\u003e \u003cul\u003e \u003cli v-for=\"phone in phones\"\u003e{{ phone.name }}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { phones: [ {name: \"iPhone X\"}, {name: \"iPhone 8p\"}, {name: \"iPhone 8\"}, {name: \"iPhone 7p\"}, {name: \"iPhone 7\"} ] } }); \u003c/script\u003e 列表渲染也可以用of替代in作为分隔符：\n\u003cli v-for=\"phone of phones\"\u003e{{ phone.name }}\u003c/li\u003e 遍历数组时，有一个可选参数index：\n\u003cli v-for=\"(phone, index) in phones\"\u003e{{index}} - {{ phone.name }}\u003c/li\u003e 遍历对象 v-for遍历一个对象：\n\u003cdiv id=\"app\"\u003e \u003cul\u003e \u003cli v-for=\"value in phone\"\u003e{{ value }}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { phone: { name: \"iPhone\", version: \"X\", price: \"9000\" } } }); \u003c/script\u003e 遍历对象属性时，有两个可选参数，分别是key和index：\n\u003cli v-for=\"(value, key, index) in phone\"\u003e{{ value }}\u003c/li\u003e key 和条件渲染v-if一样，v-for默认会复用已有元素，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key属性。 用v-bind来绑定动态值 ：\n\u003cdiv v-for=\"item in items\" :key=\"item.id\"\u003e \u003c!-- 内容 --\u003e \u003c/div\u003e 建议尽可能在使用v-for时提供key，除非遍历输出的 DOM 内容非常简单。\n数组更新 Vue的核心思想就是是数据与视图的双向绑定，当我们修改数组时，Vue 会检测到数据变化，所以用v-for渲染的视图也会立即更新。 Vue 包含了一组观察数组变异的方法，使用它们改变数组也会触发视图更新：\npush() pop() shift() unshift() splice() sort() reverse() 变异方法 (mutation method)，会改变被这些方法调用的原始数组。但是有些不会：\nfilter() concat() slice() 这些不会改变原始数组，总是返回一个新数组。当使用这些方法时，可以用新数组替换旧数组： \u003cdiv id=\"app\"\u003e \u003cul\u003e \u003cli v-for=\"phone in phones\"\u003e{{ phone.name }}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { phones: [ {name: \"iPhone X\"}, {name: \"iPhone 8p\"}, {name: \"iPhone 8\"}, {name: \"iPhone 7p\"}, {name: \"iPhone 7\"} ] } }); app.phones = app.phones.filter(function (item) { return item.name.includes(\"8\"); }); app.phones.push({name: \"HuaWei P20\"}); \u003c/script\u003e 以下变动的数组Vue 是检测不到的：\n通过索引直接设置：app.phones[10] = {name: \"HuaWei P20\"} 手动修改数组长度：app.phones.length = 2 解决第一个问题，有两种方式可以达到和app.phones[10] = {name: \"HuaWei P20\"}同样效果，同时也触发状态更新： 第一种方法：\nVue.set(vm.items, indexOfItem, newValue) Vue.set(app.phones, 10, {name: \"HuaWei P20\"}) webpack 中使用组件化的方式，默认是没有导入Vue 的,使用vm.$set实例方法，vm.$set其实是Vue.set的一个别名\nvm.$set(vm.items, indexOfItem, newValue) app.$set(app.phones, 10, {name: \"HuaWei P20\"}) 另一种方法：\napp.phones.splice(10, 1, {name: \"HuaWei P20\"}); 第二个问题也使用splice()解决：\napp.phones.splice(1); Vue 不能检测对象属性的添加或删除，例如：\nvar vm = new Vue({ data: { a: 1 } }) // `vm.a` 现在是响应式的 vm.b = 2 // `vm.b` 不是响应式的 解决方法：\nvar vm = new Vue({ data: { userProfile: { name: 'Anika' } } }) Vue.set(vm.userProfile, 'age', 27) //或者 vm.$set(vm.userProfile, 'age', 27) //如果要赋值多个新属性，使用Object.assign() 或 _.extend() //注意要创建一个新的空对象 vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: 'Vue Green' }) 排序和过滤 v-for \u0026 template v-for也可以和v-if一样应用在 \u003ctemplate\u003e上来渲染多个元素:\n\u003cul\u003e \u003ctemplate v-for=\"phone in phones\"\u003e \u003cli\u003e{{ phone.name }}\u003c/li\u003e \u003cli\u003e{{ phone.version }}\u003c/li\u003e \u003cli\u003e{{ phone.price }}\u003c/li\u003e \u003c/template\u003e \u003c/ul\u003e v-for \u0026 v-if 如果v-for和v-if在同一个节点上，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中。\n\u003cul\u003e \u003cli v-for=\"phone in phones\" v-if=\"phone.price \u003c 5000\"\u003e \u003c/li\u003e \u003c/ul\u003e 上面的代码就只会展示价格低于5000的phone。\n如果想要v-if优先级高于v-for只能把v-if放在v-for的外层元素：\n\u003cul v-if=\"phones.length \u003e 0\"\u003e \u003cli v-for=\"phone in phones\" v-if=\"phone.price \u003c 5000\"\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp v-else\u003eNo phones!\u003c/p\u003e ","总结#总结":" v-bind动态更新html元素上的属性。 v-bind绑定class和style，实现动态切换。可以绑定计算属性。 v-if,v-else-if,v-else,v-show，v-else元素必须紧跟在带v-if或者v-else-if的元素的后面，否则它将不会被识别。可以用到\u003ctemplate\u003e上。 Vue 为了提高渲染效率，通常会复用已有的元素，而不是重新渲染，但是如果想让 Vu e不复用它们。只需给元素添加一个具有唯一值的key属性 v-show只是简单地切换元素的CSS属性display。v-show表达式的值为true是就显示，false就隐藏。 v-show不能用到\u003ctemplate\u003e上，不会生效。 v-if的切换开销更大，v-show适合在切换频繁的场景使用。 建议尽可能在使用v-for时提供key，除非遍历输出的 DOM 内容非常简单。 Vue 包含了一组观察数组变异的方法，会改变被这些方法调用的原始数组。使用它们改变数组也会触发视图更新:push,pop,shift,unshift,splice,sort,reverse filter,concat,slice，这些不会改变原始数组，总是返回一个新数组，当使用这些方法时，可以用新数组替换旧数组。 Vue 检测不到的数组变动： 通过索引直接设置：app.phones[10] = {name: \"HuaWei P20\"} 手动修改数组长度：app.phones.length = 2 创建 vue 实例后，Vue 不能检测对象属性的添加或删除，使用vue.$set。 v-for也可以和v-if一样应用在\u003ctemplate\u003e上。 如果v-for和v-if在同一个节点上，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中。 v-cloak，v-once ","条件渲染#条件渲染":"v-if,v-else-if,v-else Vue 中条件渲染指令有v-if,v-else-if,v-else。和js中的if else条件语句差不多。条件渲染指令根据表达式的值，在DOM上渲染或者销毁元素：\n\u003cdiv id=\"app\"\u003e \u003cdiv v-if=\"status === 1\"\u003e \u003ch1\u003e条件渲染1\u003c/h1\u003e \u003ch2\u003e{{msg}}\u003c/h2\u003e \u003c/div\u003e \u003cdiv v-else-if=\"status === 2\"\u003e \u003ch1\u003e条件渲染2\u003c/h1\u003e \u003ch2\u003e{{msg}}\u003c/h2\u003e \u003c/div\u003e \u003cdiv v-else\u003e \u003ch1\u003e条件渲染3\u003c/h1\u003e \u003ch2\u003e{{msg}}\u003c/h2\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { status: 2, msg: \"hello, vue.\" } }); \u003c/script\u003e v-else元素必须紧跟在带v-if或者v-else-if的元素的后面，否则它将不会被识别。\n可以在Vue内置的\u003ctemplate\u003e 元素上使用v-if：\n\u003cdiv id=\"app\"\u003e \u003ctemplate v-if=\"ok\"\u003e \u003ch1\u003ev-if template\u003c/h1\u003e \u003cp\u003eHello, world\u003c/p\u003e \u003cp\u003eHello, vue\u003c/p\u003e \u003c/template\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { ok: true } }); \u003c/script\u003e Vue为了提高渲染效率，通常会复用已有的元素，而不是重新渲染：\n\u003cdiv id=\"app\"\u003e \u003ctemplate v-if=\"type === 'username'\"\u003e \u003clabel\u003eUsername\u003c/label\u003e \u003cinput placeholder=\"Enter your username\"\u003e \u003c/template\u003e \u003ctemplate v-else=\"type === 'email'\"\u003e \u003clabel\u003eEmail\u003c/label\u003e \u003cinput placeholder=\"Enter your email address\"\u003e \u003c/template\u003e \u003cbutton @click=\"toggleType\"\u003e切换登录类型\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { type: \"username\" }, methods: { toggleType: function () { this.type = this.type === \"username\" ? \"email\" : \"username\"; } } }); \u003c/script\u003e 那么在上面的代码中切换 type ，输入的内容没有改变，但是placeholder被替换了。说明input元素被复用了。 但是如果想让Vue不复用它们。只需添加一个具有唯一值的key属性：\n\u003cdiv id=\"app\"\u003e \u003ctemplate v-if=\"type === 'username'\"\u003e \u003clabel\u003eUsername\u003c/label\u003e \u003cinput placeholder=\"Enter your username\" key=\"username-input\"\u003e \u003c/template\u003e \u003ctemplate v-else=\"type === 'email'\"\u003e \u003clabel\u003eEmail\u003c/label\u003e \u003cinput placeholder=\"Enter your email address\" key=\"email-input\"\u003e \u003c/template\u003e \u003cbutton @click=\"toggleType\"\u003e切换登录类型\u003c/button\u003e \u003c/div\u003e \u003clabel\u003e元素仍然是被复用的，因为没有添加key属性。\nv-show v-show的使用方法与v-if大致一样，不同的是v-show只是简单地切换元素的CSS属性display。v-show表达式的值为true是就显示，false就隐藏。\n\u003cdiv id=\"app\"\u003e \u003cp v-show=\"show\"\u003e显示的内容\u003c/p\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { show: true } }); \u003c/script\u003e v-show不能用到\u003ctemplate\u003e上，不会生效。 v-if与v-show功能相同，但是v-if每次切换都会去销毁重建元素，但是v-show是惰性的，它只是进行了css切换。 所以说**v-if的切换开销更大，v-show适合在切换频繁的场景使用。**","绑定class#绑定class":"对象语法 v-bind:class指令可以与普通的class属性共存，可以传入多个属性。\n\u003cdiv id=\"app\"\u003e\u003cdiv class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\"\u003e\u003c/div\u003e\u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { isActive: true, hasError: false } }); \u003c/script\u003e //还可以绑定对象 \u003cdiv v-bind:class=\"classObject\"\u003e\u003c/div\u003e data: { classObject: { active: true, 'text-danger': false } } 上面的代码，结果渲染为\u003cdiv class=\"static active\"\u003e\u003c/div\u003e :class表达式过长或者逻辑比较复杂时，可以绑定计算属性：\n\u003cdiv id=\"app\"\u003e\u003cdiv :class=\"classObject\"\u003e\u003c/div\u003e\u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { isActive: true, error: null }, computed: { classObject: function () { return { active: this.isActive \u0026\u0026 !this.error, 'text-danger': this.error \u0026\u0026 this.error.type === 'fatal' } } } }); \u003c/script\u003e 数组语法 :class可以传入一个数组，以应用一个class列表：\n\u003cdiv id=\"app\"\u003e\u003cdiv class=\"static\" :class=\"[activeClass, errorClass]\"\u003e\u003c/div\u003e\u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { activeClass: 'active', errorClass: 'text-danger' } }); \u003c/script\u003e //三元表达式 \u003cdiv :class=\"[isActive ? activeClass : '', errorClass]\"\u003e\u003c/div\u003e //数组语法中也可以使用对象语法 \u003cdiv :class=\"[{ active: isActive }, errorClass]\"\u003e\u003c/div\u003e ","绑定内联样式#绑定内联样式":"Vue 绑定内联样式v-bind:style，和在元素张写css的写法相似，CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，用单引号括起来) 来命名：\n\u003cdiv id=\"app\"\u003e\u003cdiv :style=\"{'color': color, 'font-size': fontSize + 'px'}\"\u003e绑定样式\u003c/div\u003e\u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { color: \"red\", fontSize: 16 } }); \u003c/script\u003e 对象语法 \u003cdiv id=\"app\"\u003e\u003cdiv :style=\"styleObject\"\u003e绑定样式\u003c/div\u003e\u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { styleObject: { color: 'red', fontSize: '25px' } } }); \u003c/script\u003e 数组语法 应用多个样式对象时，可以使用数组语法。数组语法并不常用，一般是写在对象里，较为常用的应当是计算属性。\n\u003cdiv :style=\"[styleA, styleB]\"\u003e\u003c/div\u003e 自动添加前缀 当v-bind:style使用需要添加浏览器引擎前缀的 CSS 属性时， 如transform，Vue.js 会自动侦测并添加相应的前缀。浏览器引擎前缀，是一些放在CSS属性前的小字符串，用来确保这种属性只在特定的浏览器渲染引擎下才能识别和生效。 浏览器引擎前缀(Vendor Prefix)主要是各种浏览器用来试验或测试新出现的 CSS3 属性特征。\n这些前缀并非所有都是需要的，但通常你加上这些前缀不会有任何害处——只要记住一条，把不带前缀的版本放到最后一行：\n-moz-border-radius: 10px; -webkit-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px; 有些新的CSS3属性已经试验了很久，一些浏览器已经对这些属性不再使用前缀。Border-radius属性就是一个非常典型的例子。最新版的浏览器都支持不带前缀的Border-radius属性写法。"},"title":"command"},"/frontend-learn/docs/framework/vue/basic/component/":{"data":{"slot分发内容#\u003ccode\u003eslot\u003c/code\u003e分发内容":"","vue-组件#Vue 组件":"","x-template#\u003ccode\u003eX-Template\u003c/code\u003e":"Vue 组件Vue组件是Vue最核心的功能。\nVue的组件可以扩展html元素，提高代码重用性。\n注册组件 全局注册 Vue.component('my-component', { // 选项 }) 组件的命名最好使用小写加-分割的形式命名。\n使用：\n\u003cdiv id=\"app\"\u003e \u003cmy-component\u003e\u003c/my-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { template: '\u003cdiv\u003eA test component!\u003c/div\u003e' }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e template的DOM结构必须被一个元素包含，如果直接写成A test component!，不带\u003cdiv\u003e\u003c/div\u003e是无法渲染的。\n全局注册的行为必须在根Vue实例 (通过new Vue()) 创建之前发生。\n局部注册 new Vue({ // ... components: { // \u003cmy-component\u003e 只在父组件模板中可用 'my-component': { template: '\u003cdiv\u003eA test component!\u003c/div\u003e' } } }) 使用组件需要注意两点 DOM解析 Vue 组件的模板在某些情况下会受到HTML 的限制(例如，使用el选项来把 Vue 实例挂载到一个已有内容的元素上)， 像 \u003cul\u003e、\u003col\u003e、\u003ctable\u003e、\u003cselect\u003e 这样的元素里允许包含的元素有限制，而另一些像 \u003coption\u003e 这样的元素只能出现在某些特定元素的内部。 比如\u003ctable\u003e内规定只允许是\u003ctr\u003e、\u003ctd\u003e、\u003cth\u003e等这些表格元素，所以在\u003ctable\u003e内直接使用组件是无效的。这种情况下，可以使用特殊的is 属性来挂载组件:\n\u003ctable\u003e \u003cmy-table\u003e...\u003c/my-table\u003e //\u003cmy-row\u003e 会被当作无效的内容 \u003c/table\u003e //使用is属性 \u003ctable\u003e \u003ctr is=\"my-table\"\u003e\u003c/tr\u003e \u003c/table\u003e 使用字符串模板时不受限制的。\ndata选项必须是函数 \u003cdiv id=\"app\"\u003e \u003cmy-component2\u003e\u003c/my-component2\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component2', { template: '\u003cdiv\u003e{{message}}\u003c/div\u003e', data: function () { return { message: \"data 必须是函数\" } } }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e data必须是函数，是因为javascript的对象是引用关系，如果返回出的对象引用的是同一个对象，那么对这个对象的修改，所有引用它的组件都会收到影响：\n\u003cdiv id=\"app\"\u003e \u003cmy-component3\u003e\u003c/my-component3\u003e \u003cmy-component3\u003e\u003c/my-component3\u003e \u003cmy-component3\u003e\u003c/my-component3\u003e \u003c/div\u003e \u003cscript\u003e var data = { num: 0 }; Vue.component('my-component3', { template: '\u003cbutton @click=\"num++\"\u003e{{num}}\u003c/button\u003e', data: function () { return data; } }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 上面的代码中，三个组件实例共享了同一个data对象，因此递增一个num会影响所有组件。\n使用Prop传递数据 在 Vue 中，父子组件的关系可以总结为父组件通过Prop给子组件下发数据，子组件通过事件给父组件发送消息。\n\u003cdiv id=\"app\"\u003e \u003cchild-component message=\"父组件 prop下发的数据\"\u003e\u003c/child-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('child-component', { props: [\"message\"], template: '\u003cdiv\u003e{{message}}\u003c/div\u003e' }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e props中声明的数据与组件data函数return数据主要区别就是props的来自父级，而data中的是组件自己的数据， 作用域是组件本身，这两种数据都可以在模板template中使用也可以在 vm 实例中通过 this.message 来使用。 如果要传递多个数据，就在props数组中添加。\n因为HTML 特性是不区分大小写的。所以，使用DOM模板时，camelCase (驼峰式命名) 的prop需要转换成对应的kebab-case(短横线分隔式命名)：\nVue.component('child-component2', { props: [\"testMsg\"], template: '\u003cdiv\u003e{{testMsg}}\u003c/div\u003e' }); \u003c!-- 在 HTML 中使用 kebab-case --\u003e \u003cchild test-msg=\"camelCase 转成 kebab-case\"\u003e\u003c/child\u003e 字符串模板不受这个限制。\nprop传递动态数据 可以用v-bind来动态地将prop绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件：\n\u003cdiv id=\"app\"\u003e \u003cchild-component3 :test-msg3=\"dyMsg\"\u003e\u003c/child-component3\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('child-component3', { props: [\"testMsg3\"], template: '\u003cdiv\u003e{{testMsg3}}\u003c/div\u003e' }); var app = new Vue({ el: \"#app\", data: { dyMsg: \"父组件 动态prop数据\" } }); \u003c/script\u003e 当要传递布尔值，数值，数组，对象时，要使用v-bind，否则传递的是字符串，而不是你想要的值：\n\u003c!-- 传递了一个字符串 \"1\" --\u003e \u003ccomp some-prop=\"1\"\u003e\u003c/comp\u003e \u003c!-- 传递真正的数值 --\u003e \u003ccomp v-bind:some-prop=\"1\"\u003e\u003c/comp\u003e 单向数据流 vue 2中prop传递数据是单向的，父组件的数据变化可以传递给子组件，反之不行。这种设计，避免子组件改变父组件的状态，解耦父子组件。 一般两种情况下需要改变prop：\nProp作为初始值传入后，子组件想把它当作局部数据来用。 Prop作为原始数据传入，由子组件处理成其它数据输出。 处理方法：\n在组件的data函数中，声明一个新的变量，用prop的值初始化它： props: ['initialCounter'], data: function () { return { counter: this.initialCounter } } 使用计算属性： props: ['size'], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } } 在JavaScript中对象和数组是引用类型，指向同一个内存空间，所以props是一个对象或数组，在子组件内部改变它会影响父组件的状态。\nprop验证 为组件的prop指定验证规则，用对象的形式来定义prop，不用数组：\nVue.component('example', { props: { // 数字 (`null` 指允许任何类型) propA: Number, // 可以是多种类型数值或者字符串 propB: [String, Number], // 字符串，必传 propC: { type: String, required: true }, // 数值，如果没有传入默认值是100 propD: { type: Number, default: 100 }, // 数组/对象的默认值应当由一个工厂函数返回 propE: { type: Object, default: function () { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function (value) { return value \u003e 10 } } } }) type 类型：\nString Number Boolean Function Object Array Symbol type 也可以是一个自定义构造器函数，使用 instanceof 检测。 当prop验证失败，开发版本的Vue 会抛出警告。\n注意prop会在组件实例创建之前进行校验，所以在default或validator函数里，诸如data、computed或methods等实例属性还无法使用。\n组件间通信 父组件使用prop传递数据给子组件，子组件通过自定义事件向父组件传递数据。 Vue实现了两个接口$on和$emit，这两个接口类似addEventListener 和 dispatchEvent。 父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件：\n\u003cdiv id=\"app\"\u003e \u003cp\u003e{{ total }}\u003c/p\u003e \u003cmy-component v-on:increase=\"getTotal\" v-on:reduce=\"getTotal\"\u003e\u003c/my-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { template: `\u003cdiv\u003e \u003cbutton v-on:click=\"handleIncrease\"\u003e+\u003c/button\u003e \u003cbutton v-on:click=\"handleReduce\"\u003e-\u003c/button\u003e \u003c/div\u003e`, data: function () { return { number: 0 } }, methods: { handleIncrease: function () { this.number ++; this.$emit(\"increase\", this.number); }, handleReduce: function () { this.number --; this.$emit(\"reduce\", this.number); } } }); var app = new Vue({ el: \"#app\", data: { total: 0 }, methods: { getTotal: function (total) { this.total = total; } } }) \u003c/script\u003e $emit()方法的第一个参数是自定义事件的名称，例如示例的increase和reduce后面的参数都是要传递的数据，可以不填或填写多个。\n绑定原生事件 如果需要在组件上监听原生DOM事件，使用修饰符.native：\n\u003cmy-component v-on:click.native=\"doSomeThing\"\u003e\u003c/my-component\u003e 使用v-model \u003cdiv id=\"app\"\u003e \u003cp\u003e{{total}}\u003c/p\u003e \u003cmy-component v-model=\"total\"\u003e\u003c/my-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { template: \"\u003cbutton @click='handleClick'\u003e+\u003c/button\u003e\", data: function () { return { number: 0 } }, methods: { handleClick: function () { this.number ++; this.$emit(\"input\", this.number); } } }); var app = new Vue({ el: \"#app\", data: { total: 0 } }) \u003c/script\u003e 上面的代码实现了点击按钮加1的效果，不过这次组件$emit的事件名是特殊的input，在使用组件的父级，井没有在\u003cmy-component\u003e上使用@input= \"handler\"， 而是直接用了v-model绑定的一个数据total。这也可以算是一个语法糖，也可以改成：\n\u003cdiv id=\"app\"\u003e \u003cp\u003e{{total}}\u003c/p\u003e \u003cmy-component @input=\"getTotal\"\u003e\u003c/my-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { .... }); var app = new Vue({ el: \"#app\", data: { total: 0 }, methods: { getTotal: function(total) { this.total = total; } } }) \u003c/script\u003e \u003cinput v-model=\"something\"\u003e 这不过是以下示例的语法糖：\n\u003ccustom-input v-bind:value=\"something\" v-on:input=\"something = arguments[0]\"\u003e \u003c/custom-input\u003e 也就是绑定父组件的value，监听子组件的input事件。\n所以要让组件的v-model生效，它应该：\n子组件接受一个value prop 在有新的值时触发input事件并将新值作为参数 v-model创建自定义表单输入组件 \u003cdiv id=\"app\"\u003e \u003cp\u003e{{total}}\u003c/p\u003e \u003cmy-component v-model=\"total\"\u003e\u003c/my-component\u003e \u003cbutton @click=\"handleReduce\"\u003e-\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { props: [\"value\"], template: '\u003cinput :value=\"value\" @input=\"updateValue\"', methods: { updateValue: function () { this.$emit(\"input\", event.target.value); } } }); var app = new Vue({ el: \"#app\", data: { total: 100 }, methods: { handleReduce: function () { this.total --; } } }) \u003c/script\u003e 非父子组件通信 非父子关系的组件间通信，可以使用一个空的Vue实例作为事件总线(bus)，也就是一个中介：\n\u003cdiv id=\"app\"\u003e {{msg}} \u003cmy-component1\u003e\u003c/my-component1\u003e \u003c/div\u003e \u003cscript\u003e var bus = new Vue(); Vue.component('my-component1', { template: '\u003cbutton @click=\"handleClick\"\u003ebus\u003c/button\u003e', methods: { handleClick: function () { bus.$emit(\"on-msg\", \"my-component1 发出的消息\") } } }); var app = new Vue({ el: \"#app\", data: { msg: \"\" }, mounted: function () { var self = this; bus.$on(\"on-msg\", function (msg) { self.msg = msg; }) } }) \u003c/script\u003e 这种方法轻量地实现了任何组件间的通信，如果深入使用，可以扩展bus实例，给它添加data 、methods 、computed 等选项，这些都是可以公用的，在业务中， 尤其是协同开发时非常有用，因为经常需要共享一些通用的信息，比如用户登录的昵称、性别、邮箱等，还有用户的授权token等。只需在初始化时让bus获取一次， 任何时间、任何组件就可以从中直接使用了，在单页面富应用（SPA ）中会很实用\nslot分发内容 当需要让组件组合使用，混合父组件的内容与子组件的模板时，就会用到slot，这个过程叫作内容分发（transclusion）。 props传递数据、events 触发事件和slot 内容分发就构成了Vue 组件的3 个API 来源，再复杂的组件也是由这3部分构成的。\n作用域 学习slot，首先要知道：编译的作用域。例如：\n\u003cchild-component\u003e {{ message }} \u003c/child-component\u003e 这里的message就是一个slot，但是它绑定的是父组件的数据，而不是子组件\u003c/child-component\u003e的数据。 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。\n\u003c!-- 无效 --\u003e \u003cchild-component v-show=\"someChildProperty\"\u003e\u003c/child-component\u003e 上面的代码，试图在父组件模板内将一个指令绑定到子组件的属性/方法，someChildProperty是子组件的属性，上例不会如预期那样工作。父组件模板并不感知子组件的状态。 正确的方式应该是：\nVue.component('child-component', { // 有效，因为是在正确的作用域内 template: '\u003cdiv v-show=\"someChildProperty\"\u003eChild\u003c/div\u003e', data: function () { return { someChildProperty: true } } }) 类似地，被分发的内容会在父作用域内编译。\n单个slot 在子组件内使用特殊的\u003cslot\u003e元素就可以为这个子组件开启一个slot，如果没有\u003cslot\u003e元素，父组件的内容将会被丢弃。\n\u003cdiv id=\"app\"\u003e \u003cchild-component1\u003e \u003cp\u003e分发的内容\u003c/p\u003e \u003cp\u003e更多的内容\u003c/p\u003e \u003c/child-component1\u003e \u003c/div\u003e \u003cscript\u003e var bus = new Vue(); Vue.component('child-component1', { template: '\u003cdiv\u003e\u003cslot\u003e\u003cp\u003e父组件没有插入内容，就显示\u003c/p\u003e\u003c/slot\u003e\u003c/div\u003e' }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 如果父组件没有插入内容，就会显示最初在\u003cslot\u003e标签中的内容（备用内容）。\n备用内容在子组件的作用域内编译。\n具名slot \u003cslot\u003e元素可以指定一个name来进一步配置如何分发内容。多个插槽可以有不同的名字。 仍然可以有一个匿名插槽，它是默认插槽。 作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。\n\u003cdiv id=\"app\"\u003e \u003cchild-component1\u003e \u003ch2 slot=\"header\"\u003eslot header\u003c/h2\u003e \u003cp\u003e分发的内容\u003c/p\u003e \u003cp\u003e更多的内容\u003c/p\u003e \u003cdiv slot=\"footer\"\u003eslot footer\u003c/div\u003e \u003c/child-component1\u003e \u003c/div\u003e \u003cscript\u003e var bus = new Vue(); Vue.component('child-component1', { template: '' + '\u003cdiv class=\"container\"\u003e' + ' \u003cdiv\u003e\u003cslot name=\"header\"\u003e\u003c/slot\u003e\u003c/div\u003e' + ' \u003cdiv\u003e\u003cslot\u003e\u003c/slot\u003e\u003c/div\u003e' + ' \u003cdiv\u003e\u003cslot name=\"footer\"\u003e\u003c/slot\u003e\u003c/div\u003e' + '\u003c/div\u003e' }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 作用域插槽 作用域插槽是一种特殊的插槽，使用一个可以复用的模板替换己渲染元素。\n\u003cdiv id=\"app\"\u003e \u003cchild-component1\u003e \u003ctemplate slot-scope=\"props\"\u003e \u003cp\u003e显示父组件的内容\u003c/p\u003e \u003cp\u003e{{props.message}}\u003c/p\u003e \u003c/template\u003e \u003c/child-component1\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('child-component1', { template: '\u003cdiv\u003e\u003cslot message=\"显示子组件的内容\"\u003e\u003c/slot\u003e\u003c/div\u003e', }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 上面的代码中，在父组件中有一个特殊属性slot-scope ，它的值将被用作一个临时变量名，此变量接收从子组件传递过来的数据， 在子组件中，\u003cslot\u003e元素上有一个message=\"显示子组件的内容\"，用来将数据传到slot。\n$slot $slot用来访问被插槽分发的内容，每个具名插槽有其相应的属性 (例如slot=\"foo\"中的内容将会在vm.$slots.foo中被找到)。 vm.$slots.default属性包括了所有没有被包含在具名插槽中的节点。\n在使用render函数创建组件时，比较有用。\n动态组件 is特性来实现动态组件。 添加一个keep-alive指令，可以把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染：\n\u003ckeep-alive\u003e \u003ccomponent :is=\"currentTabComponent\"\u003e \u003c!-- 非活动组件将被缓存！ --\u003e \u003c/component\u003e \u003c/keep-alive\u003e 组件会在 currentTabComponent 改变时改变。\n异步组件 当项目比较大时，没有必要一开始把所有组件都加载，降低性能。注册vue的组件的时候，第二个参数定义为一个工厂函数， 实现异步加载组件：\n\u003cdiv id=\"app\"\u003e \u003cmy-component\u003e\u003c/my-component\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e Vue.component('my-component', function (resolve, reject) { setTimeout(function () { resolve({ template: \"\u003cdiv\u003e异步加载组件\u003c/div\u003e\" }) }, 5000) }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 这里的resolve和reject和Promise对象的resolve方法，reject方法效果差不多。setTimeout只是为了表示这里是个异步方法。\n递归组件 组件在它的模板内可以递归地调用自己，只需要给组件设置name选项：\n\u003cdiv id=\"app\"\u003e \u003cmy-component :count=\"1\"\u003e\u003c/my-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { name: \"my-component\", props: { count: { type: Number, default: 1 } }, template: \"\u003cdiv\u003e\u003cmy-component :count='count + 1' v-if='count \u003c 3'\u003e\u003c/my-component\u003e\u003c/div\u003e\" }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 使用递归组件，要确保递归调用有终止条件 (比如递归调用时使用v-if并最终解析为false)，否则会导致一个max stack size exceeded错误。 可以用来开发一些具有未知层级关系的独立组件，比如级联选择器。\n内联模板 如果子组件有inline-template特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。\n\u003cdiv id=\"app\"\u003e \u003cmy-component inline-template\u003e \u003cdiv\u003e \u003ch2\u003e父组件中定义的组件的模板\u003c/h2\u003e \u003c/div\u003e \u003c/my-component\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e inline-template让模板的作用域难以理解。使用template选项在组件内定义模板或者在.vue文件中使用template元素才是最佳实践。\nX-Template 另一种定义模板的方式是在JavaScript标签里使用text/x-template类型，并且指定一个id。\n\u003cdiv id=\"app\"\u003e \u003cmy-component\u003e\u003c/my-component\u003e \u003cscript type=\"text/x-template\" id=\"my-component\"\u003e \u003cdiv\u003e组件的内容\u003c/div\u003e \u003c/script\u003e \u003c/div\u003e \u003cscript\u003e Vue.component('my-component', { template: \"#my-component\" }); var app = new Vue({ el: \"#app\" }) \u003c/script\u003e 这种方式将模板和组件的其它定义分离了，应该避免使用。","使用prop传递数据#使用\u003ccode\u003eProp\u003c/code\u003e传递数据":"","使用组件需要注意两点#使用组件需要注意两点":"","内联模板#内联模板":"","动态组件#动态组件":"","子组件索引#子组件索引":"在子组件中，可以使用this.$parent访问父实例，如果当前实例有的话。父组件也可以通过this.$children访问它所有的子组件， 需要注意$children并不保证顺序，也不是响应式的。Vue提供了子组件索引的方法，可以使用ref为子组件指定一个引用ID。例如：\n\u003cdiv id=\"parent\"\u003e \u003cuser-profile ref=\"profile\"\u003e\u003c/user-profile\u003e \u003c/div\u003e \u003cscript\u003e var parent = new Vue({ el: '#parent' }) // 访问子组件实例 var child = parent.$refs.profile \u003c/script\u003e ","异步组件#异步组件":"","总结#总结":" 全局注册，局部注册，组件的命名最好使用小写加-分割的形式命名。 全局注册的行为必须在根Vue实例 (通过new Vue()) 创建之前发生。 template的DOM结构必须被一个元素包含，否则无法渲染。 使用组件需要注意两点： data选项必须是函数 像 \u003cul\u003e、\u003col\u003e、\u003ctable\u003e、\u003cselect\u003e 这样的元素里允许包含的元素有限制，而另一些像 \u003coption\u003e 这样的元素只能出现在某些特定元素的内部。 比如\u003ctable\u003e内规定只允许是\u003ctr\u003e、\u003ctd\u003e、\u003cth\u003e等这些表格元素，所以在\u003ctable\u003e内直接使用组件是无效的。 使用特殊的is 使用字符串模板时不受限制的。 使用DOM模板时，camelCase(驼峰式命名)的prop需要转换成对应的kebab-case(短横线分隔式命名)。字符串模板不受这个限制。 当要传递布尔值，数值，数组，对象时，要使用v-bind，否则传递的是字符串，而不是你想要的值。 在JavaScript中对象和数组是引用类型，指向同一个内存空间，所以props是一个对象或数组，在子组件内部改变它会影响父组件的状态。 prop验证。 父组件使用prop传递数据给子组件，子组件通过自定义事件向父组件传递数据。 如果需要在组件上监听原生DOM事件，使用修饰符.native 要让组件的v-model生效，它应该： 子组件接受一个value prop 在有新的值时触发input事件并将新值作为参数 非父子组件通信： 可以使用一个空的Vue实例作为事件总线(bus) props传递数据、events触发事件和slot内容分发就构成了Vue组件的3个API来源，再复杂的组件也是由这3部分构成的。 编译的作用域，父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。 在子组件内使用特殊的\u003cslot\u003e元素就可以为这个子组件开启一个slot，如果没有\u003cslot\u003e元素，父组件的内容将会被丢弃。 \u003cslot\u003e 元素可以指定一个name来进一步配置如何分发内容。多个插槽可以有不同的名字。仍然可以有一个匿名插槽，它是默认插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。 作用域插槽是一种特殊的插槽，使用一个可以复用的模板替换己渲染元素。 $slot用来访问被插槽分发的内容 keep-alive指令，可以把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染 注册vue的组件的时候，第二个参数定义为一个工厂函数，实现异步加载组件 组件在它的模板内可以递归地调用自己，只需要给组件设置name选项 ","注册组件#注册组件":"","组件间通信#组件间通信":"","递归组件#递归组件":""},"title":"component"},"/frontend-learn/docs/framework/vue/basic/component_pack/":{"data":{"vue-如何封装组件#Vue 如何封装组件":"","不要依赖-vuex#不要依赖 Vuex":" Vuex 用来做组件状态管理的，类似一个全局变量，会一直占用内存，除非刷新页面，不建议用来非父子组件通信。 Vuex 在写入数据庞大的 state 的时候，就会产生内存泄露 如果刷新页面时需要保留数据，可以通过 web storage 保存。 ","合理运用-scoped#合理运用 scoped":"在编写组件的时候，可以在\u003cstyle\u003e标签中添加scoped，让标签中的样式只对当前组件生效，但是一味的使用scoped，肯定会产生大量的重复代码， 所以当全局样式写好之后，再针对每个组件，通过scoped属性添加组件样式。","在父组件处理事件#在父组件处理事件":"","数据从父组件传入#数据从父组件传入":"","留一个slot#留一个\u003ccode\u003eslot\u003c/code\u003e":"Vue 如何封装组件封装通用组件必须具备高性能、低耦合的特性，如何封装一个好的组件？\n数据从父组件传入 为了低耦合，子组件就应该是无状态的。即使本身会生成数据，也只能在内部使用，不能传递出去。 应该对props传递的参数应该添加一些验证规则 props传入的参数，不建议修改，如果必须要修改，建议定义子组件的data的一个属性来接收prop传入的值。 如果prop只以一种原始的值传入且需要进行转换，可以使用计算属性，比如把prop传入的值转成小写return this.size.trim().toLowerCase()。 在父组件处理事件 事件的处理方法应当尽量放到父组件中，通用组件本身只作为一个中转，降低耦合性，保证了通用组件中的数据不被污染 组件内部的一些交互行为，或者处理的数据只在组件内部传递，这时候就不需要用$emit了 留一个slot 一个通用组件，往往不能够完美的适应所有应用场景，留一个slot来让父组件实现一些功能。 开发通用组件的时候，只要不是独立性很高的组件，建议都留一个slot，即使还没想好用来干什么。 "},"title":"component_pack"},"/frontend-learn/docs/framework/vue/basic/computed/":{"data":{"getter-setter#getter setter":"每一个计算属性都包含getter和setter方法，计算属性默认只有getter，但是可以自己提供setter。\ncomputed: { fullName: { // getter get: function () { return this.firstName + ' ' + this.lastName }, // setter ，执行 vm.fullName = 'pooky' 时，setter 就会被调用，从而更新firstName lastName set: function (newValue) { var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } } } ","vue-计算属性#Vue 计算属性":"Vue 计算属性模板内的表达式一般只用来做简答计算，碰到复杂的逻辑，最好使用计算属性，方便维护。 计算属性还可以依赖多个Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。 计算属性可以理解为一种代理模式，在读取属性之时，先经历读代理(getter)中的计算，再返回需要的结果，这个过程就可以认为是在为这个属性添加了一个代理。 也可以添加写代理(setter)。\n\u003cdiv id=\"app\"\u003e {{ prices }} \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { phones: [ { name: \"iPhone 7\", price: 5600, count: 10 }, { name: \"iPhone x\", price: 8900, count: 100 }, { name: \"iPhone 8\", price: 6000, count: 12 }, ], books: [ { name: \"Nodejs\", price: 56, count: 10 }, { name: \"Vue\", price: 46, count: 100 }, { name: \"Go\", price: 60, count: 12 }, ] }, computed: { prices: function () { var prices = 0; for (var i = 0; i \u003c this.phones.length; i ++) { prices += this.phones[i].price * this.phones[i].count; } for (var i = 0; i \u003c this.books.length; i ++) { prices += this.books[i].price * this.books[i].count; } return prices; } } }) \u003c/script\u003e 上面的代码中，使用了计算属性computed，商品变化，总价就会变化。","总结#总结":" 计算属性只有在它的相关依赖发生改变时才会重新求值。 每一个计算属性都包含getter和setter方法，计算属性默认只有getter，但是可以自己提供setter。 计算属性和方法区别就是计算属性是基于它的依赖缓存的。也就是说，计算属性之后在它依赖的数据改变时，才会重新取值计算，否则不会更新。methods 只要重新渲染就会被调用。 如果需要大量的计算时，建议使用计算属性。 计算属性是代理模式，侦听器是观察者模式。 尽量使用计算属性，数据变化，需要执行异步或者开销较大，使用侦听属性。 ","计算属性与方法#计算属性与方法":"用methods也可以实现相同的效果，计算属性和方法区别就是计算属性是基于它的依赖缓存的。也就是说，计算属性只会在它依赖的数据改变时， 才会重新取值计算，否则不会更新。methods只要重新渲染就会被调用。\n所以是否使用计算属性，取决于是否需要缓存，如果需要大量的计算时，建议使用计算属性。\n\u003cdiv id=\"example\"\u003e \u003cp\u003eOriginal message: \"{{ message }}\"\u003c/p\u003e \u003cp\u003eComputed reversed message: \"{{ reversedMessage }}\"\u003c/p\u003e \u003c/div\u003e var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } } }) 上面的例子中，message是响应式的，message改变，reversedMessage也改变。\ncomputed: { now: function () { return Date.now() } } 上面的例子，Date.now()不是响应式依赖，所以计算属性将不再更新。","计算属性和侦听属性#计算属性和侦听属性":"侦听属性用来观察 Vue 实例的数据变化。\n尽量使用计算属性。 数据变化，需要执行异步或者开销较大，使用侦听属性。 侦听属性，就是观察者模式了。\n//使用methods var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } } }) //使用计算属性，代码更简洁 var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) ","计算属性的两个小技巧#计算属性的两个小技巧":" 计算属性可以依赖其他计算属性 计算属性不仅可以依赖当前Vue 实例的数据，还可以依赖其他实例的数据 "},"title":"computed"},"/frontend-learn/docs/framework/vue/basic/custom_command/":{"data":{"vue-自定义指令#Vue 自定义指令":"Vue 自定义指令Vue 提供了很多内置的指令，但是有时我们希望对DOM进行底层操作，这就需要自定义指令。","自定义指令注册#自定义指令注册":"全局注册 全局注册一个v-test的指令：\nVue.directive(\"test\", { //指令选项 }) 局部注册 局部注册一个v-test的指令：\nvar app = new Vue({ el: \"#app\", directive: { test: { //指令选项 } } }) ","钩子#钩子":"指令定义对象可以提供如下几个钩子函数，都是可选的：\nbind，只调用一次，指令在第一次绑定到元素时调用。这个钩子可以定义一个在绑定时执行一次的初始化设置。 inserted，被绑定元素插入父节点时调用。 update，被绑定元素所在的模板更新时调用。 componentUpdated，被绑定元素所在模板完成一次更新周期时调用． unbind，只调用一次，指令与元素解绑时调用。 钩子函数参数 el：指令所绑定的元素，可以直接操作 DOM 。 binding：Object类型 name：指令名字，不包括v-前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\"中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如v-my-directive=\"1 + 1\"中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如v-my-directive:foo中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如v-my-directive.foo.bar中，修饰符对象为{ foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 \u003cdiv id=\"app\"\u003e \u003cdiv v-test:msg.a.b=\"message\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cscript\u003e Vue.directive('test', { bind: function (el, binding, vnode) { var s = JSON.stringify; el.innerHTML = 'name: ' + s(binding.name) + '\u003cbr\u003e' + 'value: ' + s(binding.value) + '\u003cbr\u003e' + 'expression: ' + s(binding.expression) + '\u003cbr\u003e' + 'argument: ' + s(binding.arg) + '\u003cbr\u003e' + 'modifiers: ' + s(binding.modifiers) + '\u003cbr\u003e' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }); new Vue({ el: '#app', data: { message: 'Hello, Vue!' } }) \u003c/script\u003e "},"title":"custom_command"},"/frontend-learn/docs/framework/vue/basic/event/":{"data":{"event#$event":"@click=\"handleClick()\"这里的handleClick可以跟上()也可以不跟，如果不需要参数，就可以不跟，但如果需要传入参数， 没有括号时，也会默认会将原生事件对象event传入，加了括号时，如果要用event参数，可以使用 Vue 提供的一个特殊变量$event，用于访问原生DOM 事件：\n\u003cdiv id=\"app\"\u003e \u003cbutton v-on:click=\"say('hi', $event)\"\u003eSay hi\u003c/button\u003e \u003cbutton v-on:click=\"say('what', $event)\"\u003eSay what\u003c/button\u003e \u003cbutton v-on:click=\"warn('Form cannot be submitted yet.', $event)\"\u003eSubmit\u003c/button\u003e \u003ca href=\"http://www.baidu.com\" @click=\"handle('禁止打开', $event)\"\u003e打开链接\u003c/a\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { number: 18 }, methods: { say: function (msg) { alert(msg); alert(event.target.tagName); }, warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) event.preventDefault(); alert(message); }, handle(message, event) { if (event) event.preventDefault(); alert(message); } } }) \u003c/script\u003e ","vue-事件处理#Vue 事件处理":"Vue 事件处理Vue中使用指令v-on监听DOM事件，缩写是@。类似原生javascript的 onclick。\n\u003cdiv id=\"app\"\u003e \u003cspan\u003e{{number}}\u003c/span\u003e \u003cbutton @click=\"number++\"\u003e点击加1\u003c/button\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { number: 18 } }) \u003c/script\u003e 通常情况下，业务逻辑比较复杂，@click后面可以跟上方法名，方法定义在vue实例的methods中。\n\u003cdiv id=\"app\"\u003e \u003cspan\u003e{{number}}\u003c/span\u003e \u003cbutton @click=\"handleClick()\"\u003e点击加1\u003c/button\u003e \u003cbutton @click=\"handleClick(10)\"\u003e点击加10\u003c/button\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { number: 18 }, methods: { handleClick: function (num) { num = num || 1; this.number += num; } } }) \u003c/script\u003e ","事件修饰符#事件修饰符":"上面的例子，调用event.preventDefault()或event.stopPropagation()这种方法，虽然可以在方法中实现， 但是更好的方式：**方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。**在vue中可以通过修饰符实现，修饰符是由点开头的指令后缀来表示的：\n.stop .prevent .capture .self .once 用法：\n\u003c!-- 阻止单击事件冒泡 --\u003e \u003ca @click.stop=\"handle\"\u003e\u003c/a\u003e \u003c!-- 提交事件不再重载页面 --\u003e \u003cform @submit.prevent=\"handle\"\u003e\u003c/form\u003e \u003c!-- 修饰符可以串联 --\u003e \u003ca @click.stop.prevent=\"handle\"\u003e\u003c/a\u003e \u003c!-- 只有修饰符 --\u003e \u003cform @submit.prevent\u003e\u003c/form\u003e \u003c!-- 添加事件监听器时使用事件捕获模式 --\u003e \u003c!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --\u003e \u003cdiv @click.capture=\"doThis\"\u003e...\u003c/div\u003e \u003c!-- 只当在 event.target 是当前元素自身时触发处理函数 --\u003e \u003c!-- 即事件不是从内部元素触发的 --\u003e \u003cdiv @click.self=\"doThat\"\u003e...\u003c/div\u003e \u003c!-- 点击事件将只会触发一次 --\u003e \u003ca @click.once=\"doThis\"\u003e\u003c/a\u003e \u003c!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --\u003e \u003c!-- 而不会等待 `onScroll` 完成 --\u003e \u003c!-- 这其中包含 `event.preventDefault()` 的情况 --\u003e \u003cdiv @scroll.passive=\"onScroll\"\u003e...\u003c/div\u003e \u003c!-- 键盘事件 --\u003e \u003c!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --\u003e \u003cinput @keyup.13=\"submit\"\u003e \u003c!-- Vue 为最常用的按键提供了别名 --\u003e \u003cinput @keyup.enter=\"submit\"\u003e 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用v-on:click.prevent.self会阻止所有的点击，而v-on:click.self.prevent只会阻止对元素自身的点击。 不要把.passive和.prevent一起使用，因为.prevent将会被忽略，同时浏览器可能会向你展示一个警告。\n常用的按键别名：\n.enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 自定义按键修饰符别名：\n// 可以使用 v-on:keyup.f1 Vue.config.keyCodes.enter2 = 13 按键修饰符也可以组合使用，或和鼠标一起配合使用：\n.ctrl .alt .shift .meta 例如：\n\u003c!-- Alt + C --\u003e \u003cinput @keyup.alt.67=\"handle\"\u003e \u003c!-- Ctrl + Click --\u003e \u003cdiv @click.ctrl=\"handle\"\u003eCtrl Click\u003c/div\u003e ","总结#总结":" Vue中使用指令v-on监听DOM事件，缩写是@。类似原生javascript的 onclick。 使用$event，访问原生DOM事件。 方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 事件修饰符： .stop，阻止事件冒泡 .prevent，阻止元素发生默认的行为 .capture，添加事件监听器时使用事件捕获模式 .self，只当在event.target是当前元素自身时触发处理函数 .once，事件将只会触发一次 "},"title":"event"},"/frontend-learn/docs/framework/vue/basic/form/":{"data":{"vue-表单#Vue 表单":"Vue 表单使用Vue指令v-model可以完成表单数据的双向绑定。","修饰符#修饰符":"与事件的修饰符类似，v-model也有修饰符，用于控制数据同步的时机。\n.lazy 在输入框中，v-model默认是在input事件中同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。\n\u003cinput v-model.lazy=\"msg\" type=\"text\"\u003e 添加了.lazy修饰符之后，msg 不会实时再改变，而是在失焦或按回车时才更新。\n.number 自动将用户的输入值转为数值类型，在数字输入框时会比较有用。\n\u003cinput v-model.number=\"age\" type=\"number\"\u003e .trim 自动过滤用户输入的首尾空白字符。\n\u003cinput v-model.trim=\"msg\"\u003e ","单选按钮#单选按钮":" \u003cdiv id=\"app\"\u003e \u003cinput type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"\u003e \u003clabel for=\"one\"\u003eOne\u003c/label\u003e \u003cbr\u003e \u003cinput type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"\u003e \u003clabel for=\"two\"\u003eTwo\u003c/label\u003e \u003cbr\u003e \u003cspan\u003ePicked: {{ picked }}\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { picked: '' } }) \u003c/script\u003e ","复选框#复选框":" \u003cdiv id=\"app\"\u003e \u003c!--单个复选框，绑定到布尔值--\u003e \u003cinput type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"\u003e \u003clabel for=\"checkbox\"\u003e状态：{{ checked }}\u003c/label\u003e \u003cbr\u003e \u003c!--多个复选框，绑定到同一个数组--\u003e \u003cinput type=\"checkbox\" id=\"ihpone\" value=\"ihpone\" v-model=\"phones\"\u003e \u003clabel for=\"ihpone\"\u003eihpone\u003c/label\u003e \u003cbr\u003e \u003cinput type=\"checkbox\" id=\"huawei\" value=\"huawei\" v-model=\"phones\"\u003e \u003clabel for=\"huawei\"\u003ehuawei\u003c/label\u003e \u003cbr\u003e \u003cinput type=\"checkbox\" id=\"sansung\" value=\"sansung\" v-model=\"phones\"\u003e \u003clabel for=\"sansung\"\u003esansung\u003c/label\u003e \u003cbr\u003e \u003cspan\u003eChecked phones: {{ phones }}\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { checked: false, phones: [] } }) \u003c/script\u003e ","总结#总结":" v-model只依赖所绑定的数据，会忽略初始化时的value、checked、selected属性的初始值。 使用v-model时，如果是用中文输入法输入中文，一般在没有选定词组前，也就是在拼音阶段，Vue 是不会更新数据的， 当敲下汉字时才会触发更新。如果希望总是实时更新，可以用@input来替代v-model。 \u003coption\u003e是备选项，如果含有value属性，v-model就会优先匹配value的值：如果没有，就会直接匹配\u003coption\u003e的text，推荐像上面这样提供一个值为空的禁用选项。 v-model绑定的值是一个静态字符串或布尔值 修饰符： .lazy，v-model默认是在input事件中同步输入框的数据，使用修饰符.lazy会转变为在change事件中同步。 .number，自动将用户的输入值转为数值类型，在数字输入框时会比较有用。 .trim，自动过滤用户输入的首尾空白字符。 ","文本#文本":" \u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" v-model=\"message\" placeholder=\"输入 ...\"\u003e \u003cp\u003e输入的内容：{{message}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { message: \"\" }, methods: { handle: function () { console.log(event.target.value); //默认第一个参数是event this.message = event.target.value; } } }) \u003c/script\u003e **v-model只依赖所绑定的数据，会忽略初始化时的value、checked、selected属性的初始值， 在\u003ctextarea\u003e\u003c/textarea\u003e 之间插入的值，也不会生效。使用v-model时，如果是用中文输入法输入中文， 一般在没有选定词组前，也就是在拼音阶段，Vue 是不会更新数据的，当敲下汉字时才会触发更新。如果希望总是实时更新，可以用@input来替代v-model。 **\n\u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" @input=\"handle\" placeholder=\"输入 ...\"\u003e \u003cp\u003e输入的内容：{{message}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { message: \"\" }, methods: { handle: function () { console.log(event.target.value); this.message = event.target.value; } } }) \u003c/script\u003e ","文本域#文本域":" \u003ctextarea v-model=\"message\" placeholder=\"输入 ...\"\u003e\u003c/textarea\u003e \u003cp\u003e输入的内容：{{message}}\u003c/p\u003e ","绑定值#绑定值":"单选按钮、复选框和选择列表在单独使用或单选的模式下，v-model绑定的值是一个静态字符串或布尔值，但有时需要绑定一个动态的数据，这时可以用v-bind来实现。\n\u003c!--单选按钮--\u003e \u003cdiv id=\"app\"\u003e \u003cinput type=\"radio\" v-model=\"picked\" :value=\"value\"\u003e \u003clabel\u003e单选按钮\u003c/label\u003e \u003cp\u003e{{picked}}\u003c/p\u003e \u003cp\u003e{{value}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { picked: false, value: 666 } }) \u003c/script\u003e \u003c!--复选框--\u003e \u003cdiv id=\"app\"\u003e \u003cinput type=\"checkbox\" v-model=\"toggle\" :true-value=\"value1\" :false-value=\"value2\"\u003e \u003cp\u003e{{toggle}}\u003c/p\u003e \u003cp\u003e{{value1}}\u003c/p\u003e \u003cp\u003e{{value2}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { toggle: false, value1: 666, value2: 888 } }) \u003c/script\u003e \u003c!--选择列表--\u003e \u003cdiv id=\"app\"\u003e \u003cselect v-model=\"selected\"\u003e \u003c!-- 内联对象字面量 --\u003e \u003coption v-bind:value=\"{ number: 123 }\"\u003e123\u003c/option\u003e \u003c/select\u003e \u003cp\u003e选中：{{selected.number}}\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { selected: \"\" } }) \u003c/script\u003e 选择列表，当选中时，app.selected是一个Object，所以app.selected.number == 123。\n复选框中的的true-value和false-value不会影响输入控件的value特性，因为浏览器在提交表单时并不会包含未被选中的复选框。 如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。","选择列表#选择列表":" \u003cdiv id=\"app\"\u003e \u003cselect v-model=\"selected\"\u003e \u003coption disabled value=\"\"\u003e请选择\u003c/option\u003e \u003coption\u003eA\u003c/option\u003e \u003coption\u003eB\u003c/option\u003e \u003coption\u003eC\u003c/option\u003e \u003c/select\u003e \u003cbr\u003e \u003cspan\u003eSelected: {{ selected }}\u003c/span\u003e \u003cbr\u003e \u003c!--多选--\u003e \u003cselect v-model=\"multiSelected\" multiple\u003e \u003coption value=\"apple\"\u003eiphone\u003c/option\u003e \u003coption\u003ehuawei\u003c/option\u003e \u003coption\u003esansung\u003c/option\u003e \u003c/select\u003e \u003cbr\u003e \u003cspan\u003eSelected: {{ multiSelected }}\u003c/span\u003e \u003cbr\u003e \u003c!--用 v-for 渲染--\u003e \u003cselect v-model=\"dyselected\"\u003e \u003coption v-for=\"option in options\" v-bind:value=\"option.value\"\u003e {{ option.text }} \u003c/option\u003e \u003c/select\u003e \u003cbr\u003e \u003cspan\u003eSelected: {{ dyselected }}\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { selected: '', multiSelected: [\"apple\", \"huawei\"], dyselected: '', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } }) \u003c/script\u003e \u003coption\u003e是备选项，如果含有value属性，v-model就会优先匹配value的值：如果没有，就会直接匹配\u003coption\u003e的text，推荐像上面这样提供一个值为空的禁用选项。"},"title":"form"},"/frontend-learn/docs/framework/vue/basic/mixin/":{"data":{"vue-混入#Vue 混入":"Vue 混入混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。使用场景：\n使用混入可以减少代码量，实现代码重用。 后期需要增加方法时，使用混入会减少源代码的污染。 ","全局混入和局部混入#全局混入和局部混入：":" //全局混入 Vue.mixin({ created: function () { } }) //局部混入 var mixin = { created: function () { } } var app = new Vue({ mixins: [mixin], methods: { } }) 当组件和混入对象含有同名选项时，以下面的方式混合：\n数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。 同名钩子函数将混合为一个数组，因此都将被调用。混入对象的钩子将在组件自身钩子之前调用。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 Vue.extend()也使用同样的策略进行合并。 一旦使用全局混入对象，将会影响到所有之后创建的 Vue 实例。"},"title":"mixin"},"/frontend-learn/docs/framework/vue/basic/plugin/":{"data":{"vue-插件#Vue 插件":"Vue 插件Vue 插件，可以添加全局功能。\n例如：\n添加全局方法或者属性，如:vue-custom-element 添加全局资源：指令/过滤器/过渡等，如vue-touch 通过全局mixin方法添加一些组件选项，如:vue-router 添加 Vue 实例方法，通过把它们添加到Vue.prototype上实现。 ","使用插件#使用插件":" // 调用 `MyPlugin.install(Vue)` Vue.use(MyPlugin, {}) Vue.use会自动阻止多次注册相同插件。","注册插件#注册插件":"Vue 的插件要有一个公开方法install。该方法第一个参数是 Vue 构造器，第二个参数是一个可选的对象：\nMyPlugin.install = function (Vue, options) { //添加全局方法或属性 Vue.myGlobalMethod = function () { // 逻辑... } //添加全局资源 Vue.directive('my-directive', { bind (el, binding, vnode, oldVnode) { // 逻辑... } ... }) //添加全局混合 Vue.mixin({ created: function () { // 逻辑... } ... }) //添加实例方法 Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... } } "},"title":"plugin"},"/frontend-learn/docs/framework/vue/basic/readme/":{"data":{"vue-语法#Vue 语法":"Vue 语法Vue 学习曲线平缓，容易上手，这里做一个学习笔记。并根据官网和《Vue.js实战》一书中的例子，进行练习实践， 练习代码放在GitHub上。","vue数据双向绑定#Vue数据双向绑定":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eData binder demo\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" v-model=\"name\" placeholder=\"Please enter your name\"\u003e \u003ch1\u003eHello, {{name}}\u003c/h1\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e //创建vue实例 app var app = new Vue({ el: \"#app\", //el指定挂载的DOM元素，也可以是 document.getElementByld('app') data: { name: \"\" } }); //可以通过app.name 来访问data对象里的所有属性。 console.log(app.name); //可以通过app.$el 来访问该元素。 console.log(app.$el); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 效果如图： 上面的代码在input标签上，有一个v-model，它的值对应于我们Vue 实例的data选项中的name字段，这就是数据绑定。 Vue 实例的data选项，用来声明需要双向绑定的数据。当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。 当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 **只有当实例被创建时 data 中存在的属性才是响应式的。**也就是说如果你添加一个新的属性，例如：\napp.age = 18; 那么对app.age属性的改动将不会触发任何视图的更新。所以如果需要双向绑定的数值，如果初始化时它为空或者不存在，就给它设置一个初始的值。\n数据驱动DOM 是Vue.js的核心理念，所以尽量不要主动操作DOM。 所有会用到的数据都应该预先在data内声明，这样不至于将数据散落在业务逻辑中，难以维护。\n生命周期 创建Vue实例，会有一个初始化的过程，例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时会调用响应的生命周期的钩子。 可以利用钩子函数，在不同的阶段，添加自己的业务逻辑。\n官网的生命周期图示 常用的钩子有：\ncreated，实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载，$el 还不可用。需要初始化处理一些数据时会比较有用。 mounted，el 挂载到实例上后调用，一般业务逻辑会在这里开始。 beforeDestroyed，实例销毁之前调用。主要解绑一些使用addEventListener 监听的事件等。 new Vue({ data: { name: \"xiaoming\" }, created: function () { console.log('Hello: ' + this.name); } mounted: function () { console.log('Hello: ' + this.name); } }) // =\u003e \"a is: 1\" 生命周期钩子的 this 上下文指向调用它的 Vue 实例。 不要在选项属性或回调上使用箭头函数，因为箭头函数会绑定this的指向。 经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。\n模板语法 插值 文本 Mustache语法 (双大括号)是最基本的插值方法，会自动将双向绑定的数据实现显示。\n\u003cdiv id=\"app\"\u003e \u003ch1\u003eHello, {{name}}\u003c/h1\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { name: \"pooky\" } }); \u003c/script\u003e 使用v-once指令，可以执行一次性地插值，当数据改变时，插值处的内容不会更新。\n\u003cspan v-once\u003e这个值不会改变: {{ msg }}\u003c/span\u003e 插入html 如果想输出HTML，而不是解释后的文本使用v-html:\n\u003cdiv id=\"app\"\u003e \u003cspan v-html=\"link\"\u003e\u003c/span\u003e \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { link: '\u003ca href=\"#\"\u003e这是一个连接\u003c/a\u003e' } }); \u003c/script\u003e 动态渲染的 HTML 很容易导致 XSS 攻击。。\n如果想显示双括号标签，而不进行替换，使用\"v-pre\"，这个指令，可以跳过这个元素和子元素的编译过程。\n\u003cspan v-pre\u003e{{不会编译的内容}}\u003c/span\u003e v-bind 双括号插值的方式是不能用到html标签的属性上，如果需要可以使用v-bind:\n\u003cdiv v-bind:id=\"dynamicId\"\u003e\u003c/div\u003e 在布尔特性的情况下：\n\u003cbutton v-bind:disabled=\"isButtonDisabled\"\u003eButton\u003c/button\u003e 如果isButtonDisabled的值是 null、undefined或false，则disabled特性甚至不会被包含在渲染出来的\u003cbutton\u003e元素中。\nJavaScript 表达式 除了简单的绑定属性键值，还可以使用JavaScript 表达式：\n\u003cdiv id=\"app\"\u003e {{number + 1}} {{ ok ? \"yes\" : \"no\" }} {{ msg.split(\",\")}} \u003c/div\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { number: 18, ok: \"yes\", msg: \"hello, Vue\" } }); \u003c/script\u003e 过滤器 Vue支持在双括号插值的后面加上|管道符对数据过滤，例如对时间格式转换把浏览器默认格式2017-01-02T14:04:49.470Z， 转换为2017-01-02 22:04:49，或者字母大小转换：\n\u003cdiv id=\"app\"\u003e {{date | formatDate}} \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var padDate = function (value) { return value \u003c 10 ? \"0\" + value: value; }; var app = new Vue({ el: \"#app\", data: { date: new Date() }, filters: { formatDate: function (value) { //value 就是需要过滤的数据 var date= new Date(value); var year= date.getFullYear() ; var month= padDate(date.getMonth() + 1) ; var day= padDate(date.getDate()); var hours= padDate(date.getHours()); var minutes = padDate (date.getMinutes ()); var seconds = padDate (date.getSeconds ()); //将整理好的数据返回出去 return year + \"-\" + month + \"-\" + day +\" \"+ hours + \":\" + minutes + \":\"+ seconds ; } }, mounted: function () { var self = this; this.timer = setInterval(function () { self.date = new Date(); }, 1000) }, beforeDestoryed: function () { if (this.timer) { clearInterval(this.timer); } } }); \u003c/script\u003e 过滤器可以串联和接受参数：\n{{msg| filtera | filterb}} {{msg| filtera(\"arg1\", arg2)}} ‘filtera’被定义为接收三个参数的过滤器函数。其中’msg’的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式’arg2’的值作为第三个参数。\n还可以创建 Vue 实例之前定义全局过滤器：\nVue.filter('globalFilter', function (value) { if (!value) return '' return value.toString(); }) new Vue({ // ... }) 指令 在Vue中指令是带有v-的特殊属性，比如：v-if，v-for，v-html这些都是指令，指令的职责就是当javascript表达式的值改变时，响应的作用于DOM上。\n\u003cdiv id=\"app\"\u003e \u003cspan v-if=\"show\"\u003e显示的内容\u003c/span\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { show: true } }) \u003c/script\u003e v-bind和v-on\nv-bind指令可以用于响应式地更新 HTML 属性:\n\u003ca v-bind:href=\"url\"\u003e...\u003c/a\u003e 这里的v-bind后面的冒号跟了一个href，这表示一个参数，该元素的 href 属性与表达式 url 的值绑定。\nv-on指令可以用来绑定监听事件:\n\u003cdiv id=\"app\"\u003e \u003cspan v-if=\"show\"\u003e显示的内容\u003c/span\u003e \u003cbutton v-on:click=\"clickHandler\"\u003e隐藏\u003c/button\u003e \u003c/div\u003e \u003cscript src=\"https://unpkg.com/vue@2.5.15/dist/vue.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { show: true }, methods: { clickHandler: function () { this.hide(); //Vue将methods 里的方法也代理了，所以也可以像访问Vue 数据那样来调用方法。 }, hide: function () { this.show = false; } } }) \u003c/script\u003e 这里使用v-on:click 给该元素绑定了一个点击事件。\n缩写\n\u003c!-- 完整语法 --\u003e \u003ca v-bind:href=\"url\"\u003e...\u003c/a\u003e \u003c!-- 缩写 --\u003e \u003ca :href=\"url\"\u003e...\u003c/a\u003e \u003c!-- 完整语法 --\u003e \u003ca v-on:click=\"doSomething\"\u003e...\u003c/a\u003e \u003c!-- 缩写 --\u003e \u003ca @click=\"doSomething\"\u003e...\u003c/a\u003e ","总结#总结":" 只有当实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，比如data: {name: xiaoming}，在创建实例后，添加app.age = 18， 这里的age属性，的改动将不会触发任何视图的更新。所以如果需要双向绑定的数值，如果初始化时它为空或者不存在，就给它设置一个初始的值。 所有会用到的数据都应该预先在data内声明，这样不至于将数据散落在业务逻辑中，难以维护。 数据驱动 DOM 是Vue.js的核心理念，所以尽量不要主动操作 DOM。 常用钩子函数： created，实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载，$el 还不可用。需要初始化处理一些数据时会比较有用。 mounted，el 挂载到实例上后调用，一般业务逻辑会在这里开始。 beforeDestroyed，实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等。 生命周期钩子的 this 上下文指向调用它的 Vue 实例。 不要在选项属性或回调上使用箭头函数，因为箭头函数会绑定 this 的指向，会导致Uncaught TypeError: Cannot read property of undefined 或Uncaught TypeError: this.myMethod is not a function 之类的错误。 插值： 双括号插值 v-html v-bind 双括号插值的方式是不能用到html标签的属性上，如果需要可以使用v-bind 如果v-bind的值是 null、undefined或false，则绑定的特性甚至不会被包含在渲染出来的元素中。 全局过滤器和局部过滤器，Vue 支持在双括号插值的后面加上|管道符对数据过滤 v-bind，缩写：:，v-on，缩写@ ","简单介绍#简单介绍":"关于Vue，不多介绍，可自己查看官方完档。\nVue提供了web开发中常见的高级功能：\n解耦视图与数据 可复用的组件 前端路由 状态管理 虚拟DOM 什么是MVVM MVVM(Model-View-View-Model)模式是由MVC衍生出来的。当View （视图层）变化时，会自动更新到ViewModel （视图模型）， 反之亦然。View 和ViewModel 之间通过双向绑定（data-binding ）建立联系。"},"title":"README"},"/frontend-learn/docs/framework/vue/basic/render/":{"data":{"createelement-参数#createElement 参数":"","data-对象#data 对象":"Vue render 函数Vue 2.x使用了虚拟DOM，虚拟DOM本质上是一个JavaScript对象，在状态变化是，虚拟DOM会进行diff计算，更新需要被替换的DOM，而不会重新渲染整个页面。\n使用 render 函数：\n\u003ch1\u003e \u003ca name=\"hello-bue\" href=\"#hello-vue\"\u003e Hello Vue! \u003c/a\u003e \u003c/h1\u003e 上面的代码，我们使用组件实现：\n\u003cmy-component :level=\"1\"\u003eHello Vue!\u003c/my-component\u003e \u003cscript type=\"text/x-template\" id=\"my-component-template\"\u003e \u003ch1 v-if=\"level === 1\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h1\u003e \u003ch2 v-else-if=\"level === 2\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h2\u003e \u003ch3 v-else-if=\"level === 3\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h3\u003e \u003ch4 v-else-if=\"level === 4\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h4\u003e \u003ch5 v-else-if=\"level === 5\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h5\u003e \u003ch6 v-else-if=\"level === 6\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h6\u003e \u003c/script\u003e Vue.component('my-component', { template: '#my-component-template', props: { level: { type: Number, required: true } } }) 上面的代码实现了我们想要的效果，但是代码冗长，重复使用\u003cslot\u003e元素，如果用render函数：\nVue.component('my-component', { render: function (createElement) { return createElement( 'h' + this.level, this.$slots.default ) }, props: { level: { type: Number, required: true } } }) 这样的实现就精简很多。\n虚拟DOM \u003cdiv\u003e \u003ch1\u003eMy virtual dom\u003c/h1\u003e content \u003c/div\u003e 上面的HTML，当浏览器读到这些代码，它会创建一个节点树，每一个元素都是节点，文字内容也是节点，包括注释，每个节点还有自己的子节点。 Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。请仔细看这行代码：\nreturn createElement('h1', this.blogTitle) createElement返回的其实不是一个实际的 DOM 元素，而是一个节点的描述对象。它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点及其子节点。 这样的节点叫做\"虚拟节点 (Virtual Node)\"\"，简写为\"VNode\"。“虚拟 DOM\"是由 Vue 组件树建立起来的整个 VNode 树的称呼。\ncreateElement 参数 // @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数，必要参数。 'div', // {Object} // 一个包含模板相关属性的数据对象 // 这样，您可以在 template 中使用这些属性。可选参数。 { // (详情见下一节) }, // {String | Array} // 子节点 (VNodes)，由 `createElement()` 构建而成， // 或使用字符串来生成“文本节点”。可选参数。 [ '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp: 'foobar' } }) ] ) data 对象 { // 和`v-bind:class`一样的 API 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API style: { color: 'red', fontSize: '14px' }, // 正常的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅对于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // Scoped slots in the form of // { name: props =\u003e VNode | Array\u003cVNode\u003e } scopedSlots: { default: props =\u003e createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef' } ","vue-render-函数#Vue render 函数":"","使用javascript#使用JavaScript":"v-if,v-for 在vue中，像v-if, v-for，这些指令，用JavaScript实现会更简单：\n\u003cul v-if=\"items.length\"\u003e \u003cli v-for=\"item in items\"\u003e{{ item.name }}\u003c/li\u003e \u003c/ul\u003e \u003cp v-else\u003eNo items found.\u003c/p\u003e 上面的代码如果使用render函数：\nprops: ['items'], render: function (createElement) { if (this.items.length) { return createElement('ul', this.items.map(function (item) { return createElement('li', item.name) })) } else { return createElement('p', 'No items found.') } } v-model render函数没有实现与v-model相应的 api，所以要自己实现：\nprops: ['value'], render: function (createElement) { var self = this return createElement('input', { domProps: { value: self.value }, on: { input: function (event) { self.$emit('input', event.target.value) } } }) } ","约束#约束":"组件树中的所有 VNodes 必须是唯一的。这意味着，下面的使用是错误的：\nrender: function (createElement) { var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ]) } 那么需要多个重复的组件、元素，可以使用工厂函数来实现。\nrender: function (createElement) { return createElement('div', Array.apply(null, { length: 20 }).map(function () { return createElement('p', 'hi') }) ) } ","虚拟dom#虚拟DOM":""},"title":"render"},"/frontend-learn/docs/framework/vue/basic/vue_router/":{"data":{"h5-history-模式#H5 History 模式":" const RouterConfig = { mode: 'history', routes: Routers }; const router = new VueRouter(RouterConfig); 当你使用 history 模式时，URL 就像正常的 url，例如http://website.com/bot/name，也好看！ 不过这种模式需要后台配置支持。服务端将所有路由都指向同一个html，如果 URL 匹配不到任何静态资源，则应该返回同一个index.html页面，否则刷新时页面会出现404。\nconst http = require('http') const fs = require('fs') const httpPort = 80 http.createServer((req, res) =\u003e { fs.readFile('index.html', 'utf-8', (err, content) =\u003e { if (err) { console.log('We cannot open \"index.htm\" file.') } res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' }) res.end(content) }) }).listen(httpPort, () =\u003e { console.log('Server listening on: http://localhost:%s', httpPort) }) 对于 Node.js/Express，推荐使用 connect-history-api-fallback 中间件。\n这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况， 然后在给出一个404页面。\nconst router = new VueRouter({ mode: 'history', routes: [ { path: '*', component: NotFoundComponent } ] }) ","usage#Usage":"","vue-router#vue-router":"","优先级#优先级":"","别名#别名":"","安装#安装":"","懒加载#懒加载":"实现路由组件的懒加载:\n将异步组件定义为返回一个 Promise 的工厂函数 const Foo = () =\u003e Promise.resolve({ /* 组件定义对象 */ }) 使用动态 import语法来定义代码分块点 import('./Foo.vue') // 返回 Promise const Foo = () =\u003e import('./Foo.vue') // 把组件按组分块 一个特殊的注释语法来提供 chunk name const Foo = () =\u003e import(/* webpackChunkName: \"group-foo\" */ './Foo.vue') const Bar = () =\u003e import(/* webpackChunkName: \"group-foo\" */ './Bar.vue') ","数据获取#数据获取":"有时候，进入某个路由后，需要从服务器获取数据。我们可以通过两种方式来实现：\n导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示loading之类的指示。 导航完成之前获取：导航完成前（beforeRouteEnter），在路由进入的守卫中获取数据，在数据获取成功后执行导航。 ","滚动行为#滚动行为":"scrollBehavior定义切换到新路由时的滚动位置。\nconst router = new VueRouter({ routes: [...], scrollBehavior (to, from, savedPosition) { // return 期望滚动到哪个的位置 } }) savedPosition通过浏览器的 前进/后退 按钮触发时才可用。 更多查看官方文档。","监测路由变化#监测路由变化":"","视图命名#视图命名":"","路径参数#路径参数":"","路由元信息#路由元信息":" const routers = [ { path: '/list', meta: { title: 'My Bots' }, component: (resolve) =\u003e require(['./views/list.vue'], resolve) }, { path: '/add', meta: { title: 'Add Bot' }, component: (resolve) =\u003e require(['./views/add.vue'], resolve) } ]; 在钩子函数中可以通过to.meta.some来访问。","路由命名#路由命名":"","路由嵌套#路由嵌套":"","路由组件prop#路由组件\u003ccode\u003eprop\u003c/code\u003e":"vue-routervue-router是Vue官方的核心插件之一，用来实现单页面应用(SPA)。\n实现单页面应用的核心就是前端路由。SPA其实就是在前后端分离的基础上，加一层前端路由。 前端路由实现的方式有两种，url的hash，js通过hashChange事件监听url的改变。 另一种是H5的history模式。\n安装 npm install vue-router //main.js import Vue from 'vue' import VueRouter from 'vue-router' Vue.use(VueRouter) Usage 将组件(components)映射到路由(routes):\n//html \u003cdiv id=\"app\"\u003e \u003crouter-link to=\"/list\" class=\"header-title\"\u003eChapOps\u003c/router-link\u003e \u003crouter-link to=\"/add\" class=\"header-title\"\u003eAdd\u003c/router-link\u003e \u003c/div\u003e \u003crouter-view\u003e\u003c/router-view\u003e //main.js 路由配置 import Vue from 'vue' import VueRouter from 'vue-router' const RouterConfig = { // 使用 H5 的 History 模式 mode: 'history', routes: Routers }; const router = new VueRouter(RouterConfig); const app = new Vue({ el: \"#app\", router }) //router.js 定义路由 const routers = [ { path: '/list', meta: { title: 'My Bots' }, component: (resolve) =\u003e require(['./views/list.vue'], resolve) }, { path: '/add', meta: { title: 'Add Bot' }, component: (resolve) =\u003e require(['./views/add.vue'], resolve) }, { path: '*', redirect: '/list' } ]; export default routers; 通过注入路由器，我们可以在任何组件内通过this.$router访问路由器，使用this.$router的就不需要在封装路由的组件中都导入路由。 最后一个path为*的路由，是为了当访问路径不存在时，访问list页面。\n上面的写法，webpack会把每个路由打包，请求到该页面时才会加载，也就是懒加载（按需加载），如果需要一次性加载：\n{ path: '/add', component: require('./views/add.vue') } 路由懒加载在webpack打包后可能会抛出404的错误，改写成resolve =\u003e require.ensure([], () =\u003e resolve(require('../views/BotList.vue')), 'chatops-view') 之后，问题解决。把所有组件都打包在同个异步chunk中，只需要给chunk命名，提供require.ensure第三个参数作为chunk的名称 ，Webpack 将相同chunk下的所有异步模块打包到一个异步块里面。\n路径参数 在路由路径中使用参数：\nconst routers = [ { path: '/bot/:name', component: bot } ]; 路径参数使用冒号:标记。参数值会被设置到this.$route.params。用上面的代码距离，当url/bot/testBot匹配到路由时， 可以通过this.$route.params.name访问。\n监测路由变化 当使用路由参数时，例如从/user/foo导航到/user/bar，原来的组件实例会被复用。由于组件被复用，组件的生命周期钩子不会再被调用。 所以这是想要对参数变化做出响应可以使用侦听属性：\nconst bot = { template: '...', watch: { '$route' (to, from) { // do someTing... } } } 优先级 同一个路径可以匹配多个路由，优先级按照路由的定义顺序：谁先定义的，谁的优先级就最高。\n路由嵌套 上面的例子里\u003crouter-view\u003e是用来渲染路由匹配到的组件，同样地，一个被渲染组件同样可以包含自己的嵌套 \u003crouter-view\u003e，例如：\nconst bot = { template: '\u003cdiv\u003e \u003ch2\u003eBot {{ $route.params.name }}\u003c/h2\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e', } 要在嵌套的\u003crouter-view\u003e中渲染组件，还需要配置children参数：\nconst routers = [ { path: '/bot/:name', component: bot, children: [ { // /bot/:name/env 匹配成功， // botEnv 会被渲染在 bot 的 \u003crouter-view\u003e 中 path: 'env', component: botEnv }, { path: '', component: bot }, ] } ]; 上面的配置，有一个path为空字符串的子理由，如果没有配置这个子路由，当访问/bot/testBot 时，不会渲染任何东西，因为没有匹配到合适的子路由。\n以/开头的嵌套路径会被当作根路径。\n路由跳转 两种方式，一种是使用\u003crouter-link\u003e：\n\u003cdiv id=\"app\"\u003e \u003crouter-link to=\"/list\" class=\"header-title\"\u003eChapOps\u003c/router-link\u003e \u003crouter-link to=\"/add\" class=\"header-title\"\u003eAdd\u003c/router-link\u003e \u003c/div\u003e 上面的to是一个prop，指定要跳转的path。 router-link还有一些其他的prop：\ntag，默认值: a，指定router-link渲染成某种标签，例如\u003cli\u003e。同样它还是会监听点击，触发导航。 replace，下面会介绍。 active-class，默认值: router-link-active，当路由匹配成功时，自动给当前元素添加一个router-link-activeclass。可以通过设置active-class修改class。 使用\u003crouter-link\u003e，在H5的history模式下会拦截点击，避免浏览器重新加载。\n如果要在JavaScript中跳转，就要使用router.push或者this.$router.push：\nexport default { name: \"app\", mounted() { this.$router.push({ path: \"list\"}); } } router.push router-link用法 // 字符串 router.push('home') // 对象 router.push({ path: 'home' }) // 命名的路由 router.push({ name: 'user', params: { userId: 123 }}) // 带查询参数，变成 /register?plan=private router.push({ path: 'register', query: { plan: 'private' }}) // 如果提供了 path，params 会被忽略,这里的 params 不生效 router.push({ path: '/user', params: { userId }}) // -\u003e /user 同样的规则也适用于router-link组件的to属性。\nreplace router.replace和router.push的区别就是，router.replace不会向history添加新记录，而是替换掉当前的history记录。 \u003crouter-link :to=\"...\" replace\u003e和router.replace(...)的效果是一样的\ngo router.go(n)方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似window.history.go(n)。\n路由命名 const routers = [ { path: '/bot/:name', name: bot, component: bot } ]; //调用 this.$router.push({ name: 'bot', params: { name: \"testBot\" }}) // 或者 \u003crouter-link :to=\"{ name: 'bot', params: { name: 123 }}\"\u003eBot\u003c/router-link\u003e 视图命名 如果需要同时（同级）展示多个视图，就需要给视图命名：\n\u003crouter-view\u003e\u003c/router-view\u003e \u003crouter-view name=\"one\"\u003e\u003c/router-view\u003e \u003crouter-view name=\"two\"\u003e\u003c/router-view\u003e 如果router-view没有设置名字，默认为default。 多个视图就需要多个组件:\nconst routers = [ { path: '/bot/:name', name: bot, components: { default: bot, one: One, two: Two } } ]; 在嵌套路由中也可以使用视图命名。\n重定向 const routers = [ { path: '/bot/:name', redirect: \"/list\" } ]; //重定向的目标也可以是一个命名的路由 const routers = [ { path: '/bot/:name', redirect: {name: \"list\"} } ]; //还可以是一个函数，返回重定向的路径 const routers = [ { path: '/bot/:name', redirect: (to) =\u003e { // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 return ... } } ]; 别名 /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。\nconst routers = [ { path: '/a', component: A, alias: '/b' } ]; 路由组件prop const User = { template: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e' } const router = new VueRouter({ routes: [ { path: '/user/:id', component: User } ] }) 上面的代码，使用$route，组件和路由高度解耦，可以通过props解耦:\nconst User = { props: ['id'], template: '\u003cdiv\u003eUser {{ id }}\u003c/div\u003e' } const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, props: true }, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： { path: '/user/:id', components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false } } ] }) 这里的props被设置为true，$route.params将会被设置为组件属性。props还可以是一个对象，它会被按原样设置为组件属性。也可以是一个函数\nconst router = new VueRouter({ routes: [ { path: '/promotion/from-newsletter', component: Promotion, props: { newsletterPopup: false } } ] }) const router = new VueRouter({ routes: [ { path: '/search', component: SearchUser, props: (route) =\u003e ({ query: route.query.q }) } ] }) ","路由跳转#路由跳转":"","过渡动效#过渡动效":" 是基本的动态组件，所以我们可以用 组件给它添加一些过渡效果：\n\u003ctransition\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/transition\u003e ","重定向#重定向":"","钩子#钩子":"导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 beforeEach afterEach beforeEach 和 afterEach ，它们会在路由即将改变前和改变后触发，钩子函数有3个参数：\nto，即将要进入的目标的路由对象 from，当前导航即将要离开的路由对象 next，调用该方法后，才能进入下一个钩子。 其他钩子函数查看官方文档"},"title":"vue_router"},"/frontend-learn/docs/framework/vue/basic/vuex/":{"data":{"action#action":"上面已经知道，mutation只能是同步的，如果需要异步操作数据，就使用actions。action 与mutation 很像，区别：\naction 提交的是 mutation，而不是直接变更状态。 action 可以包含异步操作。 改变数据就用mutation，存在业务逻辑，就用action。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state, n = 1) { state.count += n; } }, actions: { increment (context, payload) { context.commit('increment', payload.num); }, asyncIncrement (context) { return new Promise(resolve =\u003e { setTimeout(() =\u003e { context.commit('increment'); resolve(); }, 1000) }); } } }); 上面代码中的context对象具有store 实例对象的属性和方法，但是不是 store 实例本身。可以访问context.state 和 context.getters。\naction的通过$store.dispatch方法触发:\nthis.$store.dispatch('increment', {num: 2}); this.$store.dispatch('asyncIncrement').then(() =\u003e { console.log(this.$store.state.count); }); mapActions action的辅助函数mapActions ，不多介绍。\n在 action 中也可以触发另外一个 action：\nactions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() =\u003e { commit('someOtherMutation') }) } } ","getter#getter":"如果下面的代码中，要对数组list过滤出小于10的数据：\nstate: { list: [1, 9, 8, 10, 21, 7] } computed: { list () { return this.$state.list.filter(item =\u003e item \u003c 10); } } 计算属性可以很简单的实现，但是如果在多个组件中都需要过滤，那就要把代码复制多份，这个时候就可以使用getter：\nconst store = new Vuex.Store({ state: { list: [1, 5, 8, 10, 30, 50] }, getters: { filteredList: state =\u003e { return state.list.filter(item =\u003e item \u003c 10); } } }); //访问getter export default { computed: { list () { return this.$store.getters.filteredList; } } } getter 也可以依赖其他的getter ，把getter 作为第二个参数。\ngetters: { listLength: (state, getters) =\u003e { return getters.filteredList.length; } } 传参 getter函数不能直接传参数，但是可以通过让 getter 返回一个函数，来实现给 getter 传参。对 store 里的数据进行查询时非常有用：\ngetters: { // ... getBotByName: (state) =\u003e (name) =\u003e { return state.botList.find((bot) =\u003e { bot.name === name }) } } $store.getters.getBotByName(\"test\") mapGetters getter有自己的辅助函数mapGetters，不多介绍了。","module#module":"对于大型应用，store 文件太大，就可以分割成多个模块。在结构介绍。","mutation#mutation":"提交 mutation 是更改状态的唯一方法，通过 this.$store.commit方法来提交，上面已经简单的使用了mutation，mutation还可以接受第二个参数(payload)，\nmutations: { add (state, n = 1) { state.count += n; } } //提交mutation this.$store.commit(\"add\", 2); 当要传入的参数比较多时，payload可以传入对象。\nmutations: { commit (state, payload) { state.name = payload.name; } } this.$store.commit(\"commit\", { name: \"xiaoming\", age: 18 }); Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项:\n提前在你的 store 中初始化好所有所需属性 要在对象上添加新属性时，应该使用 vue.set，或以新对象替换老对象。 使用常量替代 Mutation 事件类型 使用常量替代 mutation 事件类型，并把这些常量放在单独的文件中：\n// mutation-types.js const TEST_MUTATION = 'TEST_MUTATION' export { TEST_MUTATION } // store.js import Vuex from 'content/docs/vue/basic/vuex' import {TEST_MUTATION} from './mutation-types' const store = new Vuex.Store({ state: {...}, mutations: { [TEST_MUTATION](state) { // mutate state } } }) mapMutations mapMutations 辅助函数将组件中的 methods 映射为 $store.commit 调用：\nimport { mapMutations } from 'vuex' export default { // ... methods: { ...mapMutations([ 'increment', // `this.increment()` 映射为 `this.$store.commit('increment')` ]), ...mapMutations({ add: 'increment' // `this.add()` 映射为 `this.$store.commit('increment')` }) } } Mutation 必须是同步函数，因为如果mutation是异步，当mutation 触发的时候回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用， 任何在回调函数中进行的状态的改变都是不可追踪的。","state#state":"Vuex 使用单一状态树，应用层级的状态应该集中到单个 store 对象中。\nconst app = new Vue({ el: '#app', // 把 store 的实例注入所有的子组件 store }) 通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中，且子组件能通过this.$store访问到。\nmapState 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。 mapState辅助函数帮助我们生成计算属性:\nimport {mapState} from 'content/docs/framework/vue/basic/vuex' export default { // ... computed: mapState({ // 箭头函数可使代码更简练 count: state =\u003e state.count, // 传字符串参数 'count' 等同于 `state =\u003e state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState(state) { return state.count + this.localCount } }) } //也可以给 mapState 传一个字符串数组 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) ","vuex#Vuex":"VuexVuex 是一个Vue状态管理插件。","介绍#介绍":"当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：\n多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。 以上的这些模式非常脆弱，通常会导致无法维护的代码。\n因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\n另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。\nVuex有五个核心概念，分别是：\nState Getter Mutation Action Module Vuex的核心就是store（仓库），store包含了大部分的应用的数据（状态）。Vuex里面的数据都是响应式的，任何组件使用同一个store里面的数据时，只要store的数据变化， 相应的组件也会更新。Vuex不能直接改变store中的数据，改变store数据的唯一途径就是显示的提交（commit）mutation。没有为什么，就是一个约定，是因为我们想要更明确 地追踪到状态的变化。这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。\nconst store = new Vuex.Store({ state: { count: \"test\" }, mutations: { add (state) { state.count ++; }, reduce (state) { state.count --; } } }) 上面的代码创建了一个store，数据保存在state属性中，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可：\n\u003ctemplate\u003e \u003cdiv\u003e {{$store.state.count}} {{count}} \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { computed: { count() { return this.$store.state.count; }, }, methods: { handleAdd() { this.$store.commit(\"add\"); }, handleReduce() { this.$store.commit(\"reduce\"); }, } } \u003c/script\u003e 由于不能直接改变store中的数据，我们可以在上面的代码中还添加了两个mutations， 在methods中通过 this.$store.commit方法来提交执行mutation。","其他#其他":"插件 Vuex 的 store 的 plugins 选项，可以添加插件。具体使用查看官网文档\n严格模式 开启严格模式：\nconst store = new Vuex.Store({ // ... strict: true }) 严格模式下，不是由 mutation 函数引起的状态变更会抛出错误。会影响性能，建议在开发环境下使用。\n表单 使用 Vuex 时，如果使用v-model绑定state中的数据会比较麻烦，因为使用v-model双向绑定数据，用户在input输入时会尝试修改state， 这在Vuex的严格模式中是会抛出错误的，因为state的数据只能在mutation中修改。\n有两种方式可以解决上面的问题：\n双向绑定计算属性 不使用v-model，v-model只是一个语法糖，可以直接使用@input=\"handleInput\"监听input事件，并使用:value给表单元素绑定value，在handleInput函数中 提交mutation。 我比较常用的方式是第一种，给计算属性添加getter和setter：\n\u003cbot-input v-model=\"volumeType\"\u003e\u003c/bot-input\u003e computed: { volumeType: { get () { return this.$store.state.currentData.volume.type; }, set (value, oldVal) { this.$store.commit('updateCurrentData', {volume: {type: value}}); } } } 具体使用查看官网文档","安装#安装":" npm install vuex --save import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) ","结构#结构":"使用 Vuex 需要遵守的规则：\n应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 如果你的 store 文件太大，可以将 action、mutation 和 getter 分割到单独的文件。\n对于大型应用，可以把 Vuex 相关代码分割到模块中：\n├── index.html ├── main.js ├── api │ └── ... # API ├── components │ ├── App.vue │ └── ... └── store ├── index.js # store ├── actions.js # 根级别的action ├── mutations.js # 根级别的mutation └── modules ├── a.js # a模块 └── b.js # b模块 //main.js： import Vue from 'vue' import App from './components/App.vue' import store from './store' new Vue({ el: '#app', store, render: h =\u003e h(App) }) //index.js import Vue from 'vue' import Vuex from 'vuex' import a from './modules/a' import b from './modules/b' Vue.use(Vuex) export default new Vuex.Store({ modules: { a, b } }) //a.js const state = { count: 0 } const getters = { render (state) { }, } const actions = { increment ({ commit, state }, {}) { } } const mutations = { increment (state) { } } export default { state, getters, actions, mutations } 命名空间 可以添加 namespaced: true 给模块添加命名空间，否则模块内部的 action、mutation 和 getter会注册到全局。这样可能导致拥有同一 mutation 或 action 的多个模块都能够对作出响应。\nconst store = new Vuex.Store({ modules: { account: { namespaced: true, // 模块内容（module assets） state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: { isAdmin () { ... } // -\u003e getters['account/isAdmin'] }, actions: { login () { ... } // -\u003e dispatch('account/login') }, mutations: { login () { ... } // -\u003e commit('account/login') }, // 嵌套模块 modules: { // 继承父模块的命名空间 myPage: { state: { ... }, getters: { profile () { ... } // -\u003e getters['account/profile'] } }, // 进一步嵌套命名空间 posts: { namespaced: true, state: { ... }, getters: { popular () { ... } // -\u003e getters['account/posts/popular'] } } } } } }) 在局部模块访问全局 在上面的例子中，有a模块和b模块，模块自己的state是局部状态对象，模块内部的 mutation 和 getter的第一个参数state，注意这个state是局部状态对象，而不是根节点的。 模块内部的action，第一个参数context，context.state属性也是局部的，但是可以通过context.rootState访问根节点状态，通过context.rootGetter访问根节点getter。 getter函数要访问根节点状态通过第三个参数，第四个参数是根节点的getter：\nconst moduleA = { // ... getters: { sumWithRootCount (state, getters, rootState, rootGetter ) { return state.count + rootState.count } } } 如果要在全局命名空间内分发 action 或提交 mutation，给 dispatch 或 commit 传入第三参数{ root: true }。\n$store.dispatch('someOtherAction', null, { root: true }) $store.commit('someOtherAction', null, { root: true }) store.registerModule 在 store 创建之后，可以使用 store.registerModule 方法注册模块,`store.unregisterModule(moduleName)`` 来卸载模块\n// 注册模块 `myModule` store.registerModule('myModule', { }) // 注册嵌套模块 `nested/myModule` store.registerModule(['nested', 'myModule'], { }) "},"title":"vuex"},"/frontend-learn/docs/framework/vue/deep/readme/":{"data":{"vue-深入学习#Vue 深入学习":"Vue 深入学习","响应式#响应式":"Vue是一个MVVM框架，Vue的响应式是基于Object.defineProperty的。\n当 render function 被渲染的时候，会读取所需对象的值，这时会触发getter函数进行依赖收集。依赖收集的目的是将观察者Watcher对象 存放到当前闭包中的订阅者Dep的subs中。修改对象时，会触发setter通知Dep中的每个Watcher，值已经改变，调用update方法更新视图。 这中间还有一个 patch 的过程以及使用队列来异步更新的策略。","更新视图#更新视图":"数据变化后，执行 render function 就可以得到一个新的 VNode 节点，新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的差异。 最后只需将这些差异对应的 DOM 进行修改即可。","编译#编译":"编译可以分成parse、optimize与generate三个阶段，编译结束后得到render函数。\nparse parse会用正则等方式解析template模板中的指令、class、style等数据，形成AST（抽象语法树）\noptimize optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程， diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。\ngenerate generate是将AST转化成render函数字符串的过程，得到结果是render的字符串以及staticRenderFns字符串。\n在经历过这三个阶段以后，组件中就会存在渲染VNode所需的render函数了。","虚拟dom#虚拟DOM":"render function 会被转化成 VNode 节点，Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树， 对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。\n{ tag: 'div', /*div标签*/ children: [ /*该标签的子节点*/ { tag: 'a', /*一个a标签*/ text: 'click me' /*标签的内容*/ } ] } 渲染后得到:\n\u003cdiv\u003e \u003ca\u003eclick me\u003c/a\u003e \u003c/div\u003e ","运行机制#运行机制":"初始化 我们知道通过new Vue()得到一个vue实例，既然要了解vue的运行机制，我们就来看看new Vue()到底做了些什么。\nfunction Vue (options) { if (process.env.NODE_ENV !== 'production' \u0026\u0026 !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options) } 这里调用了_init函数进行初始化，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。 其中最重要的是通过Object.defineProperty设置setter与getter函数，对数据进行响应式化以及依赖收集。\n初始化之后会调用$mount，如果这是没有render函数，但是存在template，就会进行编译。"},"title":"README"},"/frontend-learn/docs/framework/vue/deep/responsive/":{"data":{"objectdefineproperty#Object.defineProperty":"Vue最核心的方法便是通过Object.defineProperty()实现对属性的劫持，监听数据变动。先了解一下Object.defineProperty。 Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，用法：\nObject.defineProperty(object, propertyName, attributesObject) //例子 var student = Object.defineProperty({}, 'name', { value: 'xiaoming', writable: false, enumerable: true, configurable: false }); obj.name // 'xiaoming' obj.name = 'xiaogang'; obj.name // 'xiaoming' Object.defineProperty方法有三个参数：\nobject：定义或修改属性的对象(Object) propertyName：属性名（String） attributesObject：属性描述对象(Object) value：属性的值，默认是undefined writable：(Boolean) 属性值是否可写，默认为true enumerable：(Boolean) 属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 configurable：(Boolean) 是否可配置，默认为true。如果设为false，将阻止某些操作，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。 也就是说，configurable属性控制了属性描述对象的可写性。 get：是一个函数，表示该属性的取值函数（getter），默认为undefined。 set：是一个函数，表示该属性的存值函数（setter），默认为undefined。 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。","vue-响应式原理#Vue 响应式原理":"Vue 响应式原理Vue 响应式系统是基于Object.defineProperty实现的，我们先了解一下Object.defineProperty。"},"title":"responsive"},"/frontend-learn/docs/framework/vue/deep/ssr/":{"data":{"spa-single-page-application---单页应用程序#SPA （Single-Page Application - 单页应用程序）":"使用Vue的单页应用有什么好处：\n在客户端管理路由，用户切换路由，无需向服务器重新请求页面和静态资源，只需要使用 ajax 获取数据在客户端完成渲染，这样可以减少了很多不必要的网络传输，缩短了响应时间。 声明式渲染，从烦人的DOM操作中解放出来，集中处理业务逻辑。 组件化视图，无论是功能组件还是UI组件都可以进行抽象，写一次到处用。 前后端并行开发，只需要与后端定好数据格式，前期用模拟数据，就可以与后端并行开发了。 对复杂项目的各个组件之间的数据传递 vue - Vuex 状态管理模式 ","为什么使用服务器端渲染#为什么使用服务器端渲染":"本节介绍摘自 Vue.js 服务器端渲染指南。\n服务器端渲染流程： ","优点#优点":"与传统 SPA相比，服务器端渲染(SSR)的优势主要在于：\n更好的 SEO(Search Engine Optimization)顾名思义就是一系列为了提高 网站收录排名，吸引精准用户的方案。由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。 如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。 也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。 更快的内容到达时间(time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。 无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。 通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。 ","开始使用#开始使用":"安装 npm install vue-server-renderer --save #或者 yarn add vue-server-renderer vue-server-renderer 和 vue 必须匹配版本。\n渲染Vue实例 const Vue = require('vue') const app = new Vue({ template: `\u003cdiv\u003eHello Vue\u003c/div\u003e` }) const renderer = require('vue-server-renderer').createRenderer() //使用回调函数 renderer.renderToString(app, (err, html) =\u003e { if (err) throw err console.log(html); // \u003cdiv data-server-rendered=\"true\"\u003eHello Vue\u003c/div\u003e }) //Promise方式： renderer.renderToString(app).then(html =\u003e { console.log(html); // \u003cdiv data-server-rendered=\"true\"\u003eHello Vue\u003c/div\u003e }).catch(err =\u003e { console.error(err); }) 与Express集成 const Vue = require('vue') const server = require('express')() const renderer = require('vue-server-renderer').createRenderer() server.get('/', (req, res) =\u003e { const app = new Vue({ data: { name: `xiaoming` }, template: `\u003cdiv\u003eHello {{name}}\u003c/div\u003e` }) renderer.renderToString(app, (err, html) =\u003e { if (err) { return res.status(500).end('Internal Server Error'); } res.end(` \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e\u003ctitle\u003eSSR\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e${html}\u003c/body\u003e \u003c/html\u003e `) }) }) server.listen(8080) ","弊端#弊端":" 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数(lifecycle hook)中使用；一些外部扩展库(external library)可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序(SPA)不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源(CPU-intensive - CPU 密集)， 因此如果你预料在高流量环境(high traffic)下使用，请准备相应的服务器负载，并明智地采用缓存策略。 ","服务器端渲染#服务器端渲染":"服务器端渲染服务器端渲染(SSR)，项目中暂时没有用到，所以只学习记录一些概念和简单用法，以后用到在深入学习。"},"title":"ssr"},"/frontend-learn/docs/framework/vue/impl/readme/":{"data":{"mvue#mVue":"","mvue-1#mVue":"","单向数据绑定#单向数据绑定":"","实现双向绑定的方法#实现双向绑定的方法":"","实现思路#实现思路":"","总结#总结":"","效果#效果":"","深入vuedeep#\u003ca href=\"deep/\"\u003e深入Vue\u003c/a\u003e":"mVueVue学习并使用了一段时间，对Vue如何实现双向绑定有了初步的理解，这里参考Vue源码，尝试一步步实现一个简单的MVVM。\n单向数据绑定 现在主流的MVC框架都实现了单向数据绑定，单向数据绑定就是先把模板写好，把模板和数据整合并形成HTML代码， 然后把这段HTML代码插入到文档。但是HTML代码一旦生成以后，就无法再变了，如果数据改变，就必须替换掉HTML代码。\n实现双向绑定的方法 双向绑定，其实就是在单向绑定的基础上给input、textarea等可输入元素添加了change(input)事件，实现动态修改model和view。\n发布订阅模式 （backbone.js） 使用自定义的data属性在HTML代码中指明绑定。所有绑定起来的JavaScript对象以及DOM元素都将订阅一个发布者对象。 如果JavaScript对象或者一个HTML输入字段被侦测到发生了变化，将代理事件到发布者-订阅者模式，反过来将变化广播并传播到所有绑定的对象和元素。\n脏值检查（angular.js） Angular的实现方式，当发生了某种事件（例如输入），Angular会检查新的数据结构和之前的数据结构是否发生了变动，来决定是否更新视图。 最简单的方式就是通过setInterval()定时轮询检测数据变动，Angular只有在下面的事件触发时才会进入脏值检测：\nDOM事件，譬如用户输入文本，点击按钮等。(ng-click) XHR响应事件 ($http) 浏览器Location变更事件 ($location) Timer事件($timeout, $interval) 执行$digest()或$apply() 数据劫持（vue.js） Vue.js则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n实现思路 Object.defineProperty 了解了原理，Vue最核心的方法便是通过Object.defineProperty()实现对属性的劫持，监听数据变动。先了解一下Object.defineProperty。 Object.defineProperty方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，用法：\nObject.defineProperty(object, propertyName, attributesObject) //例子 var student = Object.defineProperty({}, 'name', { value: 'xiaoming', writable: false, enumerable: true, configurable: false }); obj.name // 'xiaoming' obj.name = 'xiaogang'; obj.name // 'xiaoming' Object.defineProperty方法有三个参数：\nobject：定义或修改属性的对象(Object) propertyName：属性名（String） attributesObject：属性描述对象(Object) value：属性的值，默认是undefined writable：(Boolean) 属性值是否可写，默认为true enumerable：(Boolean) 属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 configurable：(Boolean) 是否可配置，默认为true。如果设为false，将阻止某些操作，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。 也就是说，configurable属性控制了属性描述对象的可写性。 get：是一个函数，表示该属性的取值函数（getter），默认为undefined。 set：是一个函数，表示该属性的存值函数（setter），默认为undefined。 注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。\nObserver 上面说到利用Obeject.defineProperty()来监听属性变动，接下来需要实现一个数据监听器Observer，监控data的属性值，如有变动可拿到最新值并通知订阅者。\nfunction Observer(data) { this.data = data; this.walk(data); } Observer.prototype = { walk: function(data) { var self = this; if (!data || typeof data !== 'object') { return; } // 遍历data所有属性 Object.keys(data).forEach(function(key) { self.defineReactive(data, key, data[key]); }); }, defineReactive: function(data, key, value) { var dep = new Dep(); //递归遍历所有子属性 observe(value); //添加 setter和getter Object.defineProperty(data, key, { enumerable: true, configurable: false, get: function () { if (Dep.target) { //js是单线程的，这个全局变量在同一时间只会有同一个监听器使用 dep.addSub(Dep.target); } return value; }, set: function (newValue) { if (newValue === value) { return; } value = newValue; // 通知所有订阅者 dep.notify(); } }); } }; function observe(value) { if (!value || typeof value !== 'object') { return; } return new Observer(value); } 上面的代码中，定义了一个observer类，参数是data属性，递归遍历data的属性，并利用Obeject.defineProperty()劫持属性。 在getter和setter函数中，有一个Dep对象，Dep对象作为一个收集订阅者的容器，实现了订阅发布模式（一对多），当状态发生改变时就会通知所有订阅者对象。实现如下：\nfunction Dep () { this.subs = []; } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; Dep.target = null; Compile 接下来需要实现一个解析器Compile来做解析和绑定工作：\n解析模板指令(v-model)，并替换模板数据(双大括号)，初始化视图 将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器 解析模板，需要获取到dom元素，然后对含有DOM元素上含有指令的节点进行处理，因此需要对DOM操作比较频繁，操作DocumentFragment节点，要比直接操作DOM快得多， 所以为提高性能和效率，可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理：\nfunction Compile(el, vm) { this.vm = vm; this.el = this.isElementNode(el) ? el : document.querySelector(el); this.fragment = null; this.init(); } Compile.prototype = { init: function () { if (this.el) { this.fragment = this.nodeToFragment(this.el); this.compileElement(this.fragment); this.el.appendChild(this.fragment); } else { console.log('Cannot find the element.'); } }, nodeToFragment: function (el) { var fragment = document.createDocumentFragment(); var child = el.firstChild; // 将Dom节点拷贝到fragment中 while (child) { fragment.appendChild(child); child = el.firstChild } return fragment; }, }; 在compileElement方法中，先解析含有双大括号的变量：\ncompileElement: function (el) { var childNodes = el.childNodes; var self = this; [].slice.call(childNodes).forEach(function(node) { var reg = /\\{\\{(.*)\\}\\}/; var text = node.textContent; if (self.isElementNode(node)) { self.compile(node); } else if (self.isTextNode(node) \u0026\u0026 reg.test(text)) { // 判断是否是符合这种形式{{}}的指令 self.compileText(node, reg.exec(text)[1]); } if (node.childNodes \u0026\u0026 node.childNodes.length) { self.compileElement(node); } }); }, compile: function(node) { var nodeAttrs = node.attributes; var self = this; Array.prototype.forEach.call(nodeAttrs, function(attr) { var attrName = attr.name; if (self.isDirective(attrName)) { var exp = attr.value; var dir = attrName.substring(2); if (self.isEventDirective(dir)) { // 事件指令 self.compileEvent(node, self.vm, exp, dir); } else { // v-model 指令 self.compileModel(node, self.vm, exp, dir); } node.removeAttribute(attrName); } }); }, compileText: function(node, exp) { var self = this; var initText = this.vm[exp]; this.updateText(node, initText); new Watcher(this.vm, exp, function (value) { self.updateText(node, value); }); }, compileModel: function (node, vm, exp, dir) { var self = this; var val = this.vm[exp]; this.modelUpdater(node, val); new Watcher(this.vm, exp, function (value) { self.modelUpdater(node, value); }); node.addEventListener('input', function(e) { var newValue = e.target.value; if (val === newValue) { return; } self.vm[exp] = newValue; val = newValue; }); }, isElementNode: function (node) { return node.nodeType === 1; }, isTextNode: function(node) { return node.nodeType === 3; } watcher 订阅者Watcher在初始化的时候需要将自己添加进订阅器Dep中\nfunction Watcher(vm, exp, cb) { this.cb = cb; this.vm = vm; this.exp = exp; this.value = this.get(); // 将自己添加到订阅器的操作 } Watcher.prototype = { update: function() { // 收到属性值变化的通知 this.run(); }, run: function() { var value = this.get();// 获取最新值 var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); } }, get: function() { Dep.target = this; // 缓存当前Watcher对象 var value = this.vm.data[this.exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 释放Watcher对象 return value; } }; mVue function mVue (options) { var self = this; this.data = options.data; this.methods = options.methods; Object.keys(this.data).forEach(function(key) { self.proxyKeys(key); }); observe(this.data); new Compile(options.el, this); } mVue.prototype = { proxyKeys: function (key) { var self = this; Object.defineProperty(this, key, { enumerable: false, configurable: true, get: function getter () { return self.data[key]; }, set: function setter (newVal) { self.data[key] = newVal; } }); } }; 效果 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003emVue demo\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" v-model=\"message\"\u003e \u003cp\u003e{{ message }}\u003c/p\u003e \u003cbutton v-on:click=\"sayHello\"\u003esayHello\u003c/button\u003e \u003c/div\u003e \u003cscript src=\"./js/observer.js\"\u003e\u003c/script\u003e \u003cscript src=\"./js/watcher.js\"\u003e\u003c/script\u003e \u003cscript src=\"./js/compile.js\"\u003e\u003c/script\u003e \u003cscript src=\"./js/mVue.js\"\u003e\u003c/script\u003e \u003cscript\u003e var vm = new mVue({ el: '#app', data: { message: 'Hello mVue!' }, methods: { sayHello: function() { this.message = 'Hello!'; } } }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 总结 Observer利用Obeject.defineProperty()来监听属性变动，监控data的属性值，如有变动可拿到最新值并通知订阅者。 Dep对象作为一个收集订阅者的容器，实现了订阅发布模式（一对多），当状态发生改变时就会通知所有订阅者对象。 Compile来做解析和绑定工作： 解析模板指令(v-model)，并替换模板数据(双大括号)，初始化视图。 将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器。 操作DocumentFragment节点，要比直接操作DOM快得多，所以为提高性能和效率，可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理。 注意解析v-model指令，只是给可输入节点通过 addEventListener 监听 input事件，并在回调函数修改data对象对应属性的值。 mVue通过proxyKeys方法代理data对象的所有属性。 深入Vue "},"title":"README"},"/frontend-learn/docs/guide/html/":{"data":{"":"HTML 超文本标记语言（HyperText Markup Language）：用来定义网页内容的标记语言。\n超文本：意思就是不止文本，还包括图片、音频、视频等。 标记：标记语言，就是用标记符号（HTML 标签）来标记文本，计算机就可以识别这些标记符号，从而对文本进行处理。 CSS 层叠样式表：用来定义 HTML 的显示样式。\nJavaScript： 脚本语言，用来定义与用户的交互。"},"title":"HTML 和 CSS"},"/frontend-learn/docs/guide/html/01_tags/":{"data":{"":"","html-页面的基本结构#HTML 页面的基本结构":"一个 HTML 页面的基本结构：\n\u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eDemo\u003c/title\u003e \u003cbase href=\"/\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003c!-- 设置不同尺寸的 favicon，浏览器会根据分辨率自动加载合适的 favicon --\u003e \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"favicon-16x16.ico\" sizes=\"16x16\"\u003e \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"favicon-32x32.ico\" sizes=\"32x32\"\u003e \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"favicon-48x48.ico\" sizes=\"48x48\"\u003e \u003clink rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"\u003e \u003c!-- Fallback for older browsers --\u003e \u003clink rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"apple-touch-icon.png\"\u003e \u003c!-- 针对苹果设备，苹果设备保存网页到桌面的图标 --\u003e \u003clink rel=\"manifest\" href=\"site.webmanifest\"\u003e \u003c!-- For PWA --\u003e \u003c/head\u003e \u003cbody\u003e \u003capp-root\u003e\u003c/app-root\u003e \u003c!-- \u003cscript\u003e\u003c/script\u003e --\u003e \u003c/body\u003e \u003c/html\u003e \u003c!doctype html\u003e：声明文档类型是 html5。 \u003chtml\u003e：根标签，一般只包含 head 和 body 标签。 \u003chead\u003e：标签内容一般不会显示在页面上，用于描述页面的信息。 \u003cbody\u003e：页面的主要内容。 \u003ctitle\u003e：页面标题。 \u003cmeta name=\"keywords\" content=\"..., .., ..\"\u003e：针对搜索引擎的页面关键字。 \u003cmeta name=\"description\" content=\"...\"\u003e：针对搜索引擎的页面描述。 \u003cstyle\u003e：书写 css 样式。 \u003clink\u003e：一般用来加载 css 文件或者 favicon。 \u003cscript\u003e：用来加载 javascript 文件。\u003cscript\u003e 一般会放在 \u003cbody\u003e 标签里的最下面，原因： 当 javascript 文件比较大的时候，会阻塞页面中的其他元素的加载，导致整个页面加载缓慢。 另外 javascript 可能会处理页面中元素，如果 javascript 先加载，但是元素还没有生成，会导致报错。 ","实体符号#实体符号":"HTML 中的预留字符必须被替换为实体符号才可以使用。例如在 HTML 中不能使用 \u003c \u003e，浏览器会误认为它们是标签。\n如果希望正确地显示预留字符，必须在 HTML 源代码中使用实体符号。\nMDN Web Docs (Entity)。","常用标签#常用标签":"常用的标签，后期都是可以使用 CSS 去自定义样式。那为什么要定义这么多标签，而不是使用一个标签再配合 CSS 实现样式，这是因为一个重要的概念，语义化。\n语义化的好处：\n可读性更好。 对搜索引擎友好。 文本类标签 文本结构 h1-h6 标题，块级标签，占据一行 p 段落，块级标签，占据一行 文本修饰 em: 强调 strong: 加粗 u: 下划线 sup: 上标 sub: 下标 通用 span 一个通用标签，可以用它来替换所有的文本标签。 列表 ul 无序列表 ol 有序列表 其他 br 换行，单标签 hr 横线，单标签 结构化标签 结构化标签没有默认的样式。\n常规结构 header: 页面头部 nav: 导航 main: 主要区域 footer: 页脚 文章结构 article: 文档内容 section: 文档中的通用区块，通常包含一组相关的内容 aside: 文档中附加区块，通常包含侧边栏、广告等 通用 div：（Division）块级容器标签 媒体资源标签 img：图片 svg：矢量图 video：视频 audio：音频 canvas：画布 表单标签 form 表单标签， action 属性是提交的页面（例如 https://www.baidu.com/s ） method 提交的方法，get 提交的数据会在链接上显示，一般用来搜索，post 提交的数据在 body 里面. input、textarea 输入或选择 select：下拉列表 option：选项 button：按钮 label：标签 链接 a 链接，\u003ca href=\"#element-id\"\u003e 可以进行页面内位置的跳转。 "},"title":"HTML 标签"},"/frontend-learn/docs/guide/html/02_css/":{"data":{"":"","css-值的类型#CSS 值的类型":"CSS 值的类型可以分为三类：\n特定关键字：例如颜色关键字，例如 red、green、blue 等。 自定义值：例如 100px、200px 等。 全局值：例如 inherit、initial、unset 等。 inherit：继承父元素的属性。继承可以分为默认继承（指的是子元素没有设置对应属性，就会继承父元素的属性，大部分属性都不会默认继承，默认继承的主要是文字属性）和主动继承。 initial：将元素的属性重置为默认值。 unset：会根据属性是不是可继承的来决定应用 inherit 还是 initial。 ","变量#变量":"声明变量，变量名前加 --，变量名大小写敏感：\nbody { --foo: #7F583F; --bar: #F7EFD2; } 上面的示例声明了两个变量：--foo 和 --bar。\n用 -- 表示变量是因为 $ 被 Sass 用掉了，@ 被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用 -- 了。\nvar 函数 var() 函数用于读取变量。\na { color: var(--foo); text-decoration-color: var(--bar); } var() 函数使用第二个参数，表示变量的默认值（例如 color: var(--foo, #7F583F);）。如果该变量不存在，就会使用这个默认值。\n数值与单位直接写在一起，是无效的：\n.foo { --gap: 20; /* 无效 */ margin-top: var(--gap)px; } /* 必须使用calc()函数 */ .foo { --gap: 20; margin-top: calc(var(--gap) * 1px); } 作用域 同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的\"层叠\"（cascade）规则是一致的。\n\u003cstyle\u003e :root { --color: blue; } div { --color: green; } #alert { --color: red; } * { color: var(--color); } \u003c/style\u003e \u003cp\u003e蓝色\u003c/p\u003e \u003cdiv\u003e绿色\u003c/div\u003e \u003cdiv id=\"alert\"\u003e红色\u003c/div\u003e 变量的作用域就是它所在的选择器的有效范围。\nbody { --foo: #7F583F; } .content { --bar: #F7EFD2; } 变量 --foo 的作用域是 body 选择器的生效范围，--bar 的作用域是 .content 选择器的生效范围。\n全局的变量通常放在根元素 :root 里面：\n:root { --main-color: #06c; } ","字体属性#字体属性":" 声明使用的字体：font-family，取决于系统是否安装有对应的字体，例如 微软雅黑，黑体等。 字体样式：font-style，normal 默认的样式。 italic 斜体 字体大小，font-size。 字体颜色，color。 字体的粗细，font-weight，值可以是 100-900 或者 bold/bolder/lighter/normal，取决于系统是否安装有对应的字体。 字体排布，text-algin 值可以是 center/left/right。 字体行高，line-height，设置一行文字的高度。 字体修饰：text-decoration underline 下划 overline 上划线 line-through 删除线 字体阴影：text-shadow，text-shadow: {x 偏移值} {y 偏移值} {模糊度} {颜色}，text-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。 所有的字体属性都会继承父元素的字体属性，所以在 html 元素上设置字体属性，会使所有的元素都会默认继承 html 上的字体属性。\n字体设置 font-family 设置的字体可以分为两类\n系统已经安装的字体。 远程获取的字体。 font-family 可以设置多个值，用逗号隔开。例如：font-family: \"微软雅黑\", \"黑体\", \"宋体\", \"楷体\", \"Arial\";。这里会先去匹配第一个字体，如果没有，就会去匹配第二个字体，以此类推。全都没有就会使用默认的字体。一般情况下，会把比较常见的，大部分系统都有的字体放到后面，起到一个保底的作用。\n对于不同的系统，可能默认的字体都不太一样，如果想要简单使用系统的默认字体，就可以使用关键字 system-ui，font-family: system-ui。前提是浏览器支持。\n对于远程获取的字体，尽量避免使用，尤其时中文字体，体积较大，会导致网站加载较慢。\n引入在线字体：\n\u003chead\u003e \u003clink rel=\"preconnect\" href=\"https://fonts.googleapis.com\"\u003e \u003clink rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin\u003e \u003clink href=\"https://fonts.googleapis.com.css2?family=Matemasie\u0026display=swap\" rel=\"stylesheet\"\u003e \u003c!-- 注意要放在自己的 css 文件前面 --\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\"\u003e \u003c/head\u003e \u003c!-- 或者 --\u003e \u003chead\u003e \u003cstyle\u003e @import url('https://fonts.googleapis.com.css2?family=Matemasie\u0026display=swap') \u003c/style\u003e \u003c!-- 注意要放在自己的 css 文件前面 --\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\"\u003e \u003c/head\u003e 对于在线字体最好的方式就是先下载下来，放到自己的项目中再引用。参考下面的字体图标。\n@font-face { /* font-display */ /* 常用的可选值 block 字体文件加载时，显示空白 swap 字体文件加载时，显示备用字体，加载完成后切换 fallback 字体文件加载时，开始的很短的一段时间比如 100ms 会显示空白，如果短时间加载完成就切换，如果加载时间过长就不会再切换 */ } 字体图标 字体图标是用特殊的字体来显示图标，代替图片。\n字体图标的优势：\n可以使用字体属性，随时调整大小和颜色。 图标调整大小，不会因为过大而失真，因为字体是矢量图。 字体文件 size 普遍小于图片，可以降低服务器的带宽压力。 使用字体图标的方式：\n首先需要在 iconfont 下载字体图标。\nUnicode 这个是最原始的方式，兼容性最好，支持 IE6+，以及所有现代浏览器。支持字体属性，但是由于是字体，所以不支持多色。只能使用单色图标。\n注意：新版 iconfont 支持两种方式引用多色图标：SVG symbol 引用方式和彩色字体图标模式。（使用彩色字体图标需要在「编辑项目」中开启「彩色」选项后并重新生成。）\n使用步骤如下：\n\u003cstyle type=\"text/css\"\u003e /* 声明字体，src 是字体文件的路径，多个文件是针对不同的浏览器 */ @font-face { font-family: 'iconfont'; src: url('iconfont.woff2?t=1723520893571') format('woff2'), url('iconfont.woff?t=1723520893571') format('woff'), url('iconfont.ttf?t=1723520893571') format('truetype'); /* font-display */ /* 可选值 block 字体文件加载时，显示空白 swap 字体文件加载时，显示备用字体，加载完成后切换 fallback 字体文件加载时，开始的很短的一段时间比如 100ms 会显示空白，如果短时间加载完成就切换，如果加载时间过长就不会再切换 */ } /* 定义使用 iconfont 的样式 */ .iconfont { font-family: \"iconfont\" !important; /* 使用 iconfont 字体 */ font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } \u003c/style\u003e \u003c!-- 挑选相应图标并获取字体编码（例如 \u0026#x33;），应用于页面 --\u003e \u003cspan class=\"iconfont\"\u003e\u0026#x33;\u003c/span\u003e Font Class 主流方式。Font Class 是 Unicode 使用方式的一种变种，兼容性良好，兼容 IE8+，和所有现代浏览器（IE8 以上才支持伪元素）。\nFont Class 解决了 Unicode 书写不直观，语意不明确的问题。可以很容易分辨这个 icon 是什么。因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\n使用步骤如下：\n\u003c!-- 引入项目下面生成的 fontclass 代码 --\u003e \u003clink rel=\"stylesheet\" href=\"./iconfont.css\"\u003e \u003c!-- 挑选相应图标并获取类名，应用于页面 --\u003e \u003cspan class=\"iconfont icon-xxx\"\u003e\u003c/span\u003e Font Class 就是使用了 :before 伪元素来实现的。\n例如：\n.icon-mtiIcon-yingyongshebei-fangbaocha:before { content: \"\\e713\"; } Symbol 未来的主流方式。这种其实是做了一个 svg 的集合。支持多色图标，支持字体属性，但是兼容性较差。浏览器渲染 svg 的性能一般。","容器属性#容器属性":"盒子模型属性 一个元素的组成：内容 + 内边距 + 边框 + 外边距\nwidth 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 outline 和 border outline 和 border 在 CSS 中都可以用于给元素添加边框，但它们有几个关键的区别：\n位置不同 border 占据空间，是元素的一部分，会影响元素的尺寸。 outline 不占据空间，不会影响元素的尺寸，绘制在元素外部。 单独设置某一边 border 可以分别设置四条边，如 border-top、border-right 等。 outline 只能整体应用，没有 outline-top 之类的属性。 圆角 border 可以与 border-radius 配合使用，形成圆角。 outline 不支持 border-radius，它始终是矩形的。 受 overflow: hidden 影响 border 受 overflow: hidden 限制，如果 overflow: hidden，溢出的 border 会被裁剪掉。 outline 不会被裁剪，即使 overflow: hidden 也会显示。 outline-offset 用于控制 outline 与元素的距离。例如使 outline 在元素外额外偏移 5px，不会紧贴元素。\n.box { outline: 3px solid green; outline-offset: 5px; } outline-offset 如果是负值，就是向元素内偏移。\npadding-inline, margin-inline, padding-block, 和 margin-block padding-inline, margin-inline, padding-block 和 margin-block 都是 CSS 中的逻辑属性，这些属性相对于物理属性（如 padding-left, padding-right, margin-left, margin-right 等）更具灵活性，能够适应不同的文本方向。这些逻辑属性根据元素的书写模式（例如从左到右 LTR 或从右到左 RTL）来设置内边距和外边距。\n例如：\n在从左到右（LTR）语言中，padding-inline-start 与 padding-left 的效果相同，表示元素的左侧内边距。 但是在从右到左（RTL）语言中，padding-inline-start 会对右侧内边距产生影响，因为它总是指向开始边（即对用户书写模式的\"起始\"位置），这意味着它能够自适应语言的方向性变化。 box-sizing box-sizing：盒子模型默认是 box-sizing: content-box。\nborder-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块) div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。\n块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行内元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行内元素设置宽高是无效的。另外包含 display: inline 的属性也是内级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 一个元素一旦成为了弹性布局或者网格布局的直接子元素，那么该元素之前的模式会失效，例如：\n\u003cdiv style=\"display: flex\"\u003e \u003cspan style=\"height: 100px;width: 100px\"\u003e\u003c/span\u003e \u003c/div\u003e 上面的 span 尽管是一个行内元素，但是可以设置宽高。\n背景 background：复合属性，background: {color} {image} {repeat} {position} {size}。 background-clip：背景的绘制区域。 border-box：默认值，边框区域 padding-box：内边距区域 content-box：内容区域 background-color：背景颜色。设置单色背景时有效。对图片背景，渐变背景无效。 background-image：背景图片。 background-repeat：背景重复，对图片背景有效。 no-repeat：不重复 repeat：重复 repeat-x：只重复水平方向 repeat-y：只重复垂直方向 background-origin：背景的绘制起点，对图片背景有效。 border-box：从边框区域开始绘制 padding-box：从内边距区域开始绘制 content-box：从内容区域开始绘制 background-position：绘制背景图片的位置。left right bottom 或者 x y 坐标。如果不设置这个属性，那么绘制背景会从背景图片的左上角开始绘制。设置该属性，例如 background-position: 10px 10px，会根据 background-origin 的值，再偏移 10px 10px 位置开始绘制。left 就是从背景图片左侧居中的位置开始绘制。right bottom 就是右下角位置开始绘制。 background-size：背景大小。背景图片的大小可以大于或者小于绘制背景的区域，这个时候就可以设置该值俩调整背景图片的显示。 cover：横向或者纵向等比例缩放背景图片，完整的覆盖整个背景绘制区域。多余的部分就不显示了。 contain：横向或者纵向等比例缩放背景图片去放到背景绘制区域。 {width} {height}：背景大小。 background-attachment：背景是否固定，scroll 滚动，fixed 固定。 多层背景 背景是可以设置多层的：background: linear-gradient(yellow, orange), url(1.jpg), url(2.jpg), red。\n上面的示例就设置成了一个四层背景。越靠前的背景会覆盖后面的背景。单色背景的优先级是最低的（跟顺序无关），并且只能设置一个。\n遮罩 遮罩属性 mask 和背景属性使用方式非常类似，这个是属性可以给元素加一层遮罩。MDN Web Docs (Mask)。\n盒子阴影 box-shadow：{x 偏移值} {y 偏移值} {模糊度} {扩散} {颜色} {内阴影}，box-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。","常用单位#常用单位":"绝对单位 px：像素单位。 pt、in：打印单位。 相对单位 %：百分比。占父元素宽度或高度的百分比。 em：相对于父元素的字体大小。不建议使用。2em 就是父元素 font-size 的两倍。1em 就是 1 倍。 rem：相对于根元素（html 标签）的字体大小。2rem 就是根元素 font-size 的两倍。不仅可以用来设置字体大小，也可以用设置宽高。最终都会换算成 px。 vw：viewport width 视口单位，视口指的是浏览器的显示区域。视口宽度。20vw 就是视口宽度的 20%。 vh：viewport height 视口单位，视口高度。1vh 就等于视口高度的 1%。 vmin、vmax：vmin 是选择视口宽度或者高度中较小的那个。vmax 是选择视口宽度或者高度中较大的那个。例如 30vmax 当浏览器显示区域的高度大于宽度时，那就表示视口高度的 30%。不常用。 svh lvh dvh svw lvw dvw：移动端单位。 ","颜色#颜色":"关键字 常见的颜色关键字：red、green、blue、yellow 等等。\n十六进制 十六进制颜色是由 6 个十六进制字符组成的。例如 #FF0000 表示红色。如果两个字符相同，那么可以简写为一个字符。例如 #F00 表示红色。\n其实十六进制颜色后面还可以加两位表示透明度。例如 #FF000080 表示红色，透明度为 0.5。\nRGB/RGBA RGB 是一种色彩标准，由红（Red）、绿（Green）、蓝（Blue）3 种颜色变化来得到各种颜色。而 RGBA，其实就是在 RGB 基础上增加了一个透明度 Alpha。\nrgb(R, G, B) rgba(R, G, B, A) R，指的是红色值（Red）；G，指的是绿色值（Green）；B，指的是蓝色值（Blue）；A，指的是透明度（Alpha）。\nR、G、B 这三个可以为整数，取值范围是 0~255 或者 0%~100%。参数 A 为透明度，取值范围为 0.0~1.0。\nHSL/HSLA HSL 是一种色彩标准，由色相（Hue）、饱和度（Saturation）、亮度（Lightness）3 种颜色变化来得到各种颜色。A 为透明度，取值范围为 0.0~1.0。\nhsl(H, S, L) hsla(H, S, L, A) 颜色的透明度和 opacity 的区别 十六进制颜色，RGBA，HSLA，opacity 属性都可以设置透明度。颜色透明度和 opacity 的区别是：\n在元素中使用了 opacity，那么其后代元素都会受其影响。 RGBA 等颜色透明度可以为颜色单独设置透明度，不影响整个元素的透明度，也不会影响到元素的其他属性。 示例：\n/* 设置背景颜色的透明度，而不会影响整个元素 */ background-color:rgba(255,0,255,1.0); /* bg 后代元素以及文本内容都会受到影响 */ .bg { background-color:rgb(255, 0, 255); opacity:0.3; } "},"title":"CSS 常用属性"},"/frontend-learn/docs/guide/html/03_layout/":{"data":{"":"","定位#定位":"可以设置元素具体在某个位置上。元素默认就是 static，也就是没有定位。\nrelative、absolute、fixed 这三个属性值有一个共同点，都是相对于某个基点的定位，只是基点不同。\n文档流 文档流（Normal Flow）简单说就是 HTML 元素的一种排布规则，元素默认是从上到下、从左到右依次排列（盒模型）。不同的布局模式，例如弹性布局或者网格布局，会有不同的排布规则。 不管是哪种文档流，本质都是对内部元素进行空间分配，元素与元素之间不产生重叠。\n脱离文档流 脱离文档流是指，元素会被文档流忽略，不分配空间。脱离文档流的元素可以理解为漂浮在文档流的上方。当一个元素脱离文档流后，文档流中的其他元素将忽略该元素并填补其原先的空间。\n脱离文档流的方法有浮动 float，绝对定位 position:absolute 和固定定位 position:fixed。\nstatic static 表示浏览器会按照源码的顺序，决定每个元素的位置，每个块级元素占据自己的区块，元素与元素之间不产生重叠，这个位置就是元素的默认位置。\nstatic 定位的元素位置，是浏览器自主决定的，所以这时 left/right/top/bottom 这四个属性是无效的。\n相对定位 position: relative：相对于默认位置（即 static 时的位置）进行偏移，虽然元素根据 left/right/top/bottom 这四个属性进行了偏移，但是在文档流中占据的位置是不变的。\ndiv { position: relative; top: 20px; } 上面的示例，div 元素从默认位置向下偏移 20px（即距离顶部 20px）。\n绝对定位 position: absolute：相对于最接进自身并且设置了非 static 定位的父元素或者祖先元素（不是 static 的元素）。配合 left/right/top/bottom 属性使用。\n设置了绝对定位的元素，会脱离文档流，不会占据空间。正常的元素会顶上去。\n设置了绝对定位的元素的位置如何确定？\n没有设置定位偏移属性（left/right/top/bottom）的情况 要根据父元素的文档流模式来确定位置，例如 flex 布局：\n弹性容器设置了 justify-content: start;：\n弹性容器设置了 justify-content: end;：\n弹性容器设置了 justify-content: center;：\n设置了定位偏移属性的情况 元素的定位基点是设置了非 static 定位的最近的父元素或者祖先元素，如果没有非 static 定位的祖先元素，那么会以浏览器显示区域边界来进行定位。\n元素设置 position: absolute;bottom: 20px;left: 20px;：\n固定定位 position: fixed：固定在浏览器窗口中的某个位置，相对于浏览器窗口定位。配合 left/right/top/bottom 属性使用。\n设置了固定定位的元素，会脱离文档流，不会占据空间。\n设置了固定定位的元素的位置如何确定？\n没有设置定位偏移属性（top、bottom、left、right）的情况下，和绝对定位的表现是一样的。 设置了定位偏移属性的情况下，元素的定位基点是浏览器的显示区域边界。无论页面如何滚动，元素的位置是固定不变的。 粘性定位 sticky 的定位基点是设置了 overflow:scroll 的最近的祖先元素。如果没有就以浏览器显示区域边界来进行定位。\nsticky 定位不会脱离文档流。\nsticky 会产生动态效果，很像 relative 和 fixed 的结合。比如，网页的搜索工具栏，初始加载时，在自己的默认位置（relative 定位），页面向下滚动时，工具栏可以在距离浏览器相对应的位置固定住，始终停留在页面头部（fixed 定位）。等到页面重新向上滚动回到原位，工具栏也会回到默认位置。必须配合 left/right/top/bottom 属性使用。\n当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 sticky 元素的距离达到生效门槛，relative 定位自动切换为 fixed 定位；等到父元素完全脱离视口时（即完全不可见），fixed 定位自动切换回 relative 定位。sticky 元素这个时候也是不可见的。","层#层":"堆叠上下文 堆叠上下文就是一个独立的渲染层，里面的元素会按照自己的堆叠顺序进行渲染。\n页面的 \u003chtml\u003e 元素是一个默认就有堆叠上下文的，所以被叫做根堆叠上下文。在根堆叠上下文中，元素是可以产生自己的堆叠上下文的。\n如何让一个元素产生堆叠上下文：\n默认情况下，元素的 position 不是 static，z-index 不是 auto，那么该元素就会产生堆叠上下文。 弹性（Flex）元素或者网格（Grid）元素，只要设置了 z-index 不是 auto，那么该元素就会产生堆叠上下文。 堆叠顺序 同一个堆叠上下文中，z-index 越大，元素的堆叠顺序越靠上。 同一个堆叠上下文中，z-index 相同，那么元素的堆叠顺序就按照元素在 DOM 中的先后顺序。 设置 z-index 只在元素所在的堆叠上下文中有效。一个堆叠上下文中子元素，无论设置的 z-index 是多少，都不会影响其他堆叠上下文的堆叠顺序。如下图：\n元素 A 产生了堆叠上下文，并且 z-index 为 1，元素 B 是 A 的子元素，z-index 为 20。但是元素 B 的是无法覆盖的元素 C 的。\n也就是说，任意元素的堆叠顺序是会被自己的祖先元素的堆叠上下文限制的，只有那些不存在祖先元素有堆叠上下文的元素，才能参与到根堆叠上下文的堆叠顺序中。所以碰到 z-index 层级高却无法覆盖层级低的元素，就要先去检查一下祖先元素是否有堆叠上下文，然后再设置 z-index。\n上图中，非 static 元素是介于 0 和 1 之间的，只要元素设置了 position 并且不是 static，那么元素就会跳到红色层级。","弹性布局#弹性布局":"弹性布局可以更方便的布局，但是对浏览器要求较高。\n概念：\n弹性容器：设置了 display: flex; 的元素即为弹性容器。 弹性子元素（项目）：弹性容器里的直接子元素。 display: flex：如果一个元素的设置了这个属性（弹性容器），那么他的直接子元素（孙子元素就不是弹性布局），就会按着弹性布局的方式来布局。\n\u003chead\u003e \u003cstyle\u003e .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e 如果 parent 不是弹性布局，那么三个 child 都是块元素，每个元素会占据一整行。但是 parent 添加了 display: flex; 属性以后，三个子元素会在一行并排显示，不会有间距。\n直接子元素是弹性布局，但是parent 元素本身还是块级布局。\n弹性主轴和侧轴 弹性布局有一个主轴和一个侧轴：\n主轴：默认是水平向右，可以修改为水平向左或竖直向上，竖直向下。 侧轴（交叉轴）：默认是竖直向下，可以修改为竖直向上或水平向左，水平向右， 弹性布局的子元素默认是在主轴上一行或者一竖，不会换行，默认情况下（flex-wrap: nowrap）如果一行子元素的宽度或者高度超过了父元素，所有的子元素就会等比例缩小。\n设置主轴的方向：\nflex-derection: row：默认是 row。 row：水平向右。 row-reverse：水平向左。 column：竖直向下。 column-reverse：竖直向上。 设置主轴的排布：\njustify-content: flex-start：默认是 flex-start。 flex-start：靠近主轴的起点。 flex-end：靠近主轴的终点。 center：主轴居中。 space-between：平均分布，和主轴的起点和终点没有间距。 space-around：平均分布，和主轴的起点和终点有间距，两边的间距是中间的一半。 space-evenly：平均分布，间距一致。 弹性布局，设置水平居中只需要 justify-content:center 就可以实现，如果不是弹性布局，可以用下面的方式：\ndisplay: block; /* 设置为块级元素 */ margin: 0 auto; /* auto 设置水平居中，必须是块元素 */ 设置侧轴的排布：\nalign-items: stretch：默认是 stretch。 stretch：拉伸，如果子元素没有设置高度或宽度，那么子元素会被拉伸到和父元素一样的高度或宽度。 flex-start：靠近侧轴的起点。 flex-end：靠近侧轴的终点。 center：侧轴居中。单行的侧轴没有平均分布。 换行：\nflex-wrap: nowrap：默认是 nowrap。 nowrap：不换行。 wrap：换行，如果侧轴排布是 stretch，换行以后是两行，那么两行会被拉伸，各占一半。 多行存在的时候，侧轴分布：\nalign-content: flex-start： flex-start：多行都向侧轴的起点靠拢。 flex-end：多行都向侧轴的终点靠拢。 center：多行居中。 space-around：平均分布，和侧轴的起点和终点有间距，两边的间距是中间的一半。 space-between：平均分布，和侧轴的起点和终点没有间距。 space-evenly：平均分布，间距一致。 弹性子元素会存在多个，如果要单独设置一个子元素侧轴的分布，可以给弹性子元素添加属性：\nalign-self: flex-start： flex-start：靠近侧轴的起点。 flex-end：靠近侧轴的终点。 center：侧轴居中。 主轴是不能单独设置一个子元素的分布的。\n弹性子元素的排序 如果要设置弹性子元素的排序，可以给每个子元素添加属性：\norder: {num} 子元素会沿主轴方向从小到大排序。 示例：\n\u003chead\u003e \u003cstyle\u003e .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } .c1 { order: 3; background: skyblue; } .c2 { order: 2; background: green; } .c3 { order: 1; background: yellow; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child c1\"\u003e\u003c/div\u003e \u003cdiv class=\"child c2\"\u003e\u003c/div\u003e \u003cdiv class=\"child c3\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e 弹性子元素剩余空间配置 给子元素添加属性 flex: {num}，占据剩余份额的份数。flex: 1 就表示占据剩余空间的 1 份。\n示例：\n\u003chead\u003e \u003cstyle\u003e .parent { display: flex; width: 600px; height: 600px; background: gray; } .child { width: 100px; height: 100px; } /* 剩余空间被分为 3 份，c1 占 1/3，c2 占 2/3 */ .c1 { flex: 1; background: skyblue; } .c2 { flex: 2; background: green; } .c3 { order: 1; background: yellow; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child c1\"\u003e\u003c/div\u003e \u003cdiv class=\"child c2\"\u003e\u003c/div\u003e \u003cdiv class=\"child c3\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e 上面的示例，每个子元素的宽度为 100px，那么剩余空间就是 300px。c1 会占据剩余空间的 100px，c2 占 200px。\nflex-grow、flex-shrink、flex-basis flex 是一个复合属性（flex: {flex-grow} {flex-shrink} {flex-basiss}），它有三个属性：flex-grow、flex-shrink、flex-basis ，分别是用来设置弹性子元素的拉伸、收缩和基准值。\nflex-grow：默认值 0。和 flex: {num} 的作用是一样的。 flex-shrink：默认值 1。和 flex: {num} 的作用是相反的，当子元素的大小超过了主轴或者侧轴，那么设置了 flex-shrink 的子元素就会自动收缩。如果设置了换行，那么这个属性就没有用了。 flex-basis：默认值 auto。设置主轴方向的元素的尺寸。如果主轴是横向的，那设置的就是宽度，如果是纵向的，那设置的就是高度。 inline-flex display: inline-flex 和 display: flex 的唯一区别就是会把元素本身变为行内元素，元素内部的子元素仍然是弹性子元素。","浮动布局#浮动布局":"浮动布局的好处：\n可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。\n元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。\n例如下面的 html，三个 \u003cdiv class=\"child\"\u003e\u003c/div\u003e 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。\n\u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003c/div\u003e 如果不想有空格，可以像下面这样，把换行和空格去掉：\n\u003cdiv class=\"parent\"\u003e \u003cdiv class=\"child\"\u003e\u003c/div\u003e\u003cdiv class=\"child\"\u003e\u003c/div\u003e\u003cdiv class=\"child\"\u003e\u003c/div\u003e \u003c/div\u003e 上面的方式，不好看，可以使用浮动解决：\n.child { float: left } 第一个子元素 \u003cdiv class=\"child\"\u003e\u003c/div\u003e 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。\n清除浮动 浮动会导致父元素的高度塌陷。\n比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。\n因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。\n解决方式：\n设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：\n.parent { } .parent:after{ content: \"\"; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。","网格布局#网格布局":"弹性布局是基于轴线的布局，可以看作是一维布局，网格布局将容器划分成行和列，产生单元格，可以看作是二维布局。\n概念：\n网格容器：设置了 display: grid; 的元素即为网格容器。 项目：网格容器里的直接子元素。 grid-template-columns：设置网格容器的列宽和列的数量，例如 grid-template-columns: 100px 200px 100px; 表示网格容器有三列，列宽分别是 100px、200px、100px。 grid-template-rows：设置网格容器的行高和行的数量，例如 grid-template-rows: 100px 200px; 表示网格容器有两行，行高分别是 100px、200px。 网格布局，是看不到网格线的，开发过程中，可以在浏览器中查看元素，选择 grid 标签，如下图：\n划分网格 fr、auto、minmax fr、auto、minmax 是网格布局的三个关键字，用来设置网格容器的列宽和行高。都是具有一定收缩性和扩展性的。\n优先级：minmax() \u003e fr \u003e auto。\nfr 和 auto 最小值都是 0，过多内部存在子元素，那么最小值就是子元素的宽或者高。\nfr fr：单位（fraction），有点类似于弹性布局的 flex-grow，fr 的作用也是把整个容器内剩余的空间做均分，然后按照 fr 来分配。例如 grid-template-columns: 60px 1fr; 表示网格容器有两列，第一列的宽度是 60px，第二列的宽度是剩余的宽度。所有列都用 fr 来表示，例如 grid-template-columns: 1fr 1fr; 表示网格容器有两列，宽度各占一半。fr 可以快速的把整个网格空间利用起来，例如实现一个九宫格 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;\nauto auto 是用来设置宽高的默认值，但是在网格容器中，有一些特别的用处。\n\u003chead\u003e \u003cstyle\u003e .child3 { height: 30px; width: 100px; background-color: salmon; } .grid-container { height: 600px; width: 600px; background-color: black; display: grid; grid-template-columns: 60px 60px auto; grid-template-rows: 100px 200px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"grid-container\"\u003e \u003cdiv\u003e111\u003c/div\u003e \u003cdiv\u003e222\u003c/div\u003e \u003cdiv class=\"child3\"\u003e333\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e 上面的示例，效果如下图：\nchild3 元素的宽度是 100px，但是这个元素所在的单元格的宽度是 auto，auto 忽略了子元素的宽度，占满了剩余空间。但是如果新增一例 1fr：\n.grid-container { /* ... */ grid-template-columns: 60px 60px auto 1fr; grid-template-rows: 100px 200px; } auto 会自动收缩，正好等于子元素的宽度，如下图：\n如果有多个 auto，例如 grid-template-columns: 60px 60px auto auto; 包含了两列 auto，这两列会把剩余空间平分，如下图：\n但是一旦有了一列 fr，例如 grid-template-columns: 60px 60px auto auto 1fr;，所有的 auto 都会自动收缩。\nminmax() minmax({min}, {max})：用来设置一个范围，例如 grid-template-columns: minmax(100px, 200px); 表示网格容器的第一列的宽度在 100px 到 200px 之间。\n注意 min 值不要设置的比 max 大，例如 minmax(200px, 100px) 或者 minmax(1fr, 100px)。\nminmax() 的优先级是高于 auto 的，它会在最大的范围中去压缩 auto 的空间。\nrepeat repeat({重复次数}, {尺寸})：用来设置重复的列或者行，例如 grid-template-columns: repeat(3, 100px); 表示网格容器有三列，列宽都是 100px。\nauto-fill auto-fill：会按照尺寸去尽可能的生成最多的列或者行，例如：\n.grid-container { height: 600px; width: 650px; background-color: black; display: grid; grid-template-columns: repeat(auto-fill, 100px); grid-template-rows: 100px 200px; } 上面的示例，repeat(auto-fill, 100px) 根据当前容器的剩余空间 650px 最多就只能生成 6 列。\nauto-fit auto-fit：也是按照尺寸去尽可能的生成最多的列或者行，但是和 auto-fill 不同的是，它最终生成的列，如果没有元素，那么它会收缩为 0。\n如果 auto-fit 的尺寸设置为 minmax，例如 grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));，那么会生成的列是会把剩余空间均分的。 但如果 auto-fill 的尺寸设置为 minmax，例如 grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));，那么会按照 min 也就是 100px 去生成列。\ngap gap：设置网格容器的行间距和列间距。\n统一设置间距，例如 grid-gap: 10px; 表示网格容器的行间距和列间距都是 10px。 分别设置行和列的间距，例如 grid-gap: 10px 20px; 表示网格容器的行间距是 10px，列间距是 20px。也可以分开设置，例如 row-gap: 10px; column-gap: 20px;： row-gap：行间距。 column-gap：列间距。 网格排布 网格布局的排列顺序默认是先行后列，例如下面的一个九宫格的示例：\n\u003cstyle\u003e .grid-container { height: 300px; width: 600px; background-color: black; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 16px; font-size: 4rem; color: white; } .child { padding: 8px; } .child1 { background-color: #0055bb; } .child2 { background-color: #66bbff; } .child3 { background-color: #8440f1; } .child4 { background-color: #b88dff; } .child5 { background-color: #ff6666; } .child6 { background-color: #ffdd66; } .child7 { background-color: green; } .child8 { background-color: greenyellow; } .child9 { background-color: pink; } \u003c/style\u003e \u003cdiv class=\"grid-container\"\u003e \u003cdiv class=\"child child1\"\u003e1\u003c/div\u003e \u003cdiv class=\"child child2\"\u003e2\u003c/div\u003e \u003cdiv class=\"child child3\"\u003e3\u003c/div\u003e \u003cdiv class=\"child child4\"\u003e4\u003c/div\u003e \u003cdiv class=\"child child5\"\u003e5\u003c/div\u003e \u003cdiv class=\"child child6\"\u003e6\u003c/div\u003e \u003cdiv class=\"child child7\"\u003e7\u003c/div\u003e \u003cdiv class=\"child child8\"\u003e8\u003c/div\u003e \u003cdiv class=\"child child9\"\u003e9\u003c/div\u003e \u003c/div\u003e 显示效果：\n元素先从第一行开始，从左到右排列。\n使用 grid-auto-flow: column 设置为先列后行。\ngrid-auto-flow 属性除了设置成 row 和 column，还可以设成 row dense 和 column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。\n例如 row dense，表示\"先行后列\"，并且尽可能紧密填满，尽量不出现空格。\n网格元素的尺寸 网格中的子元素如果没有设置尺寸，那么默认会拉伸到所在网格的大小。\n网格中子元素的大小和网格的大小是没有关系的：\n如果网格的宽或者高是一个可变的值，例如 1fr，子元素的宽高大于 1fr 的时候会把网格撑开。 如果网格的宽或者高是一个固定的值，例如 200px，子元素的宽高大于 200px 的时候，子元素会忽略网格的大小。 order 网格子元素和弹性子元素一样也可以设置 order 属性来排序。网格子元素的 order 属性默认是 0.\n按网格线设置元素位置 网格边缘上的数字就是网格线的编号。列和行的网格线都是从 1 开始编号。下图中的负数，是反向编号，方便从后开始查找网格线。\n每个网格都是由四根网格线包围的，例如上图中的元素 1，它是有行的 1 号、2 号，列的 1 号、2 号网格线包围的。可以通过指定元素上下左右的 4 根网格线来设置元素在网格中的位置。\n例如上图，如果要把 7 号元素放到 2 号元素的位置：\n.child7 { background-color: green; grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; } 也可以占据多格，例如：\n.child7 { background-color: green; grid-column-start: 2; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3; } grid-column-start: 2; 和 grid-column-end: 4; 可以简写成 grid-column: 2 / 4; grid-row-start: 1; 和 grid-row-end: 3; 可以简写成 grid-row: 1 / 3; 自定义网格线名称 网格线虽然后编号，但是不容易记住，可以在定义列和行时自定义网格的名称。\ngrid-template-columns: [line1 aaa] 100px [line2] 200px [line3] 300px [line4]， 第一列 100px 左边的网格线（编号 1）命名 line1 和 aaa。 第二列 200px 左边的网格线（编号 2）命名为 line2。 第三列 300px 左边的网格线（编号 3）命名为 line3，右边的网格线（编号 4）命名为 line4。 grid-template-rows: [line5] 100px [line6] 100px 100px 网格线可以定义多个名字，用空格分隔，如 [line1 aaa]。 不需要定义所有的网格线名称，只定义需要用到的即可。如 [line5] 100px [line6] 100px 100px。 定义了名称的网格线，编号仍然是可以使用的。 grid-template-areas 网格布局是可以预先将网格划分区域的，一个区域由一个或多个单元格组成。grid-template-areas 属性用于定义区域。\n.grid-container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a a b' 'c c b' 'd e f'; } 面代码先划分出一个九宫格，然后定义了每个单元格所属的区域。\n如果某些单元格不需要利用，则使用 . 表示：\n.grid-container { grid-template-areas: 'a a b' 'c c b' '. . .'; } .child1 { background-color: #0055bb; grid-area: a; } .child2 { background-color: #66bbff; grid-area: b; } .child3 { background-color: #8440f1; grid-area: c; } 注意：\n划分区域的方式的缺点就是每一个单元格都要去设置区域，不用的单元格也要用 . 表示，如果单元格很多，就比较麻烦。 网格线划分优先级要高于区域划分。 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为 区域名-start，终止网格线自动命名为 区域名-end。 隐形网格 加入网格容器划分了九个单元格，但是我们在网格容器中放置了超过 10 个或者更多的子元素，这时，浏览器会自动生成多余的网格，以便放置子元素。这种自动生成的网格就叫做隐形网格。\ngrid-auto-columns 和 grid-auto-rows 属性就是用来设置，浏览器自动创建的多余网格的列宽和行高。如果不指定这两个属性，浏览器根据单元格内容的大小，决定新增网格的列宽和行高。\n用法和 grid-template-columns、grid-template-rows 是一样的。\n网格单元中子元素的位置 在单元格中的子元素，如果没有设置宽高，那么会自动撑满整个单元格，如果设置了宽高，那么可以使用 justify-items 和 align-items 来设置子元素在单元格中的位置。justify-items 和 align-items 都是容器属性。\njustify-items：水平方向，可选值 start，end，center，strech。默认值是 strech。 align-items：垂直方向，可选值 start，end，center，strech。默认值是 strech。 容器设置了这两个属性后，所有单元格内的元素都会按照这个位置来排布。\n如果想要单独设置某个单元格的子元素，可以使用 justify-self 和 align-self。使用方法和 justify-items、align-items 一样。\nplace-self: {align-self} {justify-self} 是 justify-self 和 align-self 的复合属性。\n网格在容器中的位置 justify-content、align-content 用来设置整个网格在容器中的排布，分别表示水平方向和垂直方向的排布。当整个网格没有撑满容器时，就可以使用这两个属性，可选值：\nstart：网格在起始边缘对齐。 end：网格在结束边缘对齐。 center：网格居中对齐。 strech：网格单元大小保持不变，网格单元的间隔拉伸，填满容器。 space-around：平均分布，每个网格单元的两侧的间隔相等。 space-between：平均分布，网格单元的之间的间隔相等，第一个单元贴近起始边缘，最后一个贴近结束边缘。 space-evenly：平均分布，间距一致。 inline-grid display: inline-grid 和 display: grid 的唯一区别就是会把元素本身变为行内元素，元素内部的子元素仍然是网格元素。"},"title":"布局与定位"},"/frontend-learn/docs/guide/html/04_animation/":{"data":{"":"","动画效果#动画效果":"动画要先用 @keyframes 去定义好变化的过程，再去应用到某个元素。\n@keyframes {动画名称} 用来设置关键帧，动画的中间过程会被补全。\n只有两个状态时，使用 from 和 to，from 是动画开始时的状态，to 是动画结束时的状态。 多个状态时，使用百分比，0% 是动画开始时的状态，100% 是动画结束时的状态。更多中间状态用 10%，20%，25% 等。 定义好变化的过程，再用 animation 去应用到某个元素：animation 是一个复合属性，默认值 none 0 ease 0 1 normal none running。\nanimation 也可以分开设置：\nanimation-name：定义动画名称，要和 @keyframes 定义的名称一致。 animation-duration：动画时间。animation-duration 属性是必须的，否则时长为 0，就不会播放动画了。 animation-delay：延迟时间。 animation-timing-function：动画速度，默认是 ease。 ease 先慢后快。 linear 线性。 steps() 步数。 cubic-bezier() 自定义。可以在浏览器的 cubic-bezier 工具中修改。 animation-iteration-count 迭代次数，infinite 表示无限。 infinite 无限次。 n 表示 n 次。 animation-direction：方向，默认是 normal，alternate 表示往返动画。 normal 默认值，正常播放。 reverse 反向播放。 alternate 往返动画。 alternate-reverse 反向往返动画。 animation-fill-mode：最后填充模式，也就是动画结束时，要应用到元素的样式。默认值是 none。 none 不填充。动画播放完以后回到原始的样式。 forwards 应用动画结束时最后一帧的样式。 backwards 应用动画结束时第一帧的样式。 both 遵循 forwards 和 backwards 的规则，从而在两个方向上扩展动画属性。 animation-play-state：动画状态，默认值是 running。 running 正在播放。 paused 暂停。 示例：\n#div1 { /*3 次动画*/ animation-name: demo1; animation-duration: 2s; animation-timing-function: ease-in-out; /*animation: demo1 2s infinite alternate; 无限次的往返动画*/ } @keyframes demo1 { from { transform: translateX(0px); } to { transform: translateX(500px); } } @keyframes demo2 { 0% { transform: translateX(0px); background: red; } 20% { transform: translateX(500px); background: blue; } 70% { transform: translateX(500px); background: green; /* 时间函数是可以设置在单独的一段中，只会影响这一段的变化 */ animation-timing-function: linear; } 100% { transform: translateX(500px); background: yellow; } } ","概述#概述":"页面中元素的变化，按照变化发起的逻辑可以分为触发型和自动型。\n让元素发生变化，有三种方式：\nCSS：适合简单的变化效果， CSS+JS：稍微复杂的变化效果，需要配合一下交互的 JS：类似在 canvas 元素上进行 2D 或者 3D 图像绘制的 元素变化的主要的属性：\n位置 尺寸 缩放，和尺寸类似，但是会带动元素整体，包裹内部元素进行缩放。 旋转 透明度 投影 颜色 边框 ","转换#转换":"2D 转换 2D 转换有 2 个轴, x，y。\n平移：transform: translate(x, y)，x 和 y 可以分开设置（transform: translateX(200px) transform: translateY(100px)） 旋转：transform: rotate(x)，transform: rotate(30deg) 顺时针旋转 30 度，负数就是逆时针旋转。 3D 转换 3D 转换实现 3D 立体效果，有 3 个轴, x，y，z。\n透视点：眼睛与屏幕之间的距离。perspective （perspective: 1000px）意思是距离屏幕 1000 像素点的距离（一般在 \u003cbody\u003e 上设置透视点）。 透视点的位置默认是屏幕的正中央。 平移：transform: translate3d(x, y, z)，也可以分开设置，3D 比 2D 多了一个 translateZ(100px)。 旋转：transform: rotate3d(x, y,z, 30deg) 绕着 x，y，z 确定的轴旋转 30 度，rotateX(45deg) 绕着 X 轴旋转 45 度。rotateY() 绕着 Y 轴旋转。rotateZ() 绕着 Z 轴旋转。 放大和缩小： 放大：transform: scale(3) 放大 3 倍，transform: scale(0.5, 2) 表示水平缩小到 0.5 倍、垂直放大 2 倍。也可以分别设置 transform: scaleX(3) 水平放大 3 倍。scaleY 垂直缩放。 倾斜：transform: skew(15deg, 0deg) 基于 X 轴倾斜 15 度，Y 轴 0 度。值可以为负数。 transform-style: preserve-3d：可以渲染出一些在三维空间中的效果。 transform-origin：设置元素变换的中心点。 transform-box：变换中心点可设置的区域。 perspective-origin：可以修改透视点的位置，例如 perspective-origin: left buttom 将透视点的位置改为左下。 ","过渡和动画的区别#过渡和动画的区别":"过渡的优点在于简单易用，但是它有几个很大的局限：\n需要事件触发，所以没法在网页加载时自动发生。 是一次性的，不能重复发生，除非一再触发。 只能定义两个状态，开始状态和结束状态，不能定义中间状态。 一条过渡规则，只能定义一个属性的变化，不能涉及多个属性。 动画通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果，可以解决过渡的不足。","过渡效果#过渡效果":"将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。\n过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。\n示例：\ntransition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：\ntransition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡缓动曲线。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义，贝塞尔曲线。可以使用一下工具来得到换动曲线： 浏览器开发者工具的 cubic-bezier 工具。 cubic-bezier easings steps，步数 transition-delay：过渡延迟时间。 steps steps(count, start|end) 是一个特殊的时间函数，它和其他关键字 linear 等最大的区别就是，它不是一个连贯的变化，是一步一步的硬切换。\n例如 steps(3, start|end)，设置了 3 步，也就是会有 4 个状态，如下图：\n第一步切换由初始状态到过程状态1。 第二步由过程状态1到过程状态2。 第二步由过程状态2到目标状态。 整个变化过程分为了三个时间段，start 和 end 表示的转台切换是在时间段的开始还是时间段的结束。\n例如 steps(3, start)，就表示时间段一开始，就切换状态，以上图为例，第一个时间段一开始，直接从初始状态就切换到了过程状态1，然后等第一段时间走完，第二段时间开始，过程状态1直接切换到过程状态2，依次类推。\n如果是 steps(3, end)，就表示时间段结束，才切换状态，以上图为例，第一个时间段走完，才从初始状态切换到过程状态1，然后等第二段时间走完，过程状态1切换到过程状态2，依次类推。\nstep-start 等价于 steps(1, start)。 step-end 等价于 steps(1, end)。 steps 在动画效果中用的更多一点。"},"title":"过渡和动画"},"/frontend-learn/docs/guide/html/05_other/":{"data":{"":"","clientheightoffsetheightscrollheight#clientHeight、offsetHeight、scrollHeight":"","tabindex#tabindex":"渐变 线性渐变 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)\n示例：\n/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。\n/* 基本的径向渐变 */ /* 默认情况下，渐变的中心点是 50% 50% 的位置 */ /* 椭圆 */ radial-gradient(red, blue); 滤镜属性 滤镜属性有两个，可以用来实现毛玻璃的效果：\nfilter：为元素本身设置滤镜效果，包括元素背后的区域。 backdrop-filter：只为元素背后的区域设置滤镜效果。 滤镜属性支持的值：\nblur() 设置元素的模糊度，默认是 0px。 例如：filter: blur(20px), blur() 中的值越大越模糊。 contrast() 对比度，正常是 100% 可以写数字，例如：filter: contrast(1000%) 和 filter: contrast(10) 是一个意思。 grayscale() 灰度，正常是 0%，也可以写数字。例如：filter: grayscale(100%)。 hue-rotate() 色相旋转，正常是 0deg 可以写数字，例如：filter: hue-rotate(45deg)。 drop-shadow 投影效果，例如：filter: drop-shadow(16px 16px 20px blue)。 sepia() 褐色，正常是 0% 可以写数字。例如：filter: sepia(100%) 。 brightness() 亮度，正常亮度 100% 可以写数字，例如：filter: brightness(100%) 。如果需要过度曝光的效果可以 brightness(500%)。 saturate() 饱和度，正常是 100% 可以写数字，例如：filter: saturate(1000%)。 invert() 色相反转，底片效果，正常是 0 可以写数字，filter: invert(100%)。 多个属性组合：filter: blur(20px) brightness(100%)。\n滤镜属性是比较耗费性能的。\n滚动属性 overflow 属性用于在内容超出容器时，如何处理内容的显示。\n容器必须有一个确定的高度或者宽度，overflow 才会生效。\noverflow 也可以分别设置 X 轴 overflow-x 和 Y 轴 overflow-y。\ndiv { overflow: hidden; /* overflow-x: hidden; overflow-y: hidden; */ } div { overflow: auto hidden; /* overflow-x: auto; overflow-y: hidden; */ } 常用的值：\nvisible：默认值，不会出现滚动条，溢出内容会直接显示在容器外部。 hidden：不会出现滚动条，溢出内容会被裁剪，超出容器的部分不可见。 scroll：显示滚动条，超出容器的内容，可以滚动滚动条来显示。 auto：和 scroll 基本一样。在内容有溢出时才显示滚动条，没有溢出则不显示滚动条。 overlay：和 auto 差不多，不同的是 auto 显示的滚动条会在容器内占据一个位置，会导致内容发生位移。overlay 则是会覆盖在容器右侧，不会占据位置 background-attachment 滚动条的样式 主要涉及以下几个伪元素属性，-webkit 表示只对 webkit 内核浏览器有效。\n::-webkit-scrollbar：设置滚动条的整体样式，可以设置尺寸等。必须要设置宽高，否则不生效。 ::-webkit-scrollbar-button：滚动条两端的按钮（上下箭头）。不设置则不出现。 ::-webkit-scrollbar-thumb：滚动条上的滚动滑块。必须要设置，否则不会出现滑块。 ::-webkit-scrollbar-track：滚动条轨道。不设置则不出现轨道。 ::-webkit-scrollbar-track-piece：滚动条没有滑块的轨道部分。 ::-webkit-scrollbar-corner：当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。 示例：\n/* 滚动条所在容器 */ .scroll-container { margin: 10px; width: 200px; height: 250px; overflow: overlay; background-color: #fff; } /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/ .scroll-container::-webkit-scrollbar { width:16px; height:16px; background-color:#F5F5F5; } /*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; } 伪类属性 滚动条的样式还可以搭配一些伪类属性来进行优化：\n:horizontal：适用于任何水平方向上的滚动条。 :vertical：适用于任何垂直方向的滚动条。\n/*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; \u0026:horizontal { background-color: blue; } } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; \u0026:vertical { background-color: red; } } 换行与溢出 相关属性：\nwhite-space：文本是否换行，空白符（换行符、空格、制表符等）的处理。 word-break，overflow-wrap：断句/断单词的换行处理，主要针对 non-CJK (CJK 指中文/日文/韩文) 的文本。 text-overflow：文字溢出的处理。 white-space normal：默认值，文本中的连续空白符会被合并。根据填充的盒子宽度来决定换行。 nowrap：不换行，文本中的连续空白符会被合并。 pre：文本之间的空白符会被保留。只有遇到换行符或者 \u003cbr\u003e 时才会换行。其行为方式类似 HTML 中的 \u003cpre\u003e 标签。 pre-wrap：换行，并且文本之间的空白符会被保留。遇到换行符或者 \u003cbr\u003e 时换行，或者根据填充的盒子宽度来决定换行。 word-break normal：默认值。 break-all：最常用的值，可在任意字符间断行，效果就是换行位置都会被填满，如果需要单词保持完整性，那就不要使用。 overflow-wrap 和 word-break 一样也是用来截断单词的，不一样的是 overflow-wrap 侧重于处理超出元素宽度的单词。\nnormal：默认值。换行符将出现在空格和连字符处。 break-word：最常用的值。如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 text-overflow 指定当文本溢出时，应该如何显示。可以设置溢出后，文本被剪切、显示省略号 (...) 或显示自定义字符串（不是所有浏览器都支持）。\nclip：剪切文本。 ellipsis：显示省略符号 ... 来代表被修剪的文本。 string：使用给定的字符串来代表被修剪的文本。 text-overflow 需要配合以下两个属性使用：\nwhite-space: nowrap; 不换行 overflow: hidden 不显示滚动条。 文本的水平对齐和垂直对齐 水平对齐 text-align：默认值 left。 left：左对齐。 right：右对齐。 center：居中对齐。 justify：两端对齐。 start：如果内容方向是从左到右的话，左对齐。反之则右对齐。 end：如果内容方向是从左到右的话，右对齐，反之则左对齐。 只有块级元素内的文字或者行内元素才生效。\n垂直对齐 垂直对齐，是设置文字在一行内的空间中的垂直对齐。\nvertical-align：默认值 baseline。 baseline：默认值，基线对齐。 top：整行的顶部对齐。 middle：垂直居中。 bottom：整行的底部对齐。 text-top：与父元素的字体的顶部对齐。 text-bottom：与父元素的字体的底部对齐。 只有表格元素或者行内元素才生效。\nclientHeight、offsetHeight、scrollHeight 每个元素都具有以和元素高度、滚动、位置相关的属性。这些属性通常用于计算元素的实际高度，尤其在涉及到滚动的情况下。\nclientWidth、clientHeight、clientLeft、clientTop clientWidth：只读属性，表示元素的内部宽度，单位 px，包括 padding 但不包括 border margin 和垂直滚动条的宽度。对于 inline 的元素这个属性一直是 0。 clientHeight：只读属性，表示元素内容的高度，单位 px，包括 padding 但不包括 border margin 和水平滚动条的高度。对于 inline 的元素这个属性一直是 0。 clientLeft：只读属性，表示元素左边框的宽度，单位 px，不包括左外边距和左内边距。 clientTop：只读属性，表示元素顶部边框的宽度，单位 px，不包括顶部外边距或内边距。\noffsetWidth、offsetHeight、offsetLeft、offsetTop offsetWidth：只读属性，表示元素的布局宽度，单位 px，包括 padding border margin 和垂直滚动条的宽度。 offsetHeight：只读属性，表示元素内容的高度，单位 px，包括 padding border margin 和水平滚动条的高度。 offsetLeft：只读属性，表示元素左上角相对于 offsetParent 左边界的偏移，单位 px，如果元素被隐藏则是 0。 offsetTop：只读属性，表示元素相对于 offsetParent 元素的顶部内边距的距离，单位 px，如果元素被隐藏则是 0。\nscrollWidth、scrollHeight、scrollLeft、scrollTop scrollWidth：只读属性，表示元素内容的总宽度，包括由于溢出而被隐藏的部分。没有水平滚动条的情况下，scrollWidth 值与元素视图填充所有内容所需要的最小值 clientWidth 相同。 scrollHeight：只读属性，表示元素内容的总高度，包括由于溢出而被隐藏的部分。没有垂直滚动条的情况下，scrollHeight 的值与元素视图填充所有内容所需要的最小值 clientHeight 相同。 scrollLeft：可读可写，代表在有滚动条时，滚动条向右（向左）滚动的距离也就是元素左边（右边）被遮住部分的宽度。在没有滚动条时 scrollLeft = 0。 scrollTop：可读可写，代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时 scrollTop = 0。\n应用 判断是否有垂直滚动条 如果 scrollHeight = clientHeight 则表示没有垂直滚动条。\n判断是否有水平滚动条 如果 scrollWidth = clientWidth 则表示没有水平滚动条。\n判断滚动区域是否滚动到底 scrollTop + clientHeight \u003e= scrollHeigh，scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的，因此确定滚动区域是否滚动到底的唯一方法是查看滚动量是否足够接近某个阈值：\nMath.abs(element.scrollHeight - element.clientHeight - element.scrollTop) \u003c 1 tabindex tabindex 全局属性，表示元素是否可以被聚焦，以及是否能用 Tab 键选中。MDN Web Docs (tabindex)。\n支持聚焦的元素 \u003cbutton\u003e 有 herf 属性的 \u003ca\u003e 有 herf 属性的 \u003clink\u003e type 不是 hidden 的 \u003cinput\u003e \u003cselect\u003e \u003ctextarea\u003e 默认情况下，在使用 Tab 键聚焦元素时，聚焦顺序等于元素在源当前 DOM 中的先后顺序。\ntabindex 的值 tabindex=负值 (例如 tabindex=\"-1\")，表示元素不会被 Tab 键选中，但可以通过 JavaScript 聚焦。 tabindex=\"0\"，将元素添加到正常的 Tab 顺序中，它的相对顺序是当前处于的 DOM 结构来决定的。 tabindex=正值，可以指定元素的 Tab 顺序，数值越小，越先被选中。如果多个元素拥有相同的 tabindex，它们的相对顺序按照他们在当前 DOM 中的先后顺序决定。tabindex=0 的顺序会被放到最后。 例如：1,1,2,2,2,2,3,4,5,0,0,0 ...。tabindex 的值是非法值或者**没有设置 tabindex**的元素，也是放到最后。 div 默认情况下是不会被聚焦的，就可以添加属性 tabindex，让 div 元素可以被聚焦。如果在 div 上设置了 tabindex 属性，它的子元素内容不能使用箭头键来滚动，除非在内容上也设置 tabindex。","user-select#user-select":" user-select：设置文本是否可以被选中。默认值 auto。 auto：可以被选中。 none：不能被选中。 ","换行与溢出#换行与溢出":"","文本的水平对齐和垂直对齐#文本的水平对齐和垂直对齐":"","渐变#渐变":"","滚动属性#滚动属性":"","滤镜属性#滤镜属性":""},"title":"其他属性"},"/frontend-learn/docs/guide/html/06_selector/":{"data":{"":"","优先级#优先级":"特指性等级 选择器 特指性等级 通用选择器，关系选择器（+、\u003e、~），否定伪类（:not()） 0 标签选择器和伪元素 1 Class 选择器，属性选择器，伪类 2 ID 选择器 3 内联样式 4 !important 5 特指性等级数值越大，优先级越高。!important 是最高优先级。内联样式仅次于 !important。\n值计算 每一段 CSS 语句的选择器都可以对应一个具体的数值，数值越大优先级越高。\n一个 0 级选择器优先级数值 +0。 一个 1 级选择器优先级数值 +1。 一个 2 级选择器优先级数值 +10。 一个 3 级选择器优先级数值 +100。 示例：\n选择器 计算值 * 0 button 1 ul \u003e li 1+0+1 a:not([target=\"_blank\"]) 1+0+10 #list .item p 100+10+1 ","伪元素选择器#伪元素选择器":"伪元素用于创建一些不在 DOM 树中的元素，‌并为其添加样式。‌虽然用户可以看到这些元素，但是这些文本实际上不在 DOM 树中。\n常用的伪元素选择器：\n::before，::after：在一个元素前或后插入一些内容，文字，图片等，‌并添加样式。 ::first-line，::first-letter：可以理解为把元素内的第一行文字或者第一个文字变成一个虚拟元素，‌并添加样式。 ::selection：为选中效果设置样式。 ::placeholder 最新的标准伪元素前面都是 ::，: 不再推荐使用。\nMDN Web Docs (Pseudo-elements)。\n伪元素不能被 JS 获取操控的。\n::before、::after 可以在元素的内容前面或者后面插入新内容。content 属性是必须设置的，否则不会显示在页面中。可以设置为空字符串。\n/* 在每个 h1 元素前面插入一幅图片 */ h1::before { content:url(smiley.gif); } /* 在每个 h1 元素后面插入一幅图片 */ h1::after { content:url(smiley.gif); } /* 在每个 h1 元素后面插入字符 */ h1::after { content: '222'; } /* 可以为空，但是 content 必须在 */ h1::after { content: ''; } 默认情况下，::before、::after 伪元素都是行内元素，这是宽高是无效的，如果需要设置宽高，可以把元素改为块元素：\nh1::after { content: '222'; display: block; /*display: inline-block;*/ width: 100px; height: 100px; } ","伪类选择器#伪类选择器":"伪类可以简单理解为是一种状态，条件，可以通过伪类选择器再配合一些其他选择器来选中页面当中已经存在的元素。\n常用的伪类选择器：\n链接伪类 link：普通的、未被访问的链接。 visited：用户已访问的链接。 用户行为伪类 :hover：鼠标指针位于其上。 :active：用户正在点击的元素。 :focus：元素获得焦点。 输入表单伪类 :enabled：用户可以编辑的元素。 :disabled：用户无法编辑的元素。 :checked：复选框或单选框被选中。 位置/结构伪类 :first-child：选择其父元素的第一个子元素。 :last-child：选择其父元素的最后一个子元素。 :only-child：选择其父元素的唯一子元素。也就是说这个父元素中只有一个子元素。 :only-of-type：选择其父元素中唯一的某个特定类型的元素。 :first-of-type：选择其父元素中第一个的某个特定类型的元素。与 :first-child 不同，:first-of-type 不关心元素是否是第一个子元素，关注的是是否为第一个该类型的子元素。 :last-of-type：选择其父元素中最后一个的某个特定类型的元素。 :nth-child：选择其父元素中第 n 个子元素。n 可以是一个数字，也可以是一个公式（例如 2n+1）。 :nth-last-child：选择其父元素中倒数第 n 个子元素。 :nth-of-type：选择其父元素中第 n 个特定类型的子元素。 :nth-last-of-type：选择其父元素中倒数第 n 个特定类型的子元素。 其他伪类 :root：根元素。 :empty：没有子元素的元素。 MDN Web Docs (Pseudo-classes)。\n状态伪类 状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的。\n状态伪类的顺序很重要，顺序错误可能会导致没有效果。\n例如为链接的不同状态设置样式时，必须按照以下次序规则：\na:hover 必须位于 a:link 和 a:visited 之后，a:active 必须位于 a:hover 之后。\n\u003c!-- 设置四种状态的背景颜色 --\u003e a:link { background-color:#B2FF99; } a:visited { background-color:#FFFF85; } a:hover { background-color:#FF704D; } a:active { background-color:#FF704D; } 结构化伪类 结构化伪类是 CSS3 新增的选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，可以减少 class 和 id 属性的定义，使文档结构更简洁。\n例如 :first-child 用来选择父元素的第一个子元素。\n/* 第一个子元素是 p 元素 */ p:first-child { color:blue; } /* 匹配的 p 元素中的第一个 i 元素 */ p \u003e i:first-child { color:blue; } /* 第一个子元素是 p 元素的任意元素中的所有 i 元素 */ p:first-child i { color:blue; } :lang() :lang() 是一个功能强大的伪类，用于根据 HTML 元素的 lang 属性匹配特定语言的内容。\n:lang(en) { font-family: 'Arial', sans-serif; color: blue; } :lang(zh) { font-family: 'Noto Sans SC', sans-serif; color: red; } ","关系选择器#关系选择器":" 选择器 含义 示例 A B 后代选择器 div p { color: #f00; }、#nav li { display: inline; } A \u003e B 直接子元素选择器 div \u003e p { color: #f00; } A + B 相邻兄弟选择器，两个挨着的同级元素 div + p { color: #f00; } A ~ B 通用兄弟选择器，只要是同级的元素，不需要紧挨着 div ~ p { color: #f00; } ","多元素选择器#多元素选择器":"A,B 多元素选择器，同时匹配所有 A 元素或 B 元素，, 分隔。","概述#概述":" 通用选择器，* 匹配任何元素。 标签选择器，匹配所有对应标签的元素。 类名选择器，匹配所有 class 属性中包含对应类名的元素。 ID 选择器，匹配 id 属性等于指定值的元素。 属性选择器 [attr]：存在某个属性，无论该属性有没有值 [attr=value]：属性等于特定值 [attr~=value]：属性具有多个空格分隔的值中的一个。例如一个元素具有属性 class=\"btn btn-primary\"，那么可以被 [class~=\"btn\"] 所匹配。 [attr|=value]：属性值是特定值或以 {值}- 开始。例如选择器 [title|=\"hello\"]： 一个元素具有属性 title=\"hello\"，可以匹配 一个元素具有属性 title=\"hello-1\"，可以匹配 一个元素具有属性 title=\"hello1\"，不可以匹配 [attr^=value]：属性值以特定值开始。例如选择器 [title^=\"hello\"]： 一个元素具有属性 title=\"hello\"，可以匹配 一个元素具有属性 title=\"hello-1\"，可以匹配 一个元素具有属性 title=\"hello1\"，可以匹配 [attr$=value]：属性值以特定值结束。例如选择器 [title$=\"abc\"]： 一个元素具有属性 title=\"hello\"，不可以匹配 一个元素具有属性 title=\"hello-abc\"，可以匹配 一个元素具有属性 title=\"helloabc\"，可以匹配 [attr*=value]：属性值包含特定值。例如选择器 [title*=\"abc\"]： 一个元素具有属性 title=\"heabcllo\"，可以匹配 一个元素具有属性 title=\"hello-abc\"，可以匹配 一个元素具有属性 title=\"helloabc\"，可以匹配 一个元素具有属性 title=\"abchello\"，可以匹配 ","组合选择器#组合选择器":"例如 h1.test[title*=\"abc\"]，这是一个组合选择器，表示含有 class=test 和符合 [title*=\"abc\"] 的 h1 标签。\n组合选择器的顺序是可以随意的，但是标签选择器因为没有特定的前缀符号，所以只能放在第一个，例如 .testh1 会被认为是 class=testh1。"},"title":"CSS 选择器"},"/frontend-learn/docs/guide/html/07_responsive/":{"data":{"":"","flex-布局和-grid-布局中元素的逐步变化#Flex 布局和 Grid 布局中元素的逐步变化":"Flex 布局和 Grid 布局中的子元素都是可以缩放的。\nFlex 布局子元素的逐步变化主要是利用两个属性：\nflex-grow：默认值 0。占据剩余空间的份数。flex-grow: 1 就表示占据剩余空间的 1 份。 flex-shrink：默认值 1。当子元素的大小超过了主轴或者侧轴，那么设置了 flex-shrink 的子元素就会自动收缩。如果设置了换行，那么这个属性就没有用了。 Grid 布局子元素的逐步变化主要时在划分网格时，grid-template-columns 和 grid-template-rows 值的设定使用 fr、%、auto 等单位。","supports#@supports":"@supports 规则用于检查浏览器是否支持某个 CSS 属性或属性值，从而实现特性检测（Feature Detection）。如果支持该属性，则应用 @supports 内部的 CSS 规则，否则忽略。\n基本用法：\n@supports @supports (display: grid) { .container { display: grid; grid-template-columns: 1fr 1fr; } } 如果浏览器支持 display: grid，则 .container 使用网格布局，否则不生效。\n@supports not（检测不支持的属性）： @supports not (display: grid) { .container { display: flex; flex-direction: column; } } 如果浏览器不支持 display: grid，则 .container 使用 flex 布局。\n@supports and（同时满足多个条件）： @supports (display: grid) and (gap: 10px) { .container { display: grid; gap: 10px; } } 同时支持 display: grid 和 gap: 10px 时，才会应用此规则。\n@supports or（至少满足一个条件）： @supports (display: grid) or (display: flex) { .container { display: flex; } } 如果浏览器支持 grid 或 flex 之一，则 .container 使用 flex 布局。\n复杂逻辑（组合 and、or、not）： @supports ((display: grid) and (gap: 10px)) or ((display: flex) and (justify-content: space-between)) { .container { color: red; } } 如果支持 grid 且 gap，或 如果支持 flex 且 justify-content: space-between 那么 .container 文字颜色变红。 selector() 函数： selector() 函数可以用来检测某个选择器是否有效。\n@supports not selector(::-webkit-scrollbar) { * { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); } } 如果浏览器不支持 ::-webkit-scrollbar 伪类选择器，则应用此规则。","利用单位实现元素的逐步变化#利用单位实现元素的逐步变化":"实现元素尺寸的逐步变化，最常用的单位就是 % 和 vh、vw 等视窗单位。如果想要元素跟随父元素的尺寸逐步变化，那么可以使用 % 来实现。如果想要元素跟随视窗的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。\nvh 和 vw 相对于浏览器整个显示区域的尺寸，但是对于移动端设备，这个尺寸是包括地址栏和功能栏的。例如，一个元素设置了 100vh 的高度，在移动端浏览器中，元素的一部分是会被地址栏工具栏覆盖的。这个时候就可以使用移动端专用的视窗单位：\nlvh、lvw：l 表示 large。 svh、svw：s 表示 small。 dvh、dvw：d 表示 dynamic。 详细的使用方式：CSS 新 Viewport 视口单位 svh、lvh 和 dvh\n文字大小的逐步变化 文字大小的尺寸设置一般是用 px，em 和 rem，这三种单位都可以算是固定单位。因为 em 是相对于父元素的字体大小。rem 是相对于根元素（html 标签）的字体大小。也就是说如果父元素或者根元素的字体大小不变，那么利用 em 或 rem 设置尺寸的元素的内部元素的文字大小肯定也不会变化。\n如果想要文字的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。\n通常，文字是不需要根据页面尺寸变化而变化的。","图片的处理#图片的处理":"图片在做响应式处理时，是比较特殊的。图片一般分两类，矢量图（svg）和位图（jpg、png、gif 等）。矢量图不管放大还是缩小都不会影响显示的。但是位图随着放大超过自身的分辨率，是会变的模糊的。\n所以对于位图，一般会使用 @media 媒体查询来处理。对于不同显示尺寸，准备不同分辨率的图片。\n为什么不准备一个高分辨率的图片，而是准备多个分辨率的图片？\n对于显示尺寸较小的设备，加载大分辨率的图片，图片可能几兆甚至十几兆，这会导致页面加载速度变慢，并且客户端访问时会去服务器下载，耗费大量的服务器带宽。\n如何准备不同分辨率的图片 如果一个图片在页面上展示的尺寸是 400px*300px，那么根据屏幕的 DPR 来计算实际需要的图片的分辨率。\n如果屏幕的 DPR 是 1，那么需要的图片分辨率就是 400px*300px。如果屏幕的 DPR 是 2，那么需要的图片分辨率就是 800px*600px。\n需要展示的尺寸（逻辑像素）* 屏幕 DPR =\u003e 需要的图片原始分辨率 图片响应式处理 图片响应式处理主要有四种方式\nimg 标签 \u003cimg\u003e 标签引入了 srcset 属性，srcset 属性用来指定多张图片，适应不同像素密度的屏幕。\n示例：\n\u003cimg src=\"small-640.jpg\" srcset=\" small-640.jpg 640w, medium-1280.jpg 1280w, large-1920.jpg 1920w\" alt=\"\"\u003e 上面的示例 srcset 属性给出了三个图片 URL，适应三种不同的像素密度。图片 URL 空格后面的是像素密度描述符或者宽度描述符（如 640w，w 表示 width。）。\n像素密度描述符，格式是像素密度倍数（DPR） + 字母x。1x 表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度（DPR），选择需要加载的图片。\n如果 srcset 属性中的图片都不满足条件，那么就加载 src 属性指定的默认图片。\n像素密度的适配，是根据整个屏幕的宽度来计算的，这样可能会导致实际使用的图片分辨率会比需要的分辨率大很多。例如：\n\u003cimg src=\"small-640.jpg\" srcset=\" small-640.jpg 640w, medium-1280.jpg 1280w, large-1920.jpg 1920w\" style=\"width: 50%\" alt=\"\"\u003e 图片设置了宽度为 50%，实际使用的图片分辨率会大很多。这时就需要使用 sizes 属性。\nsizes 属性列出不同设备的图片显示宽度.\nsizes 属性的值是一个逗号 , 分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图片的显示宽度。\n\u003cimg srcset=\"foo-160.jpg 160w, foo-320.jpg 320w, foo-640.jpg 640w, foo-1280.jpg 1280w\" sizes=\"(max-width: 440px) 100vw, (max-width: 900px) 33vw, 254px\" src=\"foo-1280.jpg\"\u003e sizes 属性给出了三种屏幕条件，以及对应的图片显示宽度。宽度不超过 440px 的设备，图片显示宽度为 100%；宽度 441px 到 900px 的设备，图片显示宽度为 33%；宽度 900px 以上的设备，图片显示宽度为 254px。\n浏览器根据当前设备的宽度，从 sizes 属性获得图片的显示宽度，然后从 srcset 属性找出最接近该宽度的图片，进行加载。\n例如当前设备的屏幕宽度是 480px，浏览器从 sizes 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。srcset 属性里面，正好有宽度等于 160px 的图片，于是加载 foo-160.jpg。\npicture、source、img 标签组合 如果要同时考虑屏幕尺寸和像素密度的适配，就要用到 \u003cpicture\u003e 标签。\n\u003cpicture\u003e \u003csource srcset=\"homepage-person@desktop.png, homepage-person@desktop-2x.png 2x\" media=\"(min-width: 990px)\"\u003e \u003csource srcset=\"homepage-person@tablet.png, homepage-person@tablet-2x.png 2x\" media=\"(min-width: 750px)\"\u003e \u003cimg srcset=\"homepage-person@mobile.png, homepage-person@mobile-2x.png 2x\" alt=\"Shopify Merchant, Corrine Anestopoulos\"\u003e \u003c/picture\u003e 浏览器按照 \u003csource\u003e 标签出现的顺序，依次判断当前设备是否满足 media 属性的媒体查询表达式，如果满足就加载 srcset 属性指定的图片文件，并且不再执行后面的 \u003csource\u003e 标签和 \u003cimg\u003e 标签。\n\u003cimg\u003e 标签是默认情况下加载的图片，用来满足上面所有 \u003csource\u003e 都不匹配的情况。\n\u003cpicture\u003e 标签还可以用来选择不同格式的图片。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图片，否则加载 PNG 图片。\n\u003cpicture\u003e \u003csource type=\"image/svg+xml\" srcset=\"logo.xml\"\u003e \u003csource type=\"image/webp\" srcset=\"logo.webp\"\u003e \u003cimg src=\"logo.png\" alt=\"ACME Corp\"\u003e \u003c/picture\u003e 浏览器按照 \u003csource\u003e 标签出现的顺序，依次检查是否支持 type 属性指定的图片格式，如果支持就加载图片，并且不再检查后面的 \u003csource\u003e 标签了。\nCSS CSS 媒体查询，CSS 样式只针对背景图片。","媒体查询#媒体查询":"媒体查询是 CSS3 中新增的特性，用于根据不同的设备类型，设置不同的样式。\n媒体查询最常用的媒体特征：\nmin-width：大于等于指定宽度。 max-width：小于等于指定宽度。 语法：\n@media not|only mediatype and (mediafeature and|or|not mediafeature) { CSS-Code; } mediatype 媒体类型：\nall：所有设备。 print：用于打印机和打印预览。 screen：用于电脑屏幕，平板电脑，智能手机等。。 speech：应用于屏幕阅读器等发声设备。 only 是为了兼容旧版本的浏览器，如果不写，默认就是 only。\n媒体查询 Level4 已经支持符号 \u003c=，不支持 =\u003e，这种语法更直观，但是由于比较新，老版本的浏览器可能不兼容：\n/* 等同于 @media (max-width: 480px) */ @media (width \u003c= 480px) { } /* 等同于 @media (min-width: 640px) and (max-width: 1200px) */ @media (640px \u003c= width \u003c= 1200px) { h1 { color: #66bbff; } } mediafeature 媒体特征，必须使用 () 包裹起来。\n示例：\n/* 屏幕小于等于 640px 时，改变 h1 的颜色*/ @media screen and (max-width: 640px) { h1 { color: #0055bb; } } /* 屏幕大于等于 1200px 时，改变 h1 的颜色*/ @media screen and (min-width: 1200px) { h1 { color: #264D73; } } /* 屏幕大于等于 640px 并且小于等于 1200px 时，改变 h1 的颜色*/ /* 640px \u003c= width \u003c= 1200px */ @media screen and (min-width: 640px) and (max-width: 1200px) { h1 { color: #66bbff; } } 当多个媒体查询同时匹配时，会按照从上到下的顺序进行匹配。也就是说最后的才会生效。\n移动优先和桌面优先 媒体查询设置的 max-width 或者 min-max 这个宽度的分界点，称为断点（breakpoint）。\n常用的断点：\n宽度 480px 一般是手机设备。 宽度 768px 主流平板设备的基本宽度。 宽度 1024px 主要是大尺寸平板设备，或者比较老的笔记本。 宽度 1280px 笔记本电脑。 宽度 1440px 台式机显示器。 一般选择三个断点就够了，通常是 480px、1024px、1440px。\n常用的断点设置的模式有两种，一种是移动优先，一种是桌面优先。\n移动优先 移动优先，基础 CSS 样式是为移动端设备编写的，然后使用媒体查询 min-width，逐步的为更大的设备添加样式。\n例如：\n.container { display: grid; grid-template-columns: 1fr; grid-template-rows: 100px; grid-auto-rows: 100px; width: 100%; gap: 10px; } @media (min-width: 480px) { .container { grid-template-columns: 1fr 1fr; } } @media (min-width: 1024px) { .container { grid-template-columns: 1fr 1fr 1fr; } } @media (min-width: 1440px) { .container { grid-template-columns: 1fr 1fr 1fr 1fr; } } 桌面优先 桌面优先，基础 CSS 样式是为桌面电脑编写的，然后使用媒体查询 max-width，逐步的为更小的设备添加样式。\n例如：\n.container { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 100px; grid-auto-rows: 100px; width: 100%; gap: 10px; } @media (max-width: 1440px) { .container { grid-template-columns: 1fr 1fr 1fr; } } @media (max-width: 1024px) { .container { grid-template-columns: 1fr 1fr; } } @media (max-width: 480px) { .container { grid-template-columns: 1fr; } } 媒体查询的引入方式 通常会把媒体查询的样式 @media 放到单独的 CSS 文件中（queries.css），然后在需要使用媒体查询的地方，使用导入 CSS 文件。\n还可以在 style 标签上使用 media 属性引入媒体查询的 CSS 文件，例如：\n\u003cstyle media=\"(min-device-width: 300px) and (max-device-width: 500px)\"\u003e .box { width: 100px; height: 100px; background-color: cadetblue; } \u003c/style\u003e 还有一种方式是在 link 标签上使用 media 属性引入媒体查询的 CSS 文件，例如：\n\u003chead\u003e \u003clink rel=\"stylesheet\" href=\"./style1.css\" media=\"(min-device-width: 300px) and (max-device-width: 500px)\" /\u003e \u003c/head\u003e 最后，使用 @import 属性引入媒体查询的 CSS 文件，例如：\n@import url=\"./queries.css\" screen and (max-width: 500px); ","容器查询#容器查询":"容器查询是一种 CSS 特性，主要根据元素所在的容器父元素的大小来设置样式，而不是整个视窗。\n容器查询包含 container-type、container-name 和 container 三个属性。container 是 container-type 和 container-name 的简写属性。\n例如，定义一个容器：\n.parent { background-color: blueviolet; height: 300px; width: 50vw; container-type: size; } .child { background-color: aqua; width: 100%; height: 100px; } @container (min-width: 320px) { .child { background-color: red; } } 上面的示例，@container 是如何知道要查询哪个容器？\n就是声明了 container-type 这个属性，就意味着告诉浏览器，在该元素上创建一个容器上下文，之后可能要查询此容器。\ncontainer-type 属性有三个可选值：\nnormal：默认值。 size：表示容器查询时，既可以查询高度，也可以查询宽度（@container (max-height: 800px) and (max-width: 800px)） inline-size：表示容器查询时，只能查询文字书向的尺寸，通常元素内部的文字都是水平方向书写的，也就是查询宽度。可以使用 writing-mode 修改文字的书写方向。 container-name 用来指定当前容器所对应的容器查询的名称。例如：\n.parent { background-color: blueviolet; height: 300px; width: 50vw; container-type: size; container-name: my-container; } /* 指定查询名称为 my-container 的容器 */ @container my-container (max-width: 800px) {} 这两个属性组合起来，例如：\n.parent { container: size / my-container; /* * 等价于 * container-type: size; * container-name: my-container; */ } 容器查询的单位 cqw：容器查询宽度（Container Query Width）占比。1cqw 等于容器宽度的 1%。例如容器宽度是 1000px，则此时 1cqw 对应的计算值就是 10px。 cqh：容器查询高度（Container Query Height）占比。1cqh 等于容器高度的 1%。 cqi：表示容器查询文字书写方向的尺寸（Container Query Inline-Size）占比。这个是逻辑属性单位，默认情况下等同于 cqw。 cqb：容器查询垂直于文字书写方向尺寸（Container Query Block-Size）占比。同上，默认情况下等同于 cqh。 cqmin：容器查询较小尺寸的（Container Query Min）占比。取 cqw 和 cqh 中较小的一个。 cqmax：表示容器查询较大尺寸的（Container Query Min）占比。取 cqw 和 cqh 中较大的一个。 ","概述#概述":"响应式的目的就是让页面在不同的设备，不同的尺寸上能够正常的合理的显示页面内容。\n使用固定尺寸的方式开发页面，就会碰到尺寸不同导致页面显示不完整等问题：\n电脑端浏览器的显示尺寸是可变的。 不同电脑的显示尺寸不同。 移动端设备屏幕小，尺寸多，浏览器的显示尺寸是固定的。 设备的交互方式不同，例如在电脑浏览器中的 :hover 在移动端是不存在的。 响应式的处理核心是基于浏览器的显示区域的宽度，然后来调整页面中元素的布局和尺寸。\n响应式处理，变化的主要是三个方面：\n元素尺寸 文字、图片 布局结构 交互方式 ","移动端响应式#移动端响应式":"声明视窗的大小：\u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"\u003e\nviewport 声明视窗。只适用于移动端。 width=device-width 宽度等于设备宽度。 initial-scale=1 初始化比例是 1。 minimum-scale=1 最小的缩小比例是 1。 maximum-scale=1 最大的放大比例是 1。 user-scalable=no 用户不允许缩放。 物理分辨率和逻辑分辨率 屏幕的发展，最初是以像素为单位，像素越多，屏幕尺寸也越大，这是一种物理性的变大。但是物理的变大时有限制的，不能过大，所以后来出现了在同样尺寸下放入更多的像素的技术，例如苹果的 Retina 显示屏（高倍屏），5K 的显示屏分辨率是 5120*2880，而普通屏幕的在同样的尺寸下分辨率是 2560*1440。\n如果我们用高倍屏去显示内容，那么就会出现一个问题，就是内容会变小。\n例如下图，如果按照 1:1 的比例去显示，在普通屏幕上占 6 个像素的图片，放到高倍屏还是占据 6 个像素，按照这个逻辑，同样的内容，在高倍屏上显示差不多就是 1/4。\n那么这显然是不合理的，所以操作系统层面就出现了逻辑分辨率，就是一个虚拟的分辨率。对应屏幕的物理分辨率。逻辑分辨率就是为了让高倍屏和普通屏在显示内容时能显示出一样的大小。\n如下图，如果一张图片占 6 个像素，那么在高倍屏时，操作系统会根据高倍屏的逻辑分辨率，把这张图片放大到 24 个像素，这样就不会出现内容变小的情况。\n设备像素比就是逻辑分辨率的宽度（高度）除以物理分辨率的宽度（高度）。对于移动端设备，设备像素比可能更高。设备像素比可以在浏览器的控制台查看，输入 devicePixelRatio 回车即可。\n移动端适配 不同的移动端设备分辨率，尺寸都不同，可以先针对一种设备，以 iphone6 为例，设计好页面的样式之后，设置 content=\"width=375,user-scalable=no\"，禁止用户缩放，指定宽度为 iphone6 的宽度，那么不同分辨率的设备（移动端）都会自适应这个宽度。"},"title":"响应式"},"/frontend-learn/docs/guide/html/08_svg/":{"data":{"":"","概述#概述":"SVG (Scalable Vector Graphics) 可伸缩矢量图形，也即是说不管怎么放大，图形都不会失真。适合在响应式的网站中使用。\n与矢量图相对应的是位图，位图放的比较大的时候就会失真。常见的位图格式如：png、jpg、gif。只要是有图片分辨率的都是位图。位图本质上，它是由一个个像素点组成的。图片文件里保存的是每个像素点的颜色值。所以它一旦放大了之后，相当于让多个像素点显示同一个颜色，这样就会造成模糊的效果。\n矢量图保存的不是每个像素点的颜色值，而是图形的绘制逻辑。所以它本质上是文本文件，体积较小。\nLottieFiles：一个基于 SVG 的开源的动画解决方案，可以直接在网页端，手机端制作动画效果，再导出某种格式的文件。LottieFiles 的 Marketplace 中，有很多的动画效果，可以直接使用。 Rive：基于 Canvas 实现的动画解决方案，大部分动画效果都可以实现，2D，3D。 "},"title":"SVG"},"/frontend-learn/docs/guide/html/09_chrome/":{"data":{"":"","animations#Animations":"Chrome 开发者工具的动画面板，可以查看元素动画效果的细节。\n打开动画面板：\n面板中有三个百分比，选择 10%，动画效果就会变得非常慢，面板中还记录了元素属性发生变化的过程，并且可以手动调节：","chrome-开发者工具#Chrome 开发者工具":"Chrome 的开发者工具查看元素的样式如下图：\n右侧样式的排序，选择器的优先级高的会在上面。\nuse agent stylesheet 是浏览器给元素的默认样式。 :hov 给元素强制加上某种伪类，使元素显示对应的样式。 :cls 给元素添加 class 切换页面的深色模式：\nComputed 包含盒子模型和元素最终显示出来的样式的值。\n如果在修改一些元素的样式，发现不生效时，就可以在列表中，点击对应属性。它会把这个属性相关的所有设置都列出来。列表中的第一个就是最终生效的那个，下面的就是被覆盖的。\n上面的盒子模型的值都是可以修改的。","device-toolbar#Device ToolBar":"\n1：切换移动端模式。 2：添加更多的移动端设备，并且可以添加自定义尺寸的设备。 3：选择自适应模式，设备尺寸可以任意调整。 4：缩放。 5：节流模式，可以模拟网速的快慢，无网络等状态。 6：旋转，模拟屏幕旋转。 媒体查询 打开媒体查询工具：\n打开之后，尺寸下面多了一栏，鼠标悬浮上去会显示，当前的宽度是什么设备的尺寸。\n如果设置了媒体查询，会出现对应的一行，鼠标悬浮上去会显示匹配的规则。\n上图中有三条媒体查询的规则：\n.parent { width: 50vh; height: 50vh; background-color: aqua; } @media (min-width: 600px) { .parent { background-color: blueviolet; } } @media (max-width: 1000px) { .parent { background-color: blueviolet; } } @media (min-width: 600px) and (max-width: 1000px) { .parent { background-color:burlywood; } } 当多个媒体查询同时匹配时，会按照从上到下的顺序进行匹配。也就是说最后的才会生效。","网页截图#网页截图":"Chrome 提供了网页截图的工具，可以将网页截图保存到本地。打开命令行面板，输入 screenshot 命令，然后回车，会出现四个 screenshot 相关的命令：\ncapture full size screenshot：截图整个页面。 capture node screenshot：截图元素。先使用选择页面元素工具在页面中选择某个需要截图的元素，再使用 capture node screenshot 命令，这个元素就会被截图。 capture screenshot：截图当前页面显示区域。 capture area screenshot：截图选中的区域。类似常见的截图工具，出现一个十字，选中区域截图。 "},"title":"Chrome 开发者工具"},"/frontend-learn/docs/guide/javascript/decorator/":{"data":{"getter-和-setter-装饰器#getter 和 setter 装饰器":" function logged(value, { kind, name }) { if (kind === \"method\" || kind === \"getter\" || kind === \"setter\") { return function (...args) { console.log(`starting ${name} with arguments ${args.join(\", \")}`); const ret = value.call(this, ...args); console.log(`ending ${name}`); return ret; }; } } class C { @logged set x(arg) {} } new C().x = 1 // starting x with arguments 1 // ending x ","为什么装饰器不能用于函数#为什么装饰器不能用于函数？":"装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。","属性装饰器#属性装饰器":"属性装饰器的第一个参数是undefined，即不输入值。用户可以选择让装饰器返回一个初始化函数，当该属性被赋值时，这个初始化函数会自动 运行，它会收到属性的初始值，然后返回一个新的初始值。属性装饰器也可以不返回任何值。除了这两种情况，返回其他类型的值都会报错。\nfunction logged(value, { kind, name }) { if (kind === \"field\") { return function (initialValue) { console.log(`initializing ${name} with value ${initialValue}`); return initialValue; }; } // ... } class C { @logged x = 1; } new C(); // initializing x with value 1 ","类方法装饰器#类方法装饰器":" function logged(value, { kind, name }) { if (kind === \"method\") { return function (...args) { console.log(`starting ${name} with arguments ${args.join(\", \")}`); const ret = value.call(this, ...args); console.log(`ending ${name}`); return ret; }; } } class C { @logged m(arg) {} } // 方法装饰器会修改类的方法 // 相当于 // C.prototype.m = logged(C.prototype.m, { // kind: \"method\", // name: \"m\", // static: false, // private: false, // }) new C().m(1); // starting m with arguments 1 // ending m 方法装饰器的第一个参数就是所要装饰的方法。\n方法装饰器可以返回一个新函数，取代原来的方法，也可以不返回值，表示依然使用原来的方法。如果返回其他类型的值，就会报错。\n// replaceMethod 返回了一个新函数，取代了原来的 hello 方法 function replaceMethod() { return function () { return `How are you, ${this.name}?`; } } class Person { constructor(name) { this.name = name; } @replaceMethod hello() { return `Hi ${this.name}!`; } } const robin = new Person('Robin'); robin.hello(), 'How are you, Robin?' 装饰器修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。\nclass Math { @log add(a, b) { return a + b; } } function log(target, name, descriptor) { var oldValue = descriptor.value; descriptor.value = function(arguments) { console.log(`Calling ${name} with`, arguments); return oldValue.apply(this, arguments); }; return descriptor; } const math = new Math(); // passed parameters should get logged now math.add(2, 4); 装饰器第一个参数是类的原型对象，上例是 Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类 的装饰，那种情况时 target 参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。\n如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。\nfunction dec(id){ console.log('evaluated', id); return (target, property, descriptor) =\u003e console.log('executed', id); } class Example { @dec(1) @dec(2) method(){} } // evaluated 1 // evaluated 2 // executed 2 // executed 1 ","类装饰器#类装饰器":" type ClassDecorator = (value: Function, context: { kind: \"class\"; name: string | undefined; addInitializer(initializer: () =\u003e void): void; }) =\u003e Function | void; 类装饰器的第一个参数，就是被装饰的类。第二个参数是上下文对象，如果被装饰的类是一个匿名类，name 属性就为 undefined。\n类装饰器可以返回一个新的类，取代原来的类，也可以不返回任何值。如果返回的不是构造函数，就会报错。\n@testable class MyTestableClass { // ... } function testable(target) { target.isTestable = true; } MyTestableClass.isTestable // true @testable 为 MyTestableClass 这个类加上了静态属性 isTestable。函数的参数 target 是 MyTestableClass 类本身。\n可以在装饰器外面再封装一层函数：\nfunction testable(isTestable) { return function(target) { // 添加静态属性 target.isTestable = isTestable; // 添加实例属性 target.prototype.isTestable = true; } } @testable(true) class MyTestableClass {} MyTestableClass.isTestable // true @testable(false) class MyClass {} MyClass.isTestable // false ","装饰器#装饰器":"装饰器装饰器是一种函数，写成@ + 函数名，可以用来装饰四种类型的值。\n类 类的属性 类的方法 属性存取器（accessor） 装饰器是一个函数：\ntype Decorator = (value: Input, context: { kind: string; name: string | symbol; access: { get?(): unknown; set?(value: unknown): void; }; private?: boolean; static?: boolean; addInitializer?(initializer: () =\u003e void): void; }) =\u003e Output | void; 装饰器函数有两个参数。运行时，JavaScript 引擎会提供这两个参数。\nvalue：所要装饰的值，某些情况下可能是 undefined（装饰属性时）。 context：上下文信息对象。 装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。"},"title":"decorator"},"/frontend-learn/docs/guide/javascript/event_loop/":{"data":{"javascript-event-loop#JavaScript Event Loop":"JavaScript Event LoopJavaScript 单线程的。那么，为什么 JavaScript 不能有多个线程？\nJavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点， 这时浏览器应该以哪个线程为准？为了避免复杂性，从一诞生，JavaScript 就是单线程。\nHTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。","任务队列#任务队列":"单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。\nJavaScript 主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再把挂起的任务继续执行下去。\n于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\n异步执行的运行机制：\n（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n（2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n（4）主线程不断重复上面的第三步。\n事件 “任务队列\"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在\"任务队列\"中添加一个事件，表示相关的异步任务可以进入\"执行栈\"了。\n除了 IO 设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。\nEvent Loop 线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。\n定时器 定时器功能主要由 setTimeout 和 setInterval 这两个函数来完成。\nsetTimeout 只是将事件插入了\"任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以 并没有办法保证，回调函数一定会在 setTimeout 指定的时间执行。"},"title":"event_loop"},"/frontend-learn/docs/guide/javascript/web/":{"data":{"cookie#cookie":"在客户端和服务器之间传递少量数据。 需要服务器读取的信息，例如会话标识 (Session ID)。 用户偏好设置存储，例如主题选择或语言设置。\n体积较小，适合存储少量信息。 支持设置过期时间和作用域。 域和路径 在设置 Cookie 时，域名 (Domain) 和 路径 (Path) 是控制 Cookie 作用范围的两个重要属性。\n设置域名 Set-Cookie: key=value; Domain=example.com 行为规则：\n明确指定域名： 例如：Domain=example.com。 适用于 example.com 和其所有子域（如 sub.example.com）。 未指定 Domain 属性： 默认情况下，Cookie 的作用域是设置该 Cookie 的域名（不包括子域）。 例如，Set-Cookie 由 www.example.com 发出： Cookie 仅适用于 www.example.com，而不适用于 example.com 或 sub.example.com。 如果需要跨子域共享 Cookie，可以设置为主域：\nSet-Cookie: key=value; Domain=example.com 这样，example.com、www.example.com 和 sub.example.com 都可以访问此 Cookie。\n为了限制作用范围，可以设置具体子域：\nSet-Cookie: key=value; Domain=sub.example.com 设置路径 Set-Cookie: key=value; Path=/somepath 行为规则：\n明确指定路径： 例如：Path=/app Cookie 适用于 /app 和其子路径（如 /app/page）。 不适用于 / 或其他路径（如 /admin）。 未指定 Path 属性： 默认路径为设置 Cookie 的 URL 路径（不包括文件名部分）。 例如，https://example.com/docs/page.html 设置的 Cookie，默认路径为 /docs/。 ","cookiesessionstoragelocalstorage#cookie、sessionStorage、localStorage":"基本特性对比：\n特性 cookie sessionStorage localStorage 数据生命周期 过期时间可设置，默认为会话结束时删除 仅在当前会话有效，关闭浏览器后清除 持久存储，除非手动清除，否则不会过期 数据存储大小 通常最大 4KB 通常最大 5MB 通常最大 5MB 是否随请求发送 会自动随 HTTP 请求发送给服务器（Cookie 头） 不会 不会 存取方式 document.cookie sessionStorage API localStorage API 作用域 同源同路径（默认） 同源\t同源 安全性 可以通过 HttpOnly 和 Secure 增强安全性 纯客户端存储，受 XSS 攻击威胁 纯客户端存储，受 XSS 攻击威胁 ","localstorage#localStorage":" 持久存储较大的非敏感数据，例如用户设置、缓存数据。 需要长时间保留的数据，如购物车内容。 数据不随浏览器关闭而消失，除非手动清除。 ","sessionstorage#sessionStorage":" 存储仅在当前会话有效的数据。 页面刷新时保留数据，但关闭浏览器或标签页后数据会被清除。 比如表单的临时保存、会话中用户选择的某些状态。 数据隔离于单个标签页或窗口。 ","web-api#Web API":"Web API"},"title":"web"},"/frontend-learn/docs/guide/typescript/01_js_c/":{"data":{"静态语言和动态语言#静态语言和动态语言":"静态语言和动态语言静态语言在编译阶段确定所有变量的类型，动态语言在运行阶段确定变量的类型。\n从内存分配的角度，以 js 和 c++ 为例：\nClass C { constructor(x, y) { this.x = x; this.y = y; } } class C { public: int x; int y; } Javascript：\n在程序运行时，动态计算属性的偏移量 需要额外的空间存储属性名 所有对象的偏移量信息各存一份 C++：\n编译阶段确定属性偏移量 用偏移量访问代替属性访问 偏移量信息共享 "},"title":"01_js_c"},"/frontend-learn/docs/guide/typescript/02_env/":{"data":{"":" # 创建 tsconfig.json tsc --init # 编译 ts 文件，输出 js 文件 tsc \u003cfilepath\u003e/\u003cfilename\u003e.ts npm install webpack webpack-cli webpack-dev-server ts-loader typescript -D npm install html-webpack-plugin -D # index.html html:5 npm install clean-webpack-plugin -D npm install webpack-merge -D npm start npm run build "},"title":"02_env"},"/frontend-learn/docs/guide/typescript/03_base_type/":{"data":{"原始类型#原始类型":"原始类型Javascript 声明变量：\nlet num = 1; TypeScript 语法与 JavaScript 语法的区别在于，可以在 TypeScript 中显式声明变量 num 是数字类型：\n// number 表示数字类型，: 用来分割变量和类型的分隔符 let num: number = 1; ","原始类型-1#原始类型":"JavaScript 中，原始类型指的是非对象且没有方法的数据类型，它包括 string、number、bigint、boolean、undefined 和 symbol 六种。\nnull 是一个伪原始类型，它在 JavaScript 中实际上是一个对象，且所有的结构化类型都是通过 null 原型链派生而来。\nJavaScript 和 TypeScript 中原始类型值是最底层的实现。\n字符串 string 表示 JavaScript 中任意的字符串（包括模板字符串）\nlet firstname: string = 'Captain'; // 字符串字面量 let familyname: string = String('S'); // 显式类型转换 let fullname: string = `my name is ${firstname}.${familyname}`; // 模板字符串 数字 number 类型表示十进制整数、浮点数，以及二进制数、八进制数、十六进制数：\n/** 十进制整数 */ let integer: number = 6; /** 十进制整数 */ let integer2: number = Number(42); /** 十进制浮点数 */ let decimal: number = 3.14; /** 二进制整数 */ let binary: number = 0b1010; /** 八进制整数 */ let octal: number = 0o744; /** 十六进制整数 */ let hex: number = 0xf00d; bigint 类型表示大整数：\nlet big: bigint = 100n; 虽然 number 和 bigint 都表示数字，但是这两个类型不兼容。\n布尔值 boolean 表示 True 或者 False\nlet TypeScriptIsGreat: boolean = true; Symbol TypeScript 开始支持 Symbol 原始类型，可以通过 Symbol 构造函数，创建一个独一无二的标记；同时，还可以使用 symbol 表示类型：\nlet sym1: symbol = Symbol(); let sym2: symbol = Symbol('42'); TypeScript 还包含 Number、String、Boolean、Symbol 等类型（注意区分大小写），别将它们和小写格式对应的 number、string、boolean、symbol 进行等价。\n枚举 枚举：一组有名字的常量集合。\n接口 接口可以用来约束对象，函数，类的结构和类型，不能改变。\n函数 类 ts 类覆盖了 es6 的类，同时引入了一些其他特性\n类可以相互继承 类可以实现接口，接口只能约束类的 public 属性 接口可以相互继承 接口可以继承类，继承类时会抽离类的 public，private，protected 属性 ","泛型#泛型":"比如一个打印函数：\nfucntion log(str: string): string { console.log(str); return value; } 如果这时候想要这个函数可以接受一个字符串数组，应该怎么办？\n一种方式是使用函数重载：\nfucntion log(value: string): string fucntion log(value: string[]): string[] fucntion log(value: any): any { console.log(value); return value; } 还可以使用联合类型来实现：\nfucntion log(value: string | string[]): string | string[] { console.log(value); return value; } 如果希望函数可以接受任意类型的参数，可以直接使用 any 类型：\nfucntion log(value: any): any { console.log(value); return value; } 但是 any 类型没有类型约束，函数的参数和返回值的类型可以是不一致的，没有了约束。\n那么我们可以利用泛型来实现：\nfunction log\u003cT\u003e(value: T): T { console.log(value); return value; } 类型 T 不需要指定，相当于 any，但是又保证了参数和返回值的类型是一致的。\n泛型的好处：\n函数和类可以很简单的支持多种类型，增强了扩展性 不必谢多条函数重载 灵活控制类型之间的约束 ","索引签名#索引签名":"{[key: string]: string} 语法是 TypeScript 中的索引签名，代表一个键值结构，当我们事先不知道类型属性的所有名称但知道值的类型时使用。 索引签名可以指定键和值的类型。\n// function returning index signature // (a key-value structure with key and value strings) function getObj(): { [key: string]: string } { return { name: 'Tom', country: 'Chile' }; } // Interface using index signature interface Person { [index: string]: string; } const p1: Person = { name: 'Tom', country: 'Chile' }; type Animal = { [index: string]: string; }; const a1: Animal = { name: 'Alfred', type: 'dog' }; 向不在联合中的类型添加属性会导致错误：\ninterface Person { [index: string]: string | number; age: number; name: string; // ERROR: Property 'colors' of type 'string[]' is not assignable // to 'string' index type 'string | number'.ts(2411) colors: string[]; } 还可以将索引签名设置为 readonly：\ninterface ReadonlyObj { readonly [index: string]: string; } const obj: ReadonlyObj = { name: 'Tom', country: 'Chile', }; // Index signature in type 'ReadonlyObj' // only permits reading. obj.name = 'Alfred'; "},"title":"03_base_type"},"/frontend-learn/docs/guide/typescript/04_complex_type/":{"data":{"":"","-和-#? 和 !":"可选属性 ? height?: number; 等价于 height: number | undefined;\n非空断言 ! ! 表成员不会为 null 或 undefined","交叉类型和联合类型#交叉类型和联合类型":"交叉类型就是指将多个类型合并为一个类型，新的类型具有所有的类型的特性。","映射类型#映射类型":"映射类型 可以从一个旧的类型生成一个新的类型\n映射类型 本质上就是预先定义的泛型接口，通常还会结合索引类型，获取对象的属性和属性值，从而映射成我们想要的结构。","条件类型#条件类型":"由条件表达式所决定的类型：T extends U ? X : Y 意思就是如果类型 T 可以被赋值给类型 U，那么得到的结果就是类型 X，否则就是类型 Y。\n条件类型使类型不是唯一性的，增加了灵活性。","类型检查#类型检查":"类型检查 类型推断 不需要指定变量的类型或函数返回值的类型，ts 可以自动的推断出一个类型。\n基础类型推断 最佳通用类型推断 上下文类型推断 类型兼容性 当一个类型 Y 可以被赋值为另一个类型 X 时，就可以说类型 X 兼容类型 Y。\n类型保护 ts 能够在特定的区块中保证变量属于某种确定的类型。可以在此区块中放心的引用此类型的属性，或者方法。","索引类型#索引类型":""},"title":"04_complex_type"},"/frontend-learn/docs/guide/typescript/05_module/":{"data":{"es6-和-commonjs-的模块系统#ES6 和 CommonJs 的模块系统":"ES6 和 CommonJs 的模块系统Node.js 使用的是 CommonJs 模块系统\nnode 命令不能直接运行 ts 文件，可以把 ts 编译成 js 文件，也可以使用 ts-node 工具。\n通过 ts-node 命令可以直接运行 ts 文件。如 ts-node ./ts-project/src/node/c.ts。\nts 对 ES6 和 CommonJs 的模块系统都可以支持。\n生产环境中，如何处理两种模块系统？\n在配置文件 tsconfig.json 中的配置选项：\ncompilerOptions.target 需要编译成的目标语言的版本 compilerOptions.module 需要把代码编译成的目标模块系统 也可以在命令行中指定这两个选项，如，tsc ./ts-project/src/es6/a.ts -t es5，-t 就是 target。\ntsc ./ts-project/src/es6/a.ts -m amd，-m 就是 module。","顶级导出#顶级导出":"ES6 的顶级导出 export default 命令用于指定模块的默认输出（顶级导出）。显然，一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令。\n本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。\nCommonJs 的顶级导出 CommonJs 中一个模块只允许一个顶级导出，也就是 module.exports，如果一个模块有次级导出，就不能有顶级导出，否则顶级导出会覆盖次级导出。\n例如文件 b.js：\nexoprts.c = 3 exports.d = 4 module.exports = {} 文件 c.js：\nlet c2 = require('./b') c2 是 {}"},"title":"05_module"},"/frontend-learn/docs/guide/typescript/06_namespace/":{"data":{"":"","tsconfig#tsconfig":"","命名空间#命名空间":"","声明合并#声明合并":"","声明文件#声明文件":"","编译工具#编译工具":"命名空间 命名空间可以避免全局污染。在引入一些全局的类库时，可以通过命名空间来解决全局污染的问题。\n命名空间不要和模块混用。命名空间最好在一个全局环境中使用。\n声明合并 声明合并是指把多个地方具有相同名称的声明合并到一起。例如在代码的多个地方定义了同样名称的接口，声明合并可以避免遗漏。\n声明文件 声明文件是 ts 用来引入外部类库的。\n对于引入的非 ts 类库，必须为其编写声明文件，暴露其 API。\n有时候一些类库的源码中就已经包含了声明文件。但是有一些的类库的声明文件是单独提供的，需要另外安装。\n大多数的类库声明文件，社区都有提供。可以安装一个类型声明包 @types/\u003cpackage\u003e，例如 @types/jquery。\n开发中如果想要查找一个非 ts 类库的声明文件可以通过这个：Type Search\n如果没有，就需要自己去写声明文件。\ndeclare 可以声明一个外部变量。\n三种类库：global，module，umd\ntsconfig 文件相关的选项 { \"files\": [ // \"src/a.ts\" ], // 编译器需要编译的单个文件列表 \"include\": [ // \"src\" // 编译 src 目录及其子目录下的文件 // \"src/*\" // 编译 src 一级子目录下的文件 // \"src/*/*\" // 编译 src 二级子目录下的文件 ], // 编译器需要编译的文件或者目录列表 \"exclude\": [ // \"src/libs\" ], // 编译器需要排除的文件或者目录列表 } 配置文件之间是可以继承的，可以把基础的配置抽取出来，然后通过 extends 来导入：\n{ \"extends\": \"./tsconfig.base.json\", \"exclude\": [] // 这会覆盖基础文件中的配置选项 } 编译相关的选项 { \"compilerOptions\": { // \"incremental\": true, // 增量编译，在编译后生成存储编译信息的文件，下次编译时可以使用，来提高编译的效率 // \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置 // \"diagnostics\": true, // 打印诊断信息 // \"target\": \"es5\", // 目标语言的版本 // \"module\": \"commonjs\", // 生成代码的模块标准 // \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在 AMD 模块中 // \"lib\": [], // TS 需要引用的库，即声明文件，es5 默认 \"dom\", \"es5\", \"scripthost\" // \"allowJs\": true, // 允许编译 JS 文件（js、jsx） // \"checkJs\": true, // 允许在 JS 文件中报错，通常与 allowJS 一起使用 // \"outDir\": \"./out\", // 指定输出目录 // \"rootDir\": \"./\", // 指定输入文件目录（用于输出） // \"declaration\": true, // 自动生成声明文件 // \"declarationDir\": \"./d\", // 声明文件输出的路径 // \"emitDeclarationOnly\": true, // 只生成声明文件，不会生成 js 文件 // \"sourceMap\": true, // 生成目标文件的 sourceMap // \"inlineSourceMap\": true, // 生成目标文件的 inline sourceMap // \"declarationMap\": true, // 生成声明文件的 sourceMap // \"typeRoots\": [], // 声明文件目录，默认 node_modules/@types // \"types\": [], // 指定需要加载的声明文件包，如果指定某一个包，就只会加载指定的这个包的声明文件 // \"removeComments\": true, // 删除注释 // \"noEmit\": true, // 不输出文件，相当于什么也没做 // \"noEmitOnError\": true, // 发生错误时不输出任何文件 // \"noEmitHelpers\": true, // 不生成 helper 函数（需额外安装 ts-helpers，可以使用 importHelpers 替代） // \"importHelpers\": true, // 通过 tslib 引入 helper 函数，文件必须是模块 // \"downlevelIteration\": true, // 降级遍历器的实现（如果目标语言是 es3/5，遍历器会有一个比较低级的实现） // \"strict\": true, // 开启所有严格的类型检查，如果开启，下面所有 strcit 相关的选项都是 true // \"alwaysStrict\": false, // 在代码中注入 \"use strict\"; // \"noImplicitAny\": false, // 不允许隐式的 any 类型 // \"strictNullChecks\": false, // 不允许把 null、undefined 赋值给其他类型变量 // \"strictFunctionTypes\": false, // 不允许函数参数双向协变 // \"strictPropertyInitialization\": false, // 类的实例属性必须初始化 // \"strictBindCallApply\": false, // 严格的 bind/call/apply 检查 // \"noImplicitThis\": false, // 不允许 this 有隐式的 any 类型 // 下面四个是函数相关的，是 warning // \"noUnusedLocals\": true, // 检查只声明，未使用的局部变量 // \"noUnusedParameters\": true, // 检查未使用的函数参数 // \"noFallthroughCasesInSwitch\": true, // 防止 switch 语句贯穿（语句贯穿是指：switch 语句的分支中，如果分支没有 break 语句，分支语句会一次执行） // \"noImplicitReturns\": true, // 每个分支都要有返回值 // \"esModuleInterop\": true, // 允许 export = 导出，由 import from 导入 // \"allowUmdGlobalAccess\": true, // 允许在模块中访问 UMD 全局变量 // \"moduleResolution\": \"node\", // 模块解析策略，可选值还有 \"classic\"（对应 AMD，System，ES6） // \"baseUrl\": \"./\", // 解析非相对模块的基地址 // \"paths\": { // 路径映射，相对于 baseUrl // \"jquery\": [\"node_modules/jquery/dist/jquery.slim.min.js\"] // }, // \"rootDirs\": [\"src\", \"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，编译器认为这多个目录在一个目录下 // \"listEmittedFiles\": true, // 打印输出的文件 // \"listFiles\": true, // 打印编译的文件（包括引用的声明文件） } } 工程引用 有时候会在一个 repo 中，存放多个需要单独构建的工程。如 ts-project/src/reference/old 目录下有三个工程：client server common。\n在 old 目录下运行编译命令：tsc。这个时候编译的结果是：\n- dist - src - client - server - common 如果不想要 src 目录，可以加上 include：\n{ \"compilerOptions\": { \"target\": \"es2016\", \"module\": \"commonjs\", \"strict\": true, \"outDir\": \"./dist\" }, \"include\": [\"src\"] } 生成的目录结构是：\n- dist - client - server - common 上面的方式并不能单独构建 client 或者 server，工程引用可以解决上面的问题。如 ts-project/src/reference/new。\n这个目录在每个工程下创建自己的 tsconfig。new 目录下的 tsconfig：\n{ \"compilerOptions\": { \"target\": \"es2016\", \"module\": \"commonjs\", \"strict\": true, \"composite\": true, // 表示工程可以被引用，支持增量编译 \"declaration\": true, // \"outDir\": \"./dist\" // 去掉 outDir 又各个工程自己指定 } } client 目录下的 tsconfig：\n{ \"extends\": \"../../tsconfig.json\", // 继承了基础的 tsconfig \"compilerOptions\": { \"outDir\": \"../../dist/client\", // 指定了输出目录 }, \"references\": [ // 配置依赖的工程 { \"path\": \"../common\" } ] } 单独构建 server 工程： tsc --build src/server --verbose 单独构建 client 工程： tsc --build src/client --verbose\n编译工具 "},"title":"06_namespace"},"/frontend-learn/docs/guide/typescript/07_lint/":{"data":{"eslint-插件#ESLint 插件":"vs code 可以安装 ESLint 插件来执行代码检查。还可以在保存文件时，自动修复代码。","tslint-和-eslint#TSLint 和 ESLint":"TSLint 和 ESLintts 官方已经弃用 TSLint 而转向 ESLint。原因 ESLint 的性能刚好，社区支持的也更好。\nts 的编译器可以做类型检查和语言转换，检查语法错误。ESLint 可以检查语法错误和代码风格。两者在功能上有一点重合。\nESLint 对 ts 的语法并不兼容，要使用 ESLint，需要使用 typescript-eslint。这个包对 ESLint 提供了解释 ts 代码的编译器。\n项目中需要安装三个依赖：\neslint @typescript-eslint/eslint-plugin 是 eslint 识别 ts 的语法 @typescript-eslint/parser 为 eslint 提供的解析器 配置文件：\n{ \"parser\": \"@typescript-eslint/parser\", \"plugins\": [\"@typescript-eslint\"], \"parserOptions\": { \"project\": \"./tsconfig.json\" // 有些规则可以使用 tsconfig 里面的信息 }, \"extends\": [ \"plugin:@typescript-eslint/recommended\" // 使用官方推荐的规则 ], \"rules\": { // eslint 希望使用 ts 的类型推断，不声明变量类型，例如 let hello: string = 'hello' // 使用这个配置关闭 \"@typescript-eslint/no-inferrable-types\": \"off\" } } "},"title":"07_lint"},"/frontend-learn/docs/node/":{"data":{"":"Node.js 底层原理、浏览器的原理。\nComing soon …"},"title":"🔍 Node.js 底层原理"},"/frontend-learn/docs/practice/":{"data":{"":"记录 Vite，Cypress 等工具的使用和原理。\nComing soon …"},"title":"🛠️ 前端工程实践"},"/frontend-learn/docs/practice/vuecli3/env/":{"data":{"env-文件与环境设置#env 文件与环境设置":"env 文件与环境设置一般一个项目都会有以下 3 种环境：\n开发环境（开发阶段，本地开发版本，一般会使用一些调试工具或额外的辅助功能） 测试环境（测试阶段，上线前版本，除了一些 bug 的修复，基本不会和上线版本有很大差别） 生产环境（上线阶段，正式对外发布的版本，一般会进行优化，关掉错误报告） 作为一名开发人员，我们可能需要针对每一种环境编写一些不同的代码并且保证这些代码运行在正确的环境中，那么我们应该如何在代码中判断项目所处的环境 同时执行不同的代码呢？这就需要我们进行正确的环境配置和管理。","介绍#介绍":"配置文件 正确的配置环境首先需要我们认识不同环境配置之间的关系，如图所示：\n我们可以在根目录下创建以下形式的文件进行不同环境下变量的配置：\n.env # 在所有的环境中被载入 .env.local # 在所有的环境中被载入，但会被 git 忽略 .env.[mode] # 只在指定的模式中被载入 .env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 比如我们创建一个名为.env.stage的文件，该文件表明其只在stage环境下被加载，在这个文件中，我们可以配置如下键值对的变量：\nNODE_ENV=stage VUE_APP_TITLE=stage mode 这时候我们怎么在 vue.config.js 中访问这些变量呢？很简单，使用process.env.[name]进行访问就可以了，比如：\n// vue.config.js console.log(process.env.NODE_ENV); // development（在终端输出） 当你运行yarn serve命令后会发现输出的是development，因为vue-cli-service serve命令默认设置的环境是development， 你需要修改package.json中的serve脚本的命令为：\n\"scripts\": { \"serve\": \"vue-cli-service serve --mode stage\", } --mode stage其实就是修改了 webpack 4 中的mode配置项为stage，同时其会读取对应.env.[model]文件下的配置，如果没找到对应配置文件， 其会使用默认环境development，同样vue-cli-service build会使用默认环境production。\n这时候如果你再创建一个.env的文件，再次配置重复的变量，但是值不同，如：\nNODE_ENV=staging VUE_APP_TITLE=staging mode VUE_APP_NAME=project 因为.env文件会被所有环境加载，即公共配置，那么最终我们运行vue-cli-service serve打印出来的是哪个呢？答案是stage， 但是如果是.env.stage.local文件中配置成上方这样，答案便是staging，所以.env.[mode].local会覆盖.env.[mode]下的相同配置。 同理.env.local会覆盖.env下的相同配置。\n相同配置项的权重：\n.env.[mode].local \u003e .env.[mode] \u003e .env.local \u003e .env 但是需要注意的是，除了相同配置项权重大的覆盖小的，不同配置项它们会进行合并操作，类似于 Javascript 中的Object.assign的用法。\n环境注入 通过上述配置文件的创建，我们成功使用命令行的形式对项目环境进行了设置并可以自由切换，但是需要注意的是我们在 Vue 的前端代码中打印 出的process.env与 vue.config.js 中输出的可能是不一样的，这需要普及一个知识点： webpack 通过DefinePlugin内置插件将process.env注入到客户端代码中。\n// webpack 配置 { ... plugins: [ new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify(process.env.NODE_ENV) } }), ], ... } 由于 vue-cli 3.x 封装的 webpack 配置中已经帮我们完成了这个功能，所以我们可以直接在客户端代码中打印出process.env的值， 该对象可以包含多个键值对，也就是说可以注入多个值，但是经过 CLI 封装后仅支持注入环境配置文件中以VUE_APP_开头的变量，而NODE_ENV和BASE_URL这两个特殊变量除外。 比如我们在权重最高的.env.stage.local文件中写入：\nNODE_ENV=stage2 VUE_APP_TITLE=stage mode2 NAME=vue 然后我们尝试在 vue.config.js 中打印process.env，终端输出：\n{ ... npm_config_ignore_scripts: '', npm_config_version_git_sign: '', npm_config_ignore_optional: '', npm_config_init_version: '1.0.0', npm_package_dependencies_vue_router: '^3.0.1', npm_config_version_tag_prefix: 'v', npm_node_execpath: '/usr/local/bin/node', NODE_ENV: 'stage2', VUE_APP_TITLE: 'stage mode2', NAME: 'vue', BABEL_ENV: 'development', ... } 可以看到输出内容除了我们环境配置中的变量外还包含了很多 npm 的信息，但是我们在入口文件main.js中打印会发现输出：\n{ \"BASE_URL\": \"/vue/\", \"NODE_ENV\": \"stage2\", \"VUE_APP_TITLE\": \"stage mode2\" } 可见注入时过滤调了非VUE_APP_开头的变量，其中多出的BASE_URL为你在 vue.config.js 设置的值，默认为/，其在环境配置文件中设置无效。\n额外配置 以上我们通过新建配置文件的方式为项目不同环境配置不同的变量值，能够实现项目基本的环境管理，但是.env这样的配置文件中的参数目前只支持静态值， 无法使用动态参数，在某些情况下无法实现特定需求，这时候我们可以在根目录下新建config文件夹用于存放一些额外的配置文件。\n/* 配置文件 index.js */ // 公共变量 const com = { IP: JSON.stringify('xxx') }; module.exports = { // 开发环境变量 dev: { env: { TYPE: JSON.stringify('dev'), ...com } }, // 生产环境变量 build: { env: { TYPE: JSON.stringify('prod'), ...com } } } 上方代码我们把环境变量分为了公共变量、开发环境变量和生产环境变量，当然这些变量可能是动态的，比如用户的 ip 等。 现在我们要在 vue.config.js 里注入这些变量，我们可以使用chainWebpack修改DefinePlugin中的值：\n/* vue.config.js */ const configs = require('./config'); // 用于做相应的 merge 处理 const merge = require('webpack-merge'); // 根据环境判断使用哪份配置 const cfg = process.env.NODE_ENV === 'production' ? configs.build.env : configs.dev.env; module.exports = { ... chainWebpack: config =\u003e { config.plugin('define') .tap(args =\u003e { let name = 'process.env'; // 使用 merge 保证原始值不变 args[0][name] = merge(args[0][name], cfg); return args }) }, ... } 最后我们可以在客户端成功打印出包含动态配置的对象：\n{ \"NODE_ENV\": \"stage2\", \"VUE_APP_TITLE\": \"stage mode2\", \"BASE_URL\": \"/vue/\", \"TYPE\": \"dev\", \"IP\": \"xxx\" } 实际场景 结合以上环境变量的配置，我们项目中一般会遇到一些实际场景： 比如在非线上环境我们可以给自己的移动端项目开启 vConsole 调试， 但是在线上环境肯定不需要开启这一功能，我们可以在入口文件中进行设置，代码如下：\n/* main.js */ import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' Vue.config.productionTip = false // 如果是非正式环境，加载 VConsole if (process.env.NODE_ENV !== 'production') { var VConsole = require('vconsole/dist/vconsole.min.js'); var vConsole = new VConsole(); } new Vue({ router, store, render: h =\u003e h(App) }).$mount('#app') 我们还可以使用配置中的BASE_URL来设置路由的base参数：\n/* router.js */ import Vue from 'vue' import Router from 'vue-router' import Home from './views/Home.vue' import About from './views/About.vue' Vue.use(Router) let base = `${process.env.BASE_URL}`; // 获取二级目录 export default new Router({ mode: 'history', base: base, // 设置 base 值 routes: [ { path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', component: About } ] }) "},"title":"env"},"/frontend-learn/docs/practice/vuecli3/expand/":{"data":{"chrome-插件#Chrome 插件":" Vue.js devtools， 它是 Vue 官方发布的一款调试 Vue 项目的插件，支持数据模拟与调试。 Vue Performance Devtool， 它可以分析我们页面中各个组件的性能情况，从而在其基础上我们可以有针对性的对组件的代码进行优化。 Postman，它是一款非常好用的接口调试工具。 Web Developer， 是一款强大的用于操作网页中各项资源与浏览器的插件，比如一键禁用 JS、编辑 CSS、清除 Cookie 等。 Google PageSpeed Insights API Extension， 是 Google 在全球范围内应用最广的开发者工具之一，作为一款专注于改进网页性能的开发者工具，它主要具有以下两个优势：真实的网页运行速度及优化建议。 FeHelper， 是百度 FE 团队开发的一款前端工具集插件，包含代码压缩／性能检测／字符串编解码等功能，能够帮助我们完成一些琐碎的开发任务。 can-i-use，我们可以使用其来查看某一特性的浏览器支持程度， 确保主流浏览器的支持。 ","ui-库#UI 库":" iview：一套基于 Vue.js 的高质量 UI 组件库（PC端） iView Admin：搭配使用iView UI组件库形成的一套后台集成解决方案（PC端） Element：一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库（PC端） Vue Antd：Ant Design 的 Vue 实现，开发和服务于企业级后台产品（PC端） VueStrap：一款 Bootstrap 风格的 Vue UI 库（PC端） Mint UI：由饿了么前端开发的基于 Vue.js 的移动端组件库（移动端） Vonic：一个基于 vue.js 和 ionic 样式的 UI 框架，用于快速构建移动端单页应用（移动端） Vant：轻量、可靠的移动端 Vue 组件库（移动端） Cube UI：基于 Vue.js 实现的精致移动端组件库（移动端） ","图标库#图标库":" Iconfont，目前最流行的一款图标库。 Font Awesome，世界上最受欢迎且最易于使用的图标集。 Ionicons，精美的开源图标库，可以用于Web，iOS，Android和桌面应用程序。 Themify，一套用于网页设计和应用程序的完整图标。 ","拓展#拓展":"拓展","第三方接口#第三方接口":" 聚合数据，国内领先的基础数据服务商。 高德地图，访问高德地图的 Web API GitHub，世界上领先的软件开发平台 百度翻译，支持多种语言之间的相互翻译 和风天气，中国天气信息 阿凡达数据，提供中国可用的 API "},"title":"expand"},"/frontend-learn/docs/practice/vuecli3/guide/":{"data":{"vue-api-盲点解析#Vue API 盲点解析":"使用 performance 开启性能追踪 performance API 是 Vue 全局配置 API 中的一个，我们可以使用它来进行网页性能的追踪，我们可以在入口文件中添加：\nif (process.env.NODE_ENV !== 'production') { Vue.config.performance = true; } 来开启这一功能，该 API（2.2.0 新增）功能只适用于开发模式和支持 performance.mark API 的浏览器上，开启后我们可以下载 Vue Performance Devtool 这一 chrome 插件来看查看各个组件的加载情况。\n而其在 Vue 源码中主要使用了 window.performance 来获取网页性能数据，其中包含了performance.mark和performance.measure。\nperformance.mark 主要用于创建标记 performance.measure 主要用于记录两个标记的时间间隔 performance.mark('start'); // 创建 start 标记 performance.mark('end'); // 创建 end 标记 performance.measure('output', 'start', 'end'); // 计算两者时间间隔 performance.getEntriesByName('output'); // 获取标记，返回值是一个数组，包含了间隔时间数据 熟练的使用 performance 我们可以查看并分析网页的很多数据，为我们项目优化提供保障。除了上述介绍的两个方法，我们还可以使用 performance.timing 来计算页面各个阶段的加载情况， 关于 performance.timing 的介绍可以查看：利用 Navigation Timing 测量页面加载时间\n使用 errorHandler 来捕获异常 在浏览器异常捕获的方法上，我们熟知的一般有：try ... catch 和 window.onerror，这也是原生 JavaScript 提供给我们处理异常的方式。 但是在 Vue 2.x 中如果你一如既往的想使用 window.onerror 来捕获异常，那么其实你是捕获不到的，因为异常信息被框架自身的异常机制捕获了， 你可以使用 errorHandler 来进行异常信息的获取：\nVue.config.errorHandler = function (err, vm, info) { let { message, // 异常信息 name, // 异常名称 stack // 异常堆栈信息 } = err; // vm 为抛出异常的 Vue 实例 // info 为 Vue 特定的错误信息，比如错误所在的生命周期钩子 } 在入口文件中加入上述代码后，我们便可以捕获到 Vue 项目中的一些异常信息了，但是需要注意的是 Vue 2.4.0 起的版本才支持捕获 Vue 自定义事件处理函数内部的错误，比如:\n\u003ctemplate\u003e \u003cmy-component @eventFn=\"doSomething\"\u003e\u003c/my-component\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { doSomething() { console.log(a); // a is not defined } } } \u003c/script\u003e 使用 Vue 中的异常捕获机制，我们可以针对捕获到的数据进行分析和上报，为实现前端异常监控奠定基础。关于对异常捕获的详细介绍， 感兴趣的同学可以查看：谈谈前端异常捕获与上报\n使用 nextTick 将回调延迟到下次 DOM 更新循环之后执行 在某些情况下，我们改变页面中绑定的数据后需要对新视图进行一些操作，而这时候新视图其实还未生成，需要等待 DOM 的更新后才能获取的到，在这种场景下我们便可以使用 nextTick 来延迟回 调的执行。比如未使用 nextTick 时的代码：\n\u003ctemplate\u003e \u003cul ref=\"box\"\u003e \u003cli v-for=\"(item, index) in arr\" :key=\"index\"\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { arr: [] } }, mounted() { this.getData(); }, methods: { getData() { this.arr = [1, 2, 3]; this.$refs.box.getElementsByTagName('li')[0].innerHTML = 'hello'; } } } \u003c/script\u003e 上方代码我们在实际运行的时候肯定会报错，因为我们获取 DOM 元素 li 的时候其还未被渲染，我们将方法放入 nextTick 回调中即可解决该问题：\nthis.$nextTick(() =\u003e { this.$refs.box.getElementsByTagName('li')[0].innerHTML = 'hello'; }) 当然你也可以使用 ES6 的 async/await 语法来改写上述方法：\nmethods: { async getData() { this.arr = [1, 2, 3]; await this.$nextTick(); this.$refs.box.getElementsByTagName('li')[0].innerHTML = 'hello'; } } 那么接下来我们来分析下 Vue 是如何做到的，其源码中使用了 3 种方式：\npromise.then 延迟调用 setTimeout(func, 0)延迟功能 MutationObserver监听变化 这里主要介绍下MutationObserver这一 HTML5 新特性， 那么什么是MutationObserver呢？用一句话介绍就是：我们可以使用它创建一个观察者对象，其会监听某个 DOM 元素，并在它的 DOM 树发生变化时执行我们提供的回调函数。 实例化代码及配置如下：\n// 传入回调函数进行实例化 var observer = new MutationObserver(mutations =\u003e { mutations.forEach(mutation =\u003e { console.log(mutation.type); }) }); // 选择目标节点 var target = document.querySelector('#box'); // 配置观察选项 var config = { attributes: true, // 是否观察属性的变动 childList: true, // 是否观察子节点的变动（指新增，删除或者更改） characterData: true // 是否观察节点内容或节点文本的变动 }; // 传入目标节点和观察选项 observer.observe(target, config); // 停止观察 observer.disconnect(); 这样我们便可以观察 id 为 box 下的 DOM 树变化，一旦发生变化就会触发相应的回调方法，实现延迟调用的功能。\n使用 watch 的深度遍历和立即调用功能 相信很多同学使用 watch 来监听数据变化的时候通常只使用过其中的 handler 回调，其实其还有两个参数，便是：\ndeep 设置为 true 用于监听对象内部值的变化 immediate 设置为 true 将立即以表达式的当前值触发回调 \u003ctemplate\u003e \u003cbutton @click=\"obj.a = 2\"\u003e修改\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { obj: { a: 1, } } }, watch: { obj: { handler: function(newVal, oldVal) { console.log(newVal); }, deep: true, immediate: true } } } \u003c/script\u003e 以上代码我们修改了 obj 对象中 a 属性的值，我们可以触发其 watch 中的 handler 回调输出新的对象，而如果不加deep: true，我们只能 监听 obj 的改变，并不会触发回调。同时我们也添加了immediate: true配置，其会立即以 obj 的当前值触发回调。\n在 Vue 源码中，主要使用了Object.defineProperty (obj, key, option)方法来实现数据的监听，同时其也是 Vue 数据双向绑定的关键方法之一。示例代码如下：\nfunction Observer() { var result = null; Object.defineProperty(this, 'result', { get: function() { console.log('你访问了 result'); return result; }, set: function(value) { result = value; console.log('你设置了 result = ' + value); } }); } var app = new Observer(); // 实例化 app.result; // 你访问了 result app.result = 11; // 你设置了 result = 11 我们通过实例化了Observer方法来实现了一个简单的监听数据访问与变化的功能。Object.defineProperty是 ES5 的语法，这也就是为什 么 Vue 不支持 IE8 以及更低版本浏览器的主要原因。\n对低开销的静态组件使用 v-once Vue 提供了v-once指令用于只渲染元素和组件一次，一般可以用于存在大量静态数据组件的更新性能优化，注意是大量 静态数据，因为少数情况下我们的页面渲染会因为一些静态数据而变慢。如果你需要对一个组件使用v-once，可以直接在组件上绑定：\n\u003cmy-component v-once :data=\"msg\"\u003e\u003c/my-component\u003e 这时候因为组件绑定了v-once，所以无论 msg 的值如何变化，组件内渲染的永远是其第一次获取到的初始值。因此我们在使用v-once 的时候需要考虑该组件今后的更新情况，避免不必要的问题产生。\n使用$isServer判断当前实例是否运行于服务器 当我们的 Vue 项目中存在服务端渲染（SSR）的时候，有些项目文件可能会同时在客户端和服务端加载，这时候代码中的一些客户端浏 览器才支持的属性或变量在服务端便会加载出错，比如 window、 document 等，这时候我们需要进行环境的判断来区分客户端和服务 端，如果你不知道$isServer，那么你可能会使用try ... catch或者process.env.VUE_ENV来判断：\ntry { document.title = 'test'; } catch(e) {} // process.env.VUE_ENV 需要在 webpack 中进行配置 if (process.env.VUE_ENV === 'client') { document.title = 'test'; } 而使用 $isServer 则无需进行配置，在组件中直接使用该 API 即可：\nif (this.$isServer) { document.title = 'test'; } 其源码中使用了Object.defineProperty来进行数据监测：\nObject.defineProperty(Vue.prototype, '$isServer', { get: isServerRendering }); var _isServer; var isServerRendering = function () { if (_isServer === undefined) { if (!inBrowser \u0026\u0026 !inWeex \u0026\u0026 typeof global !== 'undefined') { _isServer = global['process'].env.VUE_ENV === 'server'; } else { _isServer = false; } } return _isServer }; 当我们访问$isServer属性时，其会调用isServerRendering方法，该方法会首先判断当前环境，如果在浏览器或者 Weex 下则返回 false， 否则继续判断当前全局环境下的process.env.VUE_ENV是否为 server 来返回最终结果。","合理划分容器组件与展示组件#合理划分容器组件与展示组件":"组件的职能划分 如果要将 Vue 组件按照职能划分，我们可以将其分为两种类型：容器组件和展示组件。\n容器组件和展示组件的概念来自于 Redux 文档，那么首先什么是容器组件呢？顾名思义，它是一个容器性质的组件，我们可以把 它理解为最外层的父组件，也就是最顶层的组件，一般我们把它放置在 views 文件夹下，其功能主要用于做数据提取与实现公共逻辑，然后渲染对应的子组件。\n另一类组件叫做展示组件，字面意思就是主要用于做展示的组件，其主要功能是负责接收从容器组件传输过来的数据并在页面上渲染，实现其内部独有的功能逻辑。\n个页面中容器组件与展示组件的关系如下图所示： 以博客首页为例，容器组件就是整个首页最外层的父组件，而展示组件就包含了导航栏、文章列表、底部等子组件，代码层面如下：\n\u003ctemplate\u003e \u003cdiv\u003e \u003cnavigation @count=\"countFn\"\u003e\u003c/navigation\u003e \u003carticle :list=\"articleList\"\u003e\u003c/article\u003e \u003cfoot\u003e\u003c/foot\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { mapActions, mapGetters } from 'vuex'; export default { mounted() { this.SET_BLOG_DATA(); // 调用接口获取数据 }, computed: { ...mapGetters(['articleList']), // 监听 state } methods: { ...mapActions(['SET_BLOG_DATA', 'SET_NAV_COUNT']), countFn(item) { // 调用接口存储导航点击次数并跳转，通过派发 action 的形式来发起 state 变化 this.SET_NAV_COUNT({ type: item.type }); this.$router.push({name: item.route}); } } } \u003c/script\u003e 以上是首页容器组件中的主要代码，其主要做了两件事情：数据的传递和回调的处理，当然还可以包括处理一些该页面中不属于任何一个展示组件的方法， 比如校验登录状态。在一个容器组件中可以包含多个展示组件，下面我们来看一下展示组件 Navigation 中的代码：\n\u003ctemplate\u003e \u003cul\u003e \u003cli v-for=\"(item, index) in nav\" :key=\"index\" @click=\"goNav(item)\" v-text=\"item.name\" \u003e\u003c/li\u003e \u003c/ul\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { nav: [{ name: '首页', route: 'index', type: 'index' }, { name: '文章', route: 'article', type: 'article' }, { name: '关于', route: 'about', type: 'about' }] } }, methods: { goNav(item) { this.$emit('count', item); // 触发回调 } } } \u003c/script\u003e Navigation导航组件只负责自己内部的数据渲染和回调逻辑，对于存储每个导航的点击量及跳转逻 辑来说，作为展示组件这并不是其所关心的，所以我们需要通过触发容器组件回调的方式来实现。再来看一下展示组件Article的代码：\n\u003ctemplate\u003e \u003cul\u003e \u003cli v-for=\"(item, index) in list\" :key=\"index\" @click=\"goPage(item.id)\" v-text=\"item.title\" \u003e\u003c/li\u003e \u003c/ul\u003e \u003c/template\u003e \u003cscript\u003e export default { props: { // 接收容器组件数据 list: { default: [], type: Array } } } \u003c/script\u003e 展示组件 Article 中动态的数据通过props从父组件中获取，其内部只处理文章列表的渲染工作，这样很好的将 UI 层面和应用层面进行了分离，便于今后该组件的复用。\n此外 Foot 组件为纯静态组件，其只负责内部数据的渲染，不接收外部的数据和回调方法，这里就不做介绍了。\n相比较如果上述的博客首页不做组件的划分，全部逻辑都放在一个组件中，那么必然会导致代码的臃肿和难以维护，而一旦划 分了容器组件和展示组件，后期如果哪个页面同样需要展示文章列表，我们只需要传递不同的数据直接复用即可。\n组件的层次结构 关于组件的层次，一般页面中不宜嵌套超过 3 层的组件，因为超过 3 层后父子组件的通信就会变得相对困难，不利于项目的开发和维护。3 层结构的容器组件与展示组件的数据传递如下： 可见组件的层次越深数据传递的过程就会变得越复杂，当然这取决于你如何划分容器组件和展示组件，比如我们可以将上述博客首页换一种划分方式： 上图我们页面中存在 3 个容器组件，每个容器组件又可以包含各自的展示组件，这样一定程度上可以减少组件的层次嵌套深度。当然展示组件中也可以包含对应的容器组件来解决数据传输的问题： 这样展示组件 B 下面的容器组件 C 便可以不依赖于容器组件 A 的数据，其可以单独的进行数据获取和状态更新。\n而对于那些你不知道应该划分为容器组件和展示组件的组件，比如一些耦合度较高的组件，那么你可以暂时归类到其他组件中，混用容器和展示，随着日后功能的逐渐清晰，我们再将其进行划分。","指南#指南":"指南","编写可复用性模块#编写可复用性模块":"封装成一个函数 除了使用变量的赋值缓存使用来解决数据的重复读取外，我们在开发过程中重复性更多的也许是功能点的重复，比如：\n\u003ctempalte\u003e \u003cdiv\u003e \u003cinput type=\"text\" v-model=\"str1\"\u003e \u003cinput type=\"text\" v-model=\"str2\"\u003e \u003cdiv\u003e{{ str1.slice(1).toUpperCase() }}\u003c/div\u003e \u003cdiv\u003e{{ str2.slice(1).toUpperCase() }}\u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 上述代码的重复功能点在于截取输入框中第二个字符开始到最后的值并把它们转化成大写字母，像这样很简单的操作虽然重复使用也不会出现太大的问题， 但是如果是代码量较多的操作呢？重复书写相同功能的代码是一种不经过大脑思考的行为，我们需要对其进行优化，这里我们可以把功能点封装成一个函数：\nexport default { methods: { sliceUpperCase(val) { return val.slice(1).toUpperCase() } } } 如此我们只要在用到该方法的地方调用即可，将值传入其中并返回新值。当然像在双花括号插值和v-bind表达式中重复的功能点我们可以封装成过滤器比较合适：\n// 单文件组件注册过滤器 filters: { sliceUpperCase(val) { return val.slice(1).toUpperCase() } } // 全局注册过滤器 Vue.filter('sliceUpperCase', function (val) { return val.slice(1).toUpperCase() }) 然后在 html 中使用“管道”符进行过滤：\n\u003cdiv\u003e{{ str1 | toUpperCase }}\u003c/div\u003e \u003cdiv\u003e{{ str2 | toUpperCase }}\u003c/div\u003e 这样我们就把重复的功能性代码封装成了函数，而不管是过滤器还是正常的方法封装，其本质都是函数的封装。\n封装成一个组件 相比较于函数的封装，规模更大一点的便是组件的封装，组件包含了模板、脚本以及样式的代码，在实际开发中组件的使用频率也是非常大的，我们项目 中的每一个页面其实都可以看作是一个父组件，其可以包含很多子组件，子组件通过接收父组件的值来渲染页面，父组件通过响应子组件的回调来触发事件。\n封装一个组件主要包含两种方式，一种是最常见的整体封装，用户通过改变数据源来呈现不同的页面状态，代码结构不可定制化。例如：\n\u003cdiv\u003e \u003cmy-component data=\"我是父组件传入子组件的数据\"\u003e\u003c/my-component\u003e \u003c/div\u003e 另一种便是自定义封装，也就是插槽(slot)，我们可以开放一部分槽位给父组件，使其能够进行一定程度的定制化，例如：\n\u003cdiv\u003e \u003cmy-component data=\"我是父组件传入子组件的数据\"\u003e \u003ctemplate slot=\"customize\"\u003e \u003cspan\u003e这是定制化的数据\u003c/span\u003e \u003c/template\u003e \u003c/my-component\u003e \u003c/div\u003e 在 myComponent 组件中我们便可以接收对应的 slot：\n\u003cdiv class=\"container\"\u003e \u003cspan\u003e{{ data }}\u003c/span\u003e \u003cslot name=\"customize\"\u003e\u003c/slot\u003e \u003cdiv\u003e 这里我们通过定义 slot 标签的 name 值为 customize 来接收父组件在使用该组件时在 template 标签上定义的 slot=“customize” 中的代码，不 同父组件可以定制不同的 slot 代码来实现差异化的插槽。最终渲染出来的代码如下：\n\u003cdiv\u003e \u003cdiv class=\"container\"\u003e \u003cspan\u003e我是父组件传入子组件的数据\u003c/span\u003e \u003cspan\u003e这是定制化的数据\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e 这样我们就完成了一个小型组件的封装，将共用代码封装到组件中去，页面需要引入的时候直接使用 import 并进行相应注册即可，当然你也可以进行全局的引入：\nimport myComponent from '../myComponent.vue' // 全局 Vue.component('my-component', myComponent) 封装成一个插件 在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 api 即可，这需要 我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 loading 功能、弹框功能等。\nVue 提供给了我们一个 install 方法来编写插件，使用该方法中的第一个 Vue 构造器参数可以为项目添加全局方法、资源、选项等。比如我们可以给 组件添加一个简单的全局调用方法来实现插件的编写：\n/* toast.js */ import ToastComponent from './toast.vue' // 引入组件 let $vm export default { install(Vue, options) { // 判断实例是否存在 if (!$vm) { const ToastPlugin = Vue.extend(ToastComponent); // 创建一个“扩展实例构造器” // 创建 $vm 实例 $vm = new ToastPlugin({ el: document.createElement('div') // 声明挂载元素 }); document.body.appendChild($vm.$el); // 把 toast 组件的 DOM 添加到 body 里 } // 给 toast 设置自定义文案和时间 let toast = (text, duration) =\u003e { $vm.text = text; $vm.duration = duration; // 在指定 duration 之后让 toast 消失 setTimeout(() =\u003e { $vm.isShow = false; }, $vm.duration); } // 判断 Vue.$toast 是否存在 if (!Vue.$toast) { Vue.$toast = toast; } Vue.prototype.$toast = Vue.$toast; // 全局添加 $toast 事件 } } 成功编写完插件的 JS 脚本后，我们在入口文件中需要通过Vue.use()来注册一下该插件：\nimport Toast from '@/widgets/toast/toast.js' Vue.use(Toast); // 注册 Toast 最后我们在需要调用它的地方直接传入配置项使用即可，比如：\nthis.$toast('Hello World', 2000); 当然你也可以不使用 install 方法来编写插件，直接采用导出一个封装好的实例方法并将其挂载到 Vue 的原型链上来实现相同的功能。","编码技巧与规范#编码技巧与规范":"使用 Array.from 快速生成数组 let hours = []; for (let i = 0; i \u003c 24; i++) { hours.push(i + '时'); } // 改写 let hours = Array.from({ length: 24 }, (value, index) =\u003e index + '时'); 使用 router.beforeEach 来处理跳转前逻辑 在某些情况下，我们需要在路由跳转前处理一些特定的业务逻辑，比如修改路由跳转、设置 title 等，代码如下：\nimport Vue from 'vue' import Router from 'vue-router' Vue.use(Router) // 首页 const Home = (resolve =\u003e { require.ensure(['../views/home.vue'], () =\u003e { resolve(require('../views/home.vue')) }) }) let base = `${process.env.BASE_URL}`; let router = new Router({ mode: 'history', base: base, routes: [ { path: '/', name: 'home', component: Home, meta: { title: '首页' } }, ] }) router.beforeEach((to, from, next) =\u003e { let title = to.meta \u0026\u0026 to.meta.title; if (title) { document.title = title; // 设置页面 title } if (to.name === 'home') { // 拦截并跳转至 page2 单页，$openRouter 方法在第 5 节中封装 Vue.$openRouter({ name: 'page2' }); } next(); }) export default router 注意最后需要调用next()方法执行路由跳转。\n使用 v-if 来优化页面加载 在 Vue 页面中，一些模块可能需要用户主动触发才会显示，比如弹框组件等这样的子组件，那么我们可以使用v-if来进行按需渲染，没必要一进页面就渲染所有模块。比如：\n\u003ctemplate\u003e \u003cdiv @click=\"showModuleB = true\"\u003e\u003c/div\u003e \u003cmodule-b v-if=\"isShowModuleB\"\u003e\u003c/module-b\u003e \u003c/template\u003e \u003cscript\u003e import moduleB from 'components/moduleB' export default { data() { return { isShowModuleB: false } }, components: { moduleB } } \u003c/script\u003e 这样当 isShowModuleB 为 false 的时候便不会加载该模块下的代码，包括一些耗时的接口调用。当然v-if主要适用于代码量较多、用户点击不是很频繁的模块的显示隐藏， 同时如果涉及到权限问题的代码都需要使用v-if，而不是v-show。\n路由跳转尽量使用 name 而不是 path 我们前期配置的路由路径后期难免会进行修改，如果我们页面跳转的地方全是使用的 path，那么我们需要修改所有涉及该 path 的页面，这样不利于项目的维护。而 相对于 path，name 使用起来就方便多了，因为其具有唯一性，即使我们修改了 path，还可以使用原来的 name 值进行跳转。\nthis.$router.push({ name: 'page1' }); // 而不是 this.$router.push({ path: 'page1' }); 使用 key 来优化 v-for 循环 v-for是 Vue 提供的基于源数据多次渲染元素或模板块的指令。正因为是数据驱动，所以在修改列表数据的时候，Vue 内部会根据 key 值去判断某个值是否被修改， 其会重新渲染修改后的值，否则复用之前的元素。\n这里如果数据中存在唯一表示 id，则推荐使用 id 作为 key，如果没有则可以使用数组的下标 index 作为 key。因为如果在数组中间插入值，其之后的 index 会发生改变， 即使数据没变 Vue 也会进行重新渲染，所以最好的办法是使用数组中不会变化且唯一的那一项作为 key 值。例如：\n\u003ctemplate\u003e \u003cul\u003e \u003cli v-for=\"(item, index) in arr\" :key=\"item.id\"\u003e{{ item.data }}\u003c/li\u003e \u003c/ul\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { arr: [ { id: 1, data: 'a' }, { id: 2, data: 'b' }, { id: 3, data: 'c' } ] } } } \u003c/script\u003e 使用 computed 代替 watch 很多时候页面会出现 watch 的滥用而导致一系列问题的产生，而通常更好的办法是使用 computed 属性，首先需要区别它们有什么区别：\nwatch：当监测的属性变化时会自动执行对应的回调函数 computed：计算的属性只有在它的相关依赖发生改变时才会重新求值 其实它们在功能上还是有所区别的，但是有时候可以实现同样的效果，而 computed 会更胜一筹，比如：\n\u003ctemplate\u003e \u003cdiv\u003e \u003cinput type=\"text\" v-model=\"firstName\"\u003e \u003cinput type=\"text\" v-model=\"lastName\"\u003e \u003cspan\u003e{{ fullName }}\u003c/span\u003e \u003cspan\u003e{{ fullName2 }}\u003c/span\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { reurn { firstName: '', lastName: '', fullName2: '' } }, // 使用 computed computed: { fullName() { return this.firstName + ' ' + this.lastName } }, // 使用 watch watch: { firstName: function(newVal, oldVal) { this.fullName2 = newVal + ' ' + this.lastName; }, lastName: function(newVal, oldVal) { this.fullName2 = this.firstName + ' ' + newVal; }, } } \u003c/script\u003e 上方我们通过对比可以看到，在处理多数据联动的情况下，使用 computed 会更加合理一点。\ncomputed 监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算；而 watch 监 测的是属性值，只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。\n统一管理缓存变量 在项目中或多或少会使用浏览器缓存，比如 sessionStorage 和 localStorage，当一个项目中存在很多这样的缓 存存取情况的时候就会变得难以维护和管理，因为其就像全局变量一样散落在项目的各个地方，这时候我们应该将这些变量统一管理起来，放到一个或多个文件中去，比如：\n/* types.js */ export const USER_NAME = 'userName'; export const TOKEN = 'token'; 在需要存取的时候，直接引用：\nimport { USER_NAME, TOKEN } from '../types.js' sessionStorage[USER_NAME] = '张三'; localStorage[TOKEN] = 'xxx'; 好处在于一旦我们需要修改变量名，直接修改管理文件中的值即可，无需修改使用它的页面，同时这也可以避免命名冲突等问题的出现，这类似于 vuex 中 mutations 变量的管理。\n使用 setTimeout 代替 setInterval 一般情况下我们在项目里不建议使用 setInterval，因为其会存在代码的执行间隔比预期小以及 “丢帧” 的现象，原因在于其本身的实现逻辑。很多人会认 为 setInterval 中第二个时间参数的作用是经过该毫秒数执行回调方法，其实不然，其真正的作用是经过该毫秒数将回调方法放置到队列中去，但是如果队 列中存在正在执行的方法，其会等待之前的方法完毕再执行，如果存在还未执行的代码实例，其不会插入到队列中去，也就产生了 “丢帧”。\n而 setTimeout 并不会出现这样的现象，因为每一次调用都会产生了一个新定时器，同时在前一个定时器代码执行完之前，不会向队列插入新的定时器代码。\n// 该定时器实际会在 3s 后立即触发下一次回调 setInterval(() =\u003e { // 执行完这里的代码需要 2s }, 1000); // 使用 setTimeout 改写，4秒后触发下一次回调 let doSometing = () =\u003e { // 执行完这里的代码需要 2s setTimeout(doSometing, 1000); } doSometing(); 不要使用 for in 循环来遍历数组 大家应该都知道 for in 循环是用于遍历对象的，但它可以用来遍历数组吗？答案是可以的，因为数组在某种意义上也是对象，但是如果用其遍历数组会存在一些隐患： 其会遍历数组原型链上的属性。\nlet arr = [1, 2]; for (let key in arr) { console.log(arr[key]); // 会正常打印 1, 2 } // 但是如果在 Array 原型链上添加一个方法 Array.prototype.test = function() {}; for (let key in arr) { console.log(arr[key]); // 此时会打印 1, 2, ƒ () {} } 因为我们不能保证项目代码中不会对数组原型链进行操作，也不能保证引入的第三方库不对其进行操作，所以不要使用 for in 循环来遍历数组。"},"title":"guide"},"/frontend-learn/docs/practice/vuecli3/intergration/":{"data":{"使用-alias-简化路径#使用 alias 简化路径":"使用 webpack 构建过 Vue 项目的同学应该知道 alias 的作用，我们可以使用它将复杂的文件路径定义成一个变量来访问。 在不使用 alias 的项目中，我们引入文件的时候通常会去计算被引入文件对于引入它的文件的相对路径，比如像这样：\nimport HelloWorld from '../../../../HelloWorld.vue' 一旦相对层次结构较深，我们就很难去定位所引入文件的具体位置，其实这并不是我们应该操心的地方，完全可以交给 webpack 来进行处理。 在原生的 webpack 配置中我们可以定义 alias 来解决这一问题：\nconst path = require('path') const resolve = dir =\u003e { return path.join(__dirname, dir) } module.exports = { ... resolve: { alias: { '@': resolve('src'), // 定义 src 目录变量 _lib: resolve('src/common'), // 定义 common 目录变量, _com: resolve('src/components'), // 定义 components 目录变量, _img: resolve('src/images'), // 定义 images 目录变量, _ser: resolve('src/services'), // 定义 services 目录变量, } }, ... } 上方我们在 webpack resolve（解析）对象下配置 alias 的值，将常用的一些路径赋值给了我们自定义的变量，这样我们便可以将第一个例子简化为：\nimport HelloWorld from '_com/HelloWorld.vue' 而在 CLI 3.x 中我们无法直接操作 webpack 的配置文件，我们需要通过 chainWebpack 来进行间接修改，代码如下：\n/* vue.config.js */ module.exports = { ... chainWebpack: config =\u003e { config.resolve.alias .set('@', resolve('src')) .set('_lib', resolve('src/common')) .set('_com', resolve('src/components')) .set('_img', resolve('src/images')) .set('_ser', resolve('src/services')) }, ... } 这样我们修改 webpack alias 来简化路径的优化就实现了。但是需要注意的是对于在样式及 html 模板中引用路径的简写时，前面需要加上~符，否则路径解析会失败，如：\n.img { background: (~_img/home.png); } ","开启-gzip-压缩#开启 Gzip 压缩":"使用compression-webpack-plugin来开启 Gzip 压缩。 在 vue.config.js 配置文件中，我们通过 configureWebpack 中返回一个对象来实现 plugins 的合并：\n/* vue.config.js */ const isPro = process.env.NODE_ENV === 'production' module.exports = { ... configureWebpack: config =\u003e { if (isPro) { return { plugins: [ new CompressionWebpackPlugin({ // 目标文件名称。[path] 被替换为原始文件的路径和 [query] 查询 asset: '[path].gz[query]', // 使用 gzip 压缩 algorithm: 'gzip', // 处理与此正则相匹配的所有文件 test: new RegExp( '\\\\.(js|css)$' ), // 只处理大于此大小的文件 threshold: 10240, // 最小压缩比达到 0.8 时才会被压缩 minRatio: 0.8， }) ] } } } ... } 上方我们通过在生产环境中增加 Gzip 压缩配置实现了打包后输出增加对应的 .gz 为后缀的文件，而由于我们配置项中配置的是 只压缩大小超过 10240B（10kB）的 JS 及 CSS，因此不满足条件的文件不会进行 Gzip 压缩。\nGzip 压缩能在普通压缩的基础上再进行 50% 以上 的压缩。","整合功能模块#整合功能模块":"在多页应用的构建中，由于存在多个入口文件，因此会出现重复书写相同入口配置的情况，这样对于后期的修改和维护都不是特别友好，需要修改所有入口文件的相同配置， 比如在 index 单页的入口中我们引用了VConsole及performance的配置，同时在 Vue 实例上还添加了$openRouter方法：\nimport Vue from 'vue' import App from './index.vue' import router from './router' import store from '@/store/' import { Navigator } from '../../common' // 如果是非线上环境，不加载 VConsole if (process.env.NODE_ENV !== 'production') { var VConsole = require('vconsole/dist/vconsole.min.js'); var vConsole = new VConsole(); Vue.config.performance = true; } Vue.$openRouter = Vue.prototype.$openRouter = Navigator.openRouter; new Vue({ router, store, render: h =\u003e h(App) }).$mount('#app') 而在 page1 和 page2 的入口文件中也同样进行了上述配置，那我们该如何整合这些重复代码，使其能够实现一次修改多处生效的功能呢？最简单的方法便是封装成一个共用方法来进行调 用，这里我们可以在 common 文件夹下新建 entryConfig 文件夹用于放置入口文件中公共配置的封装，封装代码如下：\nimport { Navigator } from '../index' export default (Vue) =\u003e { // 如果是非线上环境，不加载 VConsole if (process.env.NODE_ENV !== 'production') { var VConsole = require('vconsole/dist/vconsole.min.js'); var vConsole = new VConsole(); Vue.config.performance = true; } Vue.$openRouter = Vue.prototype.$openRouter = Navigator.openRouter; } 上述代码我们向外暴露了一个函数，在调用它的入口文件中传入 Vue 实例作为参数即可实现内部功能的共用，我们可以将原本的入口文件简化为:\nimport Vue from 'vue' import App from './index.vue' import router from './router' import store from '@/store/' import entryConfig from '_lib/entryConfig/' // 调用公共方法加载配置 entryConfig(Vue) new Vue({ router, store, render: h =\u003e h(App) }).$mount('#app') 这样我们便完成了入口文件配置的整合，当然你还可以给该函数传入 router 实例及自定义参数用于其他共用配置的封装。","项目整合与优化#项目整合与优化":"项目整合与优化"},"title":"intergration"},"/frontend-learn/docs/practice/vuecli3/multi_pages/":{"data":{"使用-pages-构建多页应用#使用 pages 构建多页应用":"使用 pages 构建多页应用","使用-pages-配置#使用 pages 配置":"在 vue.config.js 中，我们还有一个配置没有使用，便是pages。pages对象允许我们为应用配置多个入口及模板，这就为我们的多页应用提供了开放的配置入口。官方示例代码如下：\n/* vue.config.js */ module.exports = { pages: { index: { // page 的入口 entry: 'src/index/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 \u003ctitle\u003e\u003c%= htmlWebpackPlugin.options.title %\u003e\u003c/title\u003e title: 'Index Page', // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: ['chunk-vendors', 'chunk-common', 'index'] }, // 当使用只有入口的字符串格式时， // 模板会被推导为 `public/subpage.html` // 并且如果找不到的话，就回退到 `public/index.html`。 // 输出文件名会被推导为 `subpage.html`。 subpage: 'src/subpage/main.js' } } pages 对象中的 key 就是入口的别名，而其 value 对象其实是入口 entry 和模板属性的合并， 这样我们上述介绍的获取多入口和多模板的方法就可以合并成一个函数来进行多页的处理，合并后的 setPages 方法如下：\n// pages 多入口配置 exports.setPages = configs =\u003e { let entryFiles = glob.sync(PAGE_PATH + '/*/*.js') let map = {} entryFiles.forEach(filePath =\u003e { let filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) let tmp = filePath.substring(0, filePath.lastIndexOf('\\/')) let conf = { // page 的入口 entry: filePath, // 模板来源 template: tmp + '.html', // 在 dist/index.html 的输出 filename: filename + '.html', // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本 chunks: ['manifest', 'vendor', filename], inject: true, }; if (configs) { conf = merge(conf, configs) } if (process.env.NODE_ENV === 'production') { conf = merge(conf, { minify: { removeComments: true, // 删除 html 中的注释代码 collapseWhitespace: true, // 删除 html 中的空白符 // removeAttributeQuotes: true // 删除 html 元素中属性的引号 }, chunksSortMode: 'manual'// 按 manual 的顺序引入 }) } map[filename] = conf }) return map } 上述代码我们 return 出的 map 对象就是 pages 所需要的配置项结构，我们只需在 vue.config.js 中引用即可：\n/* vue.config.js */ const utils = require('./build/utils') module.exports = { ... pages: utils.setPages(), ... } 当你运行打包命令来查看输出结果的时候，你会发现和之前的方式相比并没有什么变化，这就说明这两种方式都适用于多页的构建，但是这里还是推荐大家使用更便捷的 pages 配置。","多入口#多入口":"在单页应用中，我们的入口文件只有一个，CLI 默认配置的是 main.js，但是到了多页应用，我们的入口文件便包含了 page1.js、page2.js、index.js等， 数量取决于 pages 文件夹下目录的个数，这时候为了项目的可拓展性，我们需要自动计算入口文件的数量并解析路径配置到 webpack 中的 entry 属性上，如：\nmodule.exports = { ... entry: { page1: '/xxx/pages/page1/page1.js', page2: '/xxx/pages/page2/page2.js', index: '/xxx/pages/index/index.js', }, ... } 那么我们如何读取并解析这样的路径呢，这里就需要使用工具和函数来解决了。我们可以在根目录新建 build 文件夹存放 utils.js 这样共用 的 webpack 功能性文件，并加入多入口读取解析方法：\n/* utils.js */ const path = require('path'); // glob 是 webpack 安装时依赖的一个第三方模块，该模块允许你使用 * 等符号, // 例如 lib/*.js 就是获取 lib 文件夹下的所有 js 后缀名的文件 const glob = require('glob'); // 取得相应的页面路径，因为之前的配置，所以是 src 文件夹下的 pages 文件夹 const PAGE_PATH = path.resolve(__dirname, '../src/pages'); /* * 多入口配置 * 通过 glob 模块读取 pages 文件夹下的所有对应文件夹下的 js * 后缀文件，如果该文件存在 * 那么就作为入口处理 */ exports.getEntries = () =\u003e { let entryFiles = glob.sync(PAGE_PATH + '/*/*.js') // 同步读取所有入口文件 let map = {} // 遍历所有入口文件 entryFiles.forEach(filePath =\u003e { // 获取文件名 let filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) // 以键值对的形式存储 map[filename] = filePath }) return map } 上方我们使用了 glob 这一第三方模块读取所有 pages 文件夹下的入口文件，其需要进行安装：yarn add glob --dev\n读取并存储完毕后，我们得到了一个入口文件的对象集合，这个对象我们便可以将其设置到 webpack 的 entry 属性上，这里我们需要修改 vue.config.js 的配置来间 接修改 webpack 的值：\n/* vue.config.js */ const utils = require('./build/utils') module.exports = { ... configureWebpack: config =\u003e { config.entry = utils.getEntries() }, ... } ","多模板#多模板":"多模板的配置也是大同小异，这里所说的模板便是每个 page 下的 html 模板文件，而模板文件的作用主要用于 webpack 中html-webpack-plugin插件的配置， 其会根据模板文件生产一个编译后的 html 文件并自动加入携带 hash 的脚本和样式，基本配置如下：\n/* webpack 配置文件 */ const HtmlWebpackPlugin = require('html-webpack-plugin') // 安装并引用插件 module.exports = { ... plugins: [ new HtmlWebpackPlugin({ title: 'My Page', // 生成 html 中的 title filename: 'demo.html', // 生成 html 的文件名 template: 'xxx/xxx/demo.html', // 模板路径 chunks: ['manifest', 'vendor', 'demo'], // 所要包含的模块 inject: true, // 是否注入资源 }) ] ... } 以上是单模板的配置，那么如果是多模板只要继续往 plugins 数组中添加 HtmlWebpackPlugin 即可，但是为了和多入口一样能够灵活的获取 pages 目录下所有模板文件并进行配置，我们可以在 utils.js 中添加多模板的读取解析方法：\n/* utils.js */ // 多页面输出配置 // 与上面的多页面入口配置相同，读取 page 文件夹下的对应的 html 后缀文件，然后放入数组中 exports.htmlPlugin = configs =\u003e { let entryHtml = glob.sync(PAGE_PATH + '/*/*.html') let arr = [] entryHtml.forEach(filePath =\u003e { let filename = filePath.substring(filePath.lastIndexOf('\\/') + 1, filePath.lastIndexOf('.')) let conf = { template: filePath, // 模板路径 filename: filename + '.html', // 生成 html 的文件名 chunks: ['manifest', 'vendor', filename], inject: true, } // 如果有自定义配置可以进行 merge if (configs) { conf = merge(conf, configs) } // 针对生产环境配置 if (process.env.NODE_ENV === 'production') { conf = merge(conf, { minify: { removeComments: true, // 删除 html 中的注释代码 collapseWhitespace: true, // 删除 html 中的空白符 // removeAttributeQuotes: true // 删除 html 元素中属性的引号 }, chunksSortMode: 'manual' // 按 manual 的顺序引入 }) } arr.push(new HtmlWebpackPlugin(conf)) }) return arr } 以上我们仍然是使用 glob 读取所有模板文件，然后将其遍历并设置每个模板的 config，同时针对一些自定义配置和生产环境的配置进行了 merge 处理， 其中自定义配置的功能我会在下节进行介绍，这里介绍一下生产环境下 minify 配置的作用：将html-minifier的选项作为对象来缩小输出。\nhtml-minifier是一款用于缩小 html 文件大小的工具，其有很多配置项功能，包括上述所列举的常用的删除注释、空白、引号等。\n当我们编写完了多模板的方法后，我们同样可以在 vue.config.js 中进行配置，与多入口不同的是我们在 configureWebpack 中不能直接替换 plugins 的值， 因为它还包含了其他插件，这时候大家还记得第 3 节中讲到的使用 return 返回一个对象来进行 merge 操作吗？\n/* vue.config.js */ const utils = require('./build/utils') module.exports = { ... configureWebpack: config =\u003e { config.entry = utils.getEntries() // 直接覆盖 entry 配置 // 使用 return 一个对象会通过 webpack-merge 进行合并，plugins 不会置空 return { plugins: [...utils.htmlPlugin()] } }, ... } 这时候我们运行命令 yarn build 后你会发现 dist 目录下生成了 3 个 html 文件，分别是 index.html、page1.html 和 page2.html。","概念#概念":" 首先我们可以把多页应用理解为由多个单页构成的应用，而何谓多个单页呢？其实你可以把一个单页看成是一个 html 文件，那么多个单页便是多个 html 文件， 多页应用便是由多个 html 组成的应用，如下图所示：\n多页应用的每个单页都可以拥有单页应用 src 目录下的文件及功能，我们来看一下一个基础多页应用的目录结构：\n├── node_modules # 项目依赖包目录 ├── build # 项目 webpack 功能目录 ├── config # 项目配置项文件夹 ├── src # 前端资源目录 │ ├── images # 图片目录 │ ├── components # 公共组件目录 │ ├── pages # 页面目录 │ │ ├── page1 # page1 目录 │ │ │ ├── components # page1 组件目录 │ │ │ ├── router # page1 路由目录 │ │ │ ├── views # page1 页面目录 │ │ │ ├── page1.html # page1 html 模板 │ │ │ ├── page1.vue # page1 vue 配置文件 │ │ │ └── page1.js # page1 入口文件 │ │ ├── page2 # page2 目录 │ │ └── index # index 目录 │ ├── common # 公共方法目录 │ └── store # 状态管理 store 目录 ├── .gitignore # git 忽略文件 ├── .env # 全局环境配置文件 ├── .env.dev # 开发环境配置文件 ├── .postcssrc.js # postcss 配置文件 ├── babel.config.js # babel 配置文件 ├── package.json # 包管理文件 ├── vue.config.js # CLI 配置文件 └── yarn.lock # yarn 依赖信息文件 可以看出其实 pages 下的一个目录就是一个单页包含的功能，这里我们包含了 3 个目录就构成了多页应用。\n除了目录结构的不同外，其实区别单页应用，多页应用在很多配置上都需要进行修改，比如单入口变为多入口、单模板变为多模板等，那么下面我们就来了解一下多页应用的具体实现。"},"title":"multi_pages"},"/frontend-learn/docs/practice/vuecli3/multi_router/":{"data":{"多页路由与模板解析#多页路由与模板解析":"多页路由与模板解析","模板配置#模板配置":"模板渲染 这里所说的模板渲染是在我们的 html 模板文件中使用 html-webpack-plugin 提 供的 default template 语法进行模 板编写，比如：\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"\u003e \u003ctitle\u003e模板\u003c/title\u003e \u003c% for (var chunk in htmlWebpackPlugin.files.css) { %\u003e \u003c% if(htmlWebpackPlugin.files.css[chunk]) {%\u003e \u003clink href=\"\u003c%= htmlWebpackPlugin.files.css[chunk] %\u003e\" rel=\"stylesheet\" /\u003e \u003c%}%\u003e \u003c% } %\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e\u003c/div\u003e \u003c!-- built files will be auto injected --\u003e \u003c% for (var chunk in htmlWebpackPlugin.files.js) { %\u003e \u003c% if(htmlWebpackPlugin.files.js[chunk]) {%\u003e \u003cscript type=\"text/javascript\" src=\"\u003c%= htmlWebpackPlugin.files.js[chunk] %\u003e\"\u003e\u003c/script\u003e \u003c%}%\u003e \u003c% } %\u003e \u003c/body\u003e \u003c/html\u003e 以上我们使用模板语法手动获取并遍历 htmlWebpackPlugin 打包后的文件并生成到模板中，其中的htmlWebpackPlugin变量是模板提供的可访问变量，其有以下特定数据：\n\"htmlWebpackPlugin\": { \"files\": { \"css\": [ \"main.css\" ], \"js\": [ \"assets/head_bundle.js\", \"assets/main_bundle.js\"], \"chunks\": { \"head\": { \"entry\": \"assets/head_bundle.js\", \"css\": [ \"main.css\" ] }, \"main\": { \"entry\": \"assets/main_bundle.js\", \"css\": [] }, } } } 我们通过htmlWebpackPlugin.files可以获取打包输出的 js 及 css 文件路径，包括入口文件路径等。\n需要注意的是如果你在模板中编写了插入对应 js 及 css 的语法，你需要设置 inject 的值为 false 来关闭资源的自动注入：\n/* utils.js */ ... let conf = { entry: filePath, // page 的入口 template: filePath, // 模板路径 filename: filename + '.html', // 生成 html 的文件名 chunks: ['manifest', 'vendor', filename], inject: false, // 关闭资源自动注入 } ... 否则在页面会引入两次资源。\n自定义配置 在模板渲染中，我们只能够使用 htmlWebpackPlugin 内部的一些属性和方法来进行模板的定制化开发，那么如果遇到需要根据不 同环境来引入不同资源，同时不同模板间的配置还可能不一样的需求情况的话，我们使用自定义配置会比较方便。比如我们需要在生产环境模板中引入第三方统计脚本：\n/* vue.config.js */ module.exports = { ... pages: utils.setPages({ addScript() { if (process.env.NODE_ENV === 'production') { return ` \u003cscript src=\"https://s95.cnzz.com/z_stat.php?id=xxx\u0026web_id=xxx\" language=\"JavaScript\"\u003e\u003c/script\u003e ` } return '' } }), ... } 然后在页面模板中通过htmlWebpackPlugin.options获取自定义配置对象并进行输出：\n\u003c% if(htmlWebpackPlugin.options.addScript){ %\u003e \u003c%= htmlWebpackPlugin.options.addScript() %\u003e \u003c%}%\u003e 同时你也可以针对个别模板进行配置，比如我想只在 Index 单页中添加统计脚本，在 Page1 单页中添加其他脚本，那么你可以给 addScript 传入标识符来进行判断输出，比如：\n\u003c% if(htmlWebpackPlugin.options.addScript){ %\u003e \u003c%= htmlWebpackPlugin.options.addScript('index') %\u003e \u003c%}%\u003e 同时为 addScript 方法添加参数 from：\naddScript(from) { if (process.env.NODE_ENV === 'production') { let url = \"https://xxx\"; if (from === 'index') { url = \"https://s95.cnzz.com/z_stat.php?id=xxx\u0026web_id=xxx\"; } return ` \u003cscript src=${url} language=\"JavaScript\"\u003e\u003c/script\u003e ` } return '' } 这样我们就完成了自定义配置中的模板渲染功能。当然根据实际项目需求你的自定义配置项可能会更加复杂和灵活。","路由配置#路由配置":"跳转 在配置路由前，首先我们要明确一点就是，多页应用中的每个单页都是相互隔离的，即如果你想从 page1 下的路由跳到 page2 下的路由，你无法使用 vue-router 中的方法进行跳转， 需要使用原生方法location.href或location.replace。\n此外为了能够清晰的分辨路由属于哪个单页，我们应该给每个单页路由添加前缀，比如：\nindex 单页：/vue/ page1 单页：/vue/page1/ page2 单页：/vue/page2/ 其中/vue/为项目的二级目录，其后的目录代表路由属于哪个单页。因此我们每个单页的路由配置可以像这样：\n/* page1 单页路由配置 */ import Vue from 'vue' import Router from 'vue-router' // 首页 const Home = (resolve =\u003e { require.ensure(['../views/home.vue'], () =\u003e { resolve(require('../views/home.vue')) }) }) Vue.use(Router) let base = `${process.env.BASE_URL}` + 'page1'; // 添加单页前缀 export default new Router({ mode: 'history', base: base, routes: [ { path: '/', name: 'home', component: Home }, ] }) 我们通过设置路由的 base 值来为每个单页添加路由前缀，如果是 index 单页我们无需拼接路由前缀，直接跳转至二级目录即可。\n那么在单页间跳转的地方，我们可以这样写：\n\u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e \u003ca @click=\"goFn('')\"\u003eIndex\u003c/a\u003e | \u003ca @click=\"goFn('page1')\"\u003ePage1\u003c/a\u003e | \u003ca @click=\"goFn('page2')\"\u003ePage2\u003c/a\u003e | \u003c/div\u003e \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { goFn(name) { location.href = `${process.env.BASE_URL}` + name } } } \u003c/script\u003e 但是为了保持和 Vue 路由跳转同样的风格，我可以对单页之间的跳转做一下封装，实现一个Navigator类，类的代码可以查看本文最后的示例，封装完成后我们可以将跳转方法修改为：\nthis.$openRouter({ name: name, // 跳转地址 query: { text: 'hello' // 可以进行参数传递 }, }) 使用上述$openRouter方法我们还需要一个前提条件，便是将其绑定到 Vue 的原型链上，我们在所有单页的入口文件中添加：\nimport { Navigator } from '../../common' // 引入 Navigator Vue.prototype.$openRouter = Navigator.openRouter; // 添加至 Vue 原型链 至此我们已经能够成功模仿 vue-router 进行单页间的跳转，但是需要注意的是因为其本质使用的是 location 跳转，所以必然会产生浏览器的刷新与重载。\n重定向 当我们完成上述路由跳转的功能后，可以在本地服务器上来进行一下测试，你会发现 Index 首页可以正常打开，但是跳转 Page1、Page2 却仍然处于 Index 父组件下，这是因为浏览 器认为你所要跳转的页面还是在 Index 根路由下，同时又没有匹配到 Index 单页中对应的路由。这时候我们服务器需要做一次重定向，将下方路由指向对应的 html 文件即可：\n/vue/page1 -\u003e /vue/page1.html /vue/page2 -\u003e /vue/page2.html 在 vue.config.js 中，我们需要对 devServer 进行配置，添加historyApiFallback配置项，该配置项主要用于解决 HTML5 History API 产生的问题， 比如其rewrites选项用于重写路由：\n/* vue.config.js */ let baseUrl = '/vue/'; module.exports = { ... devServer: { historyApiFallback: { rewrites: [ { from: new RegExp(baseUrl + 'page1'), to: baseUrl + 'page1.html' }, { from: new RegExp(baseUrl + 'page2'), to: baseUrl + 'page2.html' }, ] } } ... } 上方我们通过 rewrites 匹配正则表达式的方式将/vue/page1这样的路由替换为访问服务器下正确 html 文件的形式，如此不同单页间便可以进行正确跳转和访问了。 最后需要注意的是如果你的应用发布到正式服务器上，你同样需要让服务器或者中间层作出合理解析，参考： HTML5 History 模式 # 后端配置例子\n而更多关于 historyApiFallback 的信息可以访问：connect-history-api-fallback"},"title":"multi_router"},"/frontend-learn/docs/practice/vuecli3/npm_package/":{"data":{"介绍#介绍":"npm 与 package.json npm 是 Node Package Manager 的简称， node 的包管理工具，也是目前世界上最大的开源库生态系统。 官方地址为：www.npmjs.com。\n在最外层目录中，可以看到有package.json这一文件，该文件便是我们需要了解的包管理文件。\n{ \"name\": \"my-project\", \"version\": \"0.1.0\", \"private\": true, \"scripts\": { \"serve\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\" }, \"dependencies\": { \"vue\": \"^2.5.16\", \"vue-router\": \"^3.0.1\", \"vuex\": \"^3.0.1\" }, \"devDependencies\": { \"@vue/cli-plugin-babel\": \"^3.0.0-beta.15\", \"@vue/cli-service\": \"^3.0.0-beta.15\", \"less\": \"^3.0.4\", \"less-loader\": \"^4.1.0\", \"vue-template-compiler\": \"^2.5.16\" }, \"browserslist\": [ \"\u003e 1%\", \"last 2 versions\", \"not ie \u003c= 8\" ] } 详细的package.json文件配置项介绍可以参考：package.json\n第三方插件配置 browserslist这一配置项，就是第三方插件配置项，该配置的主要作用是用于在不同的前端工具之间共享目标浏览器和 Node.js 的版本：\n\"browserslist\": [ \"\u003e 1%\", // 表示包含所有使用率 \u003e 1% 的浏览器 \"last 2 versions\", // 表示包含浏览器最新的两个版本 \"not ie \u003c= 8\" // 表示不包含 ie8 及以下版本 ] 比如像 autoprefixer 这样的插件需要把你写的 css 样式适配不同的浏览器， 那么这里要针对哪些浏览器呢，就是上面配置中所包含的。\n而如果写在 autoprefixer 的配置中，那么会存在一个问题，万一其他第三方插件也需要浏览器的包含范围用于实现其特定的功能， 那么就又得在其配置中设置一遍，这样就无法得以共用。所以在package.json中配置browserslist的属性使得所有工具都会自动找到目标浏览器。\n你也可以单独写在.browserslistrc的文件中：\n# Browsers that we support \u003e 1% last 2 versions not ie \u003c= 8 至于它是如何去衡量浏览器的使用率和版本的，数据都是来源于 Can I Use。你也可以访问 browserl.ist 去搜索配置项所包含的浏览器列表，比如搜索last 2 versions会得到你想要的结果，或者在项目终端运行如下命令查看：\nnpx browserslist vue-cli 包安装 vue-cli 3.x 还提供了其专属的vue add命令，但是需要注意的是该命令安装的包是以@vue/cli-plugin或者vue-cli-plugin开头，即只能安装 Vue 集成的包。\n比如：\nvue add jquery 会安装vue-cli-plugin-jquery，很显然这个插件不存在便会安装失败。又或者你运行：\nvue add @vue/eslint 其会解析为完整的包名@vue/cli-plugin-eslint，因为该包存在所以会安装成功。\nvue add不仅会将包安装到你的项目中，其还会改变项目的代码或文件结构，所以安装前最好提交你的代码至仓库。\nvue add中还有两个特例，如下：\n# 安装 vue-router vue add router # 安装 vuex vue add vuex 这两个命令会直接安装vue-router和vuex并改变你的代码结构，使你的项目集成这两个配置，并不会去安装添加vue-cli-plugin或@vue/cli-plugin前缀的包。","包管理工具与配置项#包管理工具与配置项":"包管理工具与配置项"},"title":"npm_package"},"/frontend-learn/docs/practice/vuecli3/readme/":{"data":{"vue-cli-3-项目构建基础#Vue CLI 3 项目构建基础":"Vue CLI 3 项目构建基础","依赖#依赖":" Node.js ","目录#目录":" 包管理工具及配置 webpack 环境变量 配置基本的单页面应用 多页应用 多页路由与解析 项目整合优化 指南 拓展 ","脚手架#脚手架":"什么是脚手架 脚手架可以理解为能够帮助我们快速构建前端项目的一个工具或平台。\nvue-cli Vue 的脚手架工具vue-cli，目前最新的版本是 3.x。CLI 3.x 版本和 2.x 版本存在着很大的区别。\n安装 # 安装 Vue CLI 3.x npm i -g @vue/cli # 或者 yarn global add @vue/cli 构建 # my-project 是你的项目名称 vue create my-project 执行完上述命令后，会出现一系列的选择项，流程图如下：\n如果你只想构建一个基础的 Vue 项目，那么使用 Babel、Router、Vuex、CSS Pre-processors 就足够了，最后选择你喜欢的包管理工具 npm or yarn。\n启动 # 打开项目目录 cd vue-project # 启动项目 yarn serve # or npm run serve 如果启动的时候出现报错或者包丢失等情况，最好将 node 或者 yarn （如果使用）的版本更新到最新重新构建。\n成功后打开浏览器地址：http://localhost:8080/\n目录结构 ├── node_modules # 项目依赖包目录 ├── public │ ├── favicon.ico # ico图标 │ └── index.html # 首页模板 ├── src │ ├── assets # 样式图片目录 │ ├── components # 组件目录 │ ├── views # 页面目录 │ ├── App.vue # 父组件 │ ├── main.js # 入口文件 │ ├── router.js # 路由配置文件 │ └── store.js # vuex状态管理文件 ├── .gitignore # git忽略文件 ├── .postcssrc.js # postcss配置文件 ├── babel.config.js # babel配置文件 ├── package.json # 包管理文件 └── yarn.lock # yarn依赖信息文件 可视化界面 除了使用上述命令行构建外，vue-cli 3.x 还提供了可视化的操作界面，在项目目录下我们运行如下命令开启图形化界面：\nvue ui 之后浏览器会自动打开本地 8000 端口，页面如下：\n如果你还没有任何项目，那么可以点击创建或者直接导入现有的项目。创建项目和我们使用命令行的步骤基本相同。"},"title":"README"},"/frontend-learn/docs/practice/vuecli3/spa_config/":{"data":{"单页应用的基本配置#单页应用的基本配置":"单页应用的基本配置","配置#配置":"路由配置 由于 Vue 这类型的框架都是以一个或多个单页构成，在单页内部跳转并不会重新渲染 HTML 文件，其路由可以由前端进行控制，因此我们 需要在项目内部编写相应的路由文件，Vue 会解析这些文件中的配置并进行对应的跳转渲染。\n/* router.js */ import Vue from 'vue' import Router from 'vue-router' import Home from './views/Home.vue' // 引入 Home 组件 import About from './views/About.vue' // 引入 About 组件 Vue.use(Router) // 注册路由 export default new Router({ routes: [{ path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', component: About }] }) 有以下几点需要进行优化：\n如果路由存在二级目录，需要添加base属性，否则默认为 “/” 默认路由模式是 hash 模式，会携带#标记，与真实 url 不符，可以改为 history 模式 页面组件没有进行按需加载，可以使用require.ensure()来进行优化 /* router.js */ import Vue from 'vue' import Router from 'vue-router' // 引入 Home 组件 const Home = resolve =\u003e { require.ensure(['./views/Home.vue'], () =\u003e { resolve(require('./views/Home.vue')) }) } // 引入 About 组件 const About = resolve =\u003e { require.ensure(['./views/About.vue'], () =\u003e { resolve(require('./views/About.vue')) }) } Vue.use(Router) let base = `${process.env.BASE_URL}` // 动态获取二级目录 export default new Router({ mode: 'history', base: base, routes: [{ path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', component: About }] }) 改为 history 后我们 url 的路径就变成了 http://127.0.0.1:8080/vue/about， 而不是原来的 http://127.0.0.1:8080/vue/#/about，但是需要注意页面渲染404的问题， 具体可查阅：HTML5 History 模式。\n而在异步加载的优化上，我们使用了 webpack 提供的require.ensure()进行了代码拆分，主要区别在于没有优化前，访问 Home 页面会一起加 载 About 组件的资源，因为它们打包进了一个app.js中：\n但是优化过后，它们分别被拆分成了 2.js 和 3.js：\n如此，只有当用户点击了某页面，才会加载对应页面的 js 文件，实现了按需加载的功能。\nwebpack 在编译时，会静态地解析代码中的require.ensure()，同时将模块添加到一个分开的 chunk 当中。 这个新的 chunk 会被 webpack 通过 jsonp 来按需加载。\n关于require.ensure()的知识点可以参考官方文档：require.ensure。\n除了使用require.ensure来拆分代码，Vue Router 官方文档还推荐使用动态import 语法来进行代码分块，比如上述require.ensure代码可以修改为：\n// 引入 Home 组件 const Home = () =\u003e import('./views/Home.vue'); // 引入 About 组件 const About = () =\u003e import('./views/About.vue'); 其余代码可以保持不变，仍然可以实现同样的功能。如果你想给拆分出的文件命名，可以尝试一下 webpack 提供的 Magic Comments（魔法注释）：\nconst Home = () =\u003e import(/* webpackChunkName:'home'*/ './views/Home.vue'); Vuex 配置 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。来看一下使用 CLI 生成的配置文件 store.js 中的内容：\nimport Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { }, mutations: { }, actions: { } }) 主要有 4 个核心点：state、mutations、actions 及 getter，详细的介绍大家可以参考官方文档：核心概念， 这里我用一句话介绍它们之间的关系就是：我们可以通过 actions 异步提交 mutations 去 修改 state 的值并通过 getter 获取。\n需要注意的是不是每一个项目都适合使用 Vuex，如果你的项目是中大型项目，那么使用 Vuex 来管理错综复杂的状态数据是很有帮助的， 而为了后期的拓展性和可维护性，这里不建议使用 CLI 生成的一份配置文件来管理所有的状态操作，我们可以把它拆分为以下目录：\n└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── moduleA.js # A模块 └── moduleB.js # B模块 与单个 store.js 文件不同的是，我们按模块进行了划分，每个模块中都可以包含自己 4 个核心功能。比如模块 A 中：\n/* moduleA.js */ const moduleA = { state: { text: 'hello' }, mutations: { addText (state, txt) { // 这里的 `state` 对象是模块的局部状态 state.text += txt } }, actions: { setText ({ commit }) { commit('addText', ' world') } }, getters: { getText (state) { return state.text + '!' } } } export default moduleA 上方我们导出 A 模块，并在 index.js 中引入：\n/* index.js */ import Vue from 'vue' import Vuex from 'vuex' import moduleA from './modules/moduleA' import moduleB from './modules/moduleB' import { mutations } from './mutations' import actions from './actions' Vue.use(Vuex) export default new Vuex.Store({ state: { groups: [1] }, modules: { moduleA, // 引入 A 模块 moduleB, // 引入 B 模块 }, actions, // 根级别的 action mutations, // 根级别的 mutations // 根级别的 getters getters: { getGroups (state) { return state.groups } } }) 接口配置 我们可以在 src 目录下新建 services 文件夹用于存放接口文件：\n└── src └── services ├── http.js # 接口封装 ├── moduleA.js # A模块接口 └── moduleB.js # B模块接口 为了让接口便于管理，我们同样使用不同的文件来配置不同模块的接口，同时由于接口的调用 ajax 请求代码重复部分较多，我们可以对其进行简单的封装， 比如在http.js中（fetch为例）：\n/* http.js */ import 'whatwg-fetch' // HTTP 工具类 export default class Http { static async request(method, url, data) { const param = { method: method, headers: { 'Content-Type': 'application/json' } }; if (method === 'GET') { url += this.formatQuery(data) } else { param['body'] = JSON.stringify(data) } // Tips.loading(); // 可调用 loading 组件 return fetch(url, param).then(response =\u003e this.isSuccess(response)) .then(response =\u003e { return response.json() }) } // 判断请求是否成功 static isSuccess(res) { if (res.status \u003e= 200 \u0026\u0026 res.status \u003c 300) { return res } else { this.requestException(res) } } // 处理异常 static requestException(res) { const error = new Error(res.statusText) error.response = res throw error } // url处理 static formatQuery(query) { let params = []; if (query) { for (let item in query) { let vals = query[item]; if (vals !== undefined) { params.push(item + '=' + query[item]) } } } return params.length ? '?' + params.join('\u0026') : ''; } // 处理 get 请求 static get(url, data) { return this.request('GET', url, data) } // 处理 put 请求 static put(url, data) { return this.request('PUT', url, data) } // 处理 post 请求 static post(url, data) { return this.request('POST', url, data) } // 处理 patch 请求 static patch(url, data) { return this.request('PATCH', url, data) } // 处理 delete 请求 static delete(url, data) { return this.request('DELETE', url, data) } } 封装完毕后我们在 moduleA.js 中配置一个 github 的开放接口：\n/* moduleA.js */ import Http from './http' // 获取测试数据 export const getTestData = () =\u003e { return Http.get('https://api.github.com/repos/octokit/octokit.rb') } 然后在项目页面中进行调用，会成功获取 github 返回的数据，但是一般我们在项目中配置接口的时候会直接省略项目 url 部分，比如：\n/* moduleA.js */ import Http from './http' // 获取测试数据 export const getTestData = () =\u003e { return Http.get('/repos/octokit/octokit.rb') } 这时候我们再次调用接口的时候会发现其调用地址为本地地址：http://127.0.0.1:8080/repos/octokit/octokit.rb，那么为了让其 指向https://api.github.com，我们需要在 vue.config.js 中进行 devServer 的配置：\n/* vue.config.js */ module.exports = { ... devServer: { // string | Object 代理设置 proxy: { // 接口是 '/repos' 开头的才用代理 '/repos': { target: 'https://api.github.com', // 目标地址 changeOrigin: true, // 是否改变源地址 // pathRewrite: {'^/api': ''} } }, } ... } 在 devServer 中 我们配置 proxy 进行接口的代理，将我们本地地址转换为真实的服务器地址，此时我们同样能顺利的获取到数据，不同点在于接口状态变成了 304（重定向）。\n公共设施配置 最后我们项目开发中肯定需要对一些公共的方法进行封装使用，这里我把它称之为公共设施，那么我们可以在 src 目录下建一个 common 文件夹来存放其配置文件：\n└── src └── common ├── index.js # 公共配置入口 ├── validate.js # 表单验证配置 └── other.js # 其他配置 在入口文件中我们可以向外暴露其他功能配置的模块，比如：\n/* index.js */ import Validate from './validate' import Other from './other' export { Validate, Other, } 这样我们在页面中只需要引入一个 index.js 即可。\n结语 本案例代码地址：single-page-project"},"title":"spa_config"},"/frontend-learn/docs/practice/vuecli3/webpack/":{"data":{"webpack-在-cli-3-中的应用#webpack 在 CLI 3 中的应用":"webpack 在 CLI 3 中的应用","webpack-的使用#webpack 的使用":"与 vue-cli 2.x 的差异 vue-cli 2.x 其构建出的目录会包含相应的 webpack 配置文件，但是在 vue-cli 3.x 中却见不到一份关于 webpack 的配置文件，难道 3.x 抛弃了 webpack？其实不然， 3.x 提供了一种开箱即用的模式，即你无需配置 webpack 就可以运行项目，并且它提供了一个vue.config.js文件来满足开发者对其封装的 webpack 默认配置的修改。如图：\nvue.config.js 的配置 通过上方新老版本的对比，我们可以清晰的看出 vue.config.js 的配置项结构，如果你构建的项目中没有该文件，那么你需要在根目录手动创建它。 下面就来介绍一下其常用配置项的功能和用途：\nbaseurl 通过 vue-cli 3.x 成功构建并在浏览器中打开http://localhost:8080/展示了项目首页。如果现在你想要将项目地址加一个二级目录，比如：http://localhost:8080/vue/， 那么我们需要在vue.config.js里配置baseurl这一项：\n// vue.config.js module.exports = { ... baseUrl: 'vue', ... } 其改变的其实是 webpack 配置文件中output的publicPath项，这时候你重启终端再次打开页面的时候我们首页的 url 就会变成带二级目录的形式。\noutputDir 如果你想将构建好的文件打包输出到output文件夹下（默认是dist文件夹），你可以配置：\n// vue.config.js module.exports = { ... outputDir: 'output', ... } 然后运行命令yarn build进行打包输出，你会发现项目跟目录会创建output文件夹， 这其实改变了 webpack 配置中output下的path项，修改了文件的输出路径。\nproductionSourceMap 该配置项用于设置是否为生产环境构建生成 source map，一般在生产环境下为了快速定位错误信息，我们都会开启 source map：\n// vue.config.js module.exports = { ... productionSourceMap: true, ... } 该配置会修改 webpack 中devtool项的值为source-map。\nchainWebpack chainWebpack配置项允许我们更细粒度的控制 webpack 的内部配置，其集成的是webpack-chain这一插件， 该插件可以让我们能够使用链式操作来修改配置，比如：\n// 用于做相应的合并处理 const merge = require('webpack-merge'); module.exports = { ... // config 参数为已经解析好的 webpack 配置 chainWebpack: config =\u003e { config.module .rule('images') .use('url-loader') .tap(options =\u003e merge(options, { limit: 5120, }) ) } ... } 以上操作我们可以成功修改 webpack 中module项里配置 rules 规则为图片下的 url-loader 值，将其 limit 限制改为 5M，修改后的 webpack 配置代码如下：\n{ ... module: { rules: [ { /* config.module.rule('images') */ test: /\\.(png|jpe?g|gif|webp)(\\?.*)?$/, use: [ /* config.module.rule('images').use('url-loader') */ { loader: 'url-loader', options: { limit: 5120, name: 'img/[name].[hash:8].[ext]' } } ] } ] } ... } 这里需要注意的是我们使用了 webpack-merge 这一插件，该插件用于做 webpack 配置的合并处理，这样 options 下面的其他值就不会被覆盖或改变。\nwebpack-chain 它提供了操作类似 JavaScript Set 和 Map 的方式，以及一系列速记方法。\nconfigureWebpack 除了上述使用chainWebpack来改变 webpack 内部配置外，我们还可以使用configureWebpack来进行修改，两者的不同点在于 chainWebpack是链式修改，而configureWebpack更倾向于整体替换和修改。示例代码如下：\n// vue.config.js module.exports = { ... // config 参数为已经解析好的 webpack 配置 configureWebpack: config =\u003e { // config.plugins = []; // 这样会直接将 plugins 置空 // 使用 return 一个对象会通过 webpack-merge 进行合并，plugins 不会置空 return { plugins: [] } } ... } configureWebpack可以直接是一个对象，也可以是一个函数，如果是对象它会直接使用 webpack-merge 对其进行合并处理，如果是函数， 你可以直接使用其config参数来修改 webpack 中的配置，或者返回一个对象来进行 merge 处理。\n你可以在项目目录下运行vue inspect来查看你修改后的 webpack 完整配置，当然你也可以缩小审查范围，比如：\n# 只查看 plugins 的内容 vue inspect plugins devServer vue.config.js还提供了devServer项用于配置 webpack-dev-server 的行为，使得我们可以对本地服务器进行相应配置，我们在命令行中运行的yarn serve 对应的命令vue-cli-service serve其实便是基于 webpack-dev-server 开启的一个本地服务器，其常用配置参数如下：\n// vue.config.js module.exports = { ... devServer: { open: true, // 是否自动打开浏览器页面 host: '0.0.0.0', // 指定使用一个 host。默认是 localhost port: 8080, // 端口地址 https: false, // 使用https提供服务 proxy: null, // string | Object 代理设置 // 提供在服务器内部的其他中间件之前执行自定义中间件的能力 before: app =\u003e { // `app` 是一个 express 实例 } } ... } 其支持所有的 webpack-dev-server 中的选项，比如historyApiFallback用于重写路由（会在后续的多页应用配置中讲解）、progress将运行进度输出到控制台等， 具体可参考：devServer\n以上讲解了 vue.config.js 中一些常用的配置项功能，具体的配置实现需要结合实际项目进行， 完整的配置项可以查看：vue.config.js\n默认插件简介 通过对 vue.config.js 的了解，我们知道了 vue-cli 3.x 为我们默认封装了项目运行的常用 webpack 配置，那么它给我们提供了哪些默认插件， 每一个 plugin 又有着怎样的用途呢？除了使用vue inspect plugins我们还可以通过运行vue ui进入可视化页面查看，步骤如下：\n打开可视化页面，点击对应项目进入管理页面（如果没有对应项目，需要导入或新建） 点击侧边栏 Tasks 选项，再点击二级栏 inspect 选项 点击 Run task 按钮执行审查命令 如图所示： 最后我们从输出的内容中找到 plugins 数组，其包含了如下插件（配置项已经省略，增加了定义插件的代码）：\n// vue-loader是 webpack 的加载器，允许你以单文件组件的格式编写 Vue 组件 const VueLoaderPlugin = require('vue-loader/lib/plugin'); // webpack 内置插件，用于创建在编译时可以配置的全局常量 const {DefinePlugin} = require('content/docs/pactice/vuecli3/webpack'); // 用于强制所有模块的完整路径必需与磁盘上实际路径的确切大小写相匹配 const CaseSensitivePathsPlugin = require('case-sensitive-paths-webpack-plugin'); // 识别某些类型的 webpack 错误并整理，以提供开发人员更好的体验。 const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin'); // 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件 const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); // 用于在 webpack 构建期间优化、最小化 CSS文件 const OptimizeCssnanoPlugin = require('optimize-css-assets-webpack-plugin'); // webpack 内置插件，用于根据模块的相对路径生成 hash 作为模块 id, 一般用于生产环境 const {HashedModuleIdsPlugin} = require('content/docs/pactice/vuecli3/webpack'); // 用于根据模板或使用加载器生成 HTML 文件 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 用于在使用 html-webpack-plugin 生成的 html 中添加 \u003clink rel ='preload'\u003e 或 \u003clink rel ='prefetch'\u003e，有助于异步加载 const PreloadPlugin = require('preload-webpack-plugin'); // 用于将单个文件或整个目录复制到构建目录 const CopyWebpackPlugin = require('copy-webpack-plugin'); module.exports = { plugins: [ /* config.plugin('vue-loader') */ new VueLoaderPlugin(), /* config.plugin('define') */ new DefinePlugin(), /* config.plugin('case-sensitive-paths') */ new CaseSensitivePathsPlugin(), /* config.plugin('friendly-errors') */ new FriendlyErrorsWebpackPlugin(), /* config.plugin('extract-css') */ new MiniCssExtractPlugin(), /* config.plugin('optimize-css') */ new OptimizeCssnanoPlugin(), /* config.plugin('hash-module-ids') */ new HashedModuleIdsPlugin(), /* config.plugin('html') */ new HtmlWebpackPlugin(), /* config.plugin('preload') */ new PreloadPlugin(), /* config.plugin('copy') */ new CopyWebpackPlugin() ] } "},"title":"webpack"}}