<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on Frontend Learning</title><link>http://shipengqi.github.io/frontend-learn/</link><description>Recent content in 主要内容 on Frontend Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://shipengqi.github.io/frontend-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>HTML 标签</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/01_tags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/01_tags/</guid><description>HTML 标签 # HTML 页面的基本结构 # 一个 HTML 页面的基本结构：
&amp;lt;!doctype html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt; &amp;lt;base href=&amp;#34;/&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;!-- 设置不同尺寸的 favicon，浏览器会根据分辨率自动加载合适的 favicon --&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-16x16.ico&amp;#34; sizes=&amp;#34;16x16&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-32x32.ico&amp;#34; sizes=&amp;#34;32x32&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-48x48.ico&amp;#34; sizes=&amp;#34;48x48&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon.ico&amp;#34;&amp;gt; &amp;lt;!-- Fallback for older browsers --&amp;gt; &amp;lt;link rel=&amp;#34;apple-touch-icon&amp;#34; sizes=&amp;#34;180x180&amp;#34; href=&amp;#34;apple-touch-icon.png&amp;#34;&amp;gt; &amp;lt;!-- 针对苹果设备，苹果设备保存网页到桌面的图标 --&amp;gt; &amp;lt;link rel=&amp;#34;manifest&amp;#34; href=&amp;#34;site.webmanifest&amp;#34;&amp;gt; &amp;lt;!-- For PWA --&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;app-root&amp;gt;&amp;lt;/app-root&amp;gt; &amp;lt;!</description></item><item><title>CSS 常用属性</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/02_css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/02_css/</guid><description>CSS 常用属性 # 容器属性 # 盒子模型属性 # 一个元素的组成：内容 + 内边距 + 边框 + 外边距
width 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 box-sizing：盒子模型默认是 box-sizing: content-box。
border-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块) # div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。
块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行内元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行内元素设置宽高是无效的。另外包含 display: inline 的属性也是内级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 一个元素一旦成为了弹性布局或者网格布局的直接子元素，那么该元素之前的模式会失效，例如：</description></item><item><title>布局与定位</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/03_layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/03_layout/</guid><description>布局与定位 # 浮动布局 # 浮动布局的好处：
可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。
元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。
例如下面的 html，三个 &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。
&amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 如果不想有空格，可以像下面这样，把换行和空格去掉：
&amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 上面的方式，不好看，可以使用浮动解决：
.child { float: left } 第一个子元素 &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。
清除浮动 # 浮动会导致父元素的高度塌陷。
比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。
因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。
解决方式：
设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：
.parent { } .parent:after{ content: &amp;#34;&amp;#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。</description></item><item><title>过渡和动画</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/04_animation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/04_animation/</guid><description>过渡和动画 # 页面中元素的变化，按照变化发起的逻辑可以分为触发型和自动型。
让元素发生变化，有三种方式：
CSS：适合简单的变化效果， CSS+JS：稍微复杂的变化效果，需要配合一下交互的 JS：类似在 canvas 元素上进行 2D 或者 3D 图像绘制的 元素变化的主要的属性：
位置 尺寸 缩放，和尺寸类似，但是会带动元素整体，包裹内部元素进行缩放。 旋转 透明度 投影 颜色 边框 过渡效果 # 将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。
过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。
示例：
transition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：
transition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡缓动曲线。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义，贝塞尔曲线。可以使用一下工具来得到换动曲线： 浏览器开发者工具的 cubic-bezier 工具。 cubic-bezier easings steps，步数 transition-delay：过渡延迟时间。 steps # steps(count, start|end) 是一个特殊的时间函数，它和其他关键字 linear 等最大的区别就是，它不是一个连贯的变化，是一步一步的硬切换。</description></item><item><title>其他属性</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/05_other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/05_other/</guid><description>其他属性 # 渐变 # 线性渐变 # 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)
示例：
/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 # 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。</description></item><item><title>CSS 选择器</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/06_selector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/06_selector/</guid><description>CSS 选择器 # 通用选择器，* 匹配任何元素。 标签选择器，匹配所有对应标签的元素。 类名选择器，匹配所有 class 属性中包含对应类名的元素。 ID 选择器，匹配 id 属性等于指定值的元素。 属性选择器 [attr]：存在某个属性，无论该属性有没有值 [attr=value]：属性等于特定值 [attr~=value]：属性具有多个空格分隔的值中的一个。例如一个元素具有属性 class=&amp;quot;btn btn-primary&amp;quot;，那么可以被 [class~=&amp;quot;btn&amp;quot;] 所匹配。 [attr|=value]：属性值是特定值或以 {值}- 开始。例如选择器 [title|=&amp;quot;hello&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-1&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello1&amp;quot;，不可以匹配 [attr^=value]：属性值以特定值开始。例如选择器 [title^=&amp;quot;hello&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-1&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello1&amp;quot;，可以匹配 [attr$=value]：属性值以特定值结束。例如选择器 [title$=&amp;quot;abc&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，不可以匹配 一个元素具有属性 title=&amp;quot;hello-abc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;helloabc&amp;quot;，可以匹配 [attr*=value]：属性值包含特定值。例如选择器 [title*=&amp;quot;abc&amp;quot;]： 一个元素具有属性 title=&amp;quot;heabcllo&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-abc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;helloabc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;abchello&amp;quot;，可以匹配 组合选择器 # 例如 h1.test[title*=&amp;quot;abc&amp;quot;]，这是一个组合选择器，表示含有 class=test 和符合 [title*=&amp;quot;abc&amp;quot;] 的 h1 标签。
组合选择器的顺序是可以随意的，但是标签选择器因为没有特定的前缀符号，所以只能放在第一个，例如 .testh1 会被认为是 class=testh1。</description></item><item><title>响应式</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/07_responsive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/07_responsive/</guid><description>响应式 # 响应式的目的就是让页面在不同的设备，不同的尺寸上能够正常的合理的显示页面内容。
使用固定尺寸的方式开发页面，就会碰到尺寸不同导致页面显示不完整等问题：
电脑端浏览器的显示尺寸是可变的。 不同电脑的显示尺寸不同。 移动端设备屏幕小，尺寸多，浏览器的显示尺寸是固定的。 设备的交互方式不同，例如在电脑浏览器中的 :hover 在移动端是不存在的。 响应式的处理核心是基于浏览器的显示区域的宽度，然后来调整页面中元素的布局和尺寸。
响应式处理，变化的主要是三个方面：
元素尺寸 文字、图片 布局结构 交互方式 利用单位实现元素的逐步变化 # 实现元素尺寸的逐步变化，最常用的单位就是 % 和 vh、vw 等视窗单位。如果想要元素跟随父元素的尺寸逐步变化，那么可以使用 % 来实现。如果想要元素跟随视窗的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。
vh 和 vw 相对于浏览器整个显示区域的尺寸，但是对于移动端设备，这个尺寸是包括地址栏和功能栏的。例如，一个元素设置了 100vh 的高度，在移动端浏览器中，元素的一部分是会被地址栏工具栏覆盖的。这个时候就可以使用移动端专用的视窗单位：
lvh、lvw：l 表示 large。 svh、svw：s 表示 small。 dvh、dvw：d 表示 dynamic。 详细的使用方式：CSS 新 Viewport 视口单位 svh、lvh 和 dvh
文字大小的逐步变化 # 文字大小的尺寸设置一般是用 px，em 和 rem，这三种单位都可以算是固定单位。因为 em 是相对于父元素的字体大小。rem 是相对于根元素（html 标签）的字体大小。也就是说如果父元素或者根元素的字体大小不变，那么利用 em 或 rem 设置尺寸的元素的内部元素的文字大小肯定也不会变化。
如果想要文字的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。
通常，文字是不需要根据页面尺寸变化而变化的。
Flex 布局和 Grid 布局中元素的逐步变化 # Flex 布局和 Grid 布局中的子元素都是可以缩放的。</description></item><item><title>Chrome 开发者工具</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/08_chrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/08_chrome/</guid><description>Chrome 开发者工具 # Chrome 的开发者工具查看元素的样式如下图：
右侧样式的排序，选择器的优先级高的会在上面。
use agent stylesheet 是浏览器给元素的默认样式。 :hov 给元素强制加上某种伪类，使元素显示对应的样式。 :cls 给元素添加 class 切换页面的深色模式：
Computed 包含盒子模型和元素最终显示出来的样式的值。
如果在修改一些元素的样式，发现不生效时，就可以在列表中，点击对应属性。它会把这个属性相关的所有设置都列出来。列表中的第一个就是最终生效的那个，下面的就是被覆盖的。
上面的盒子模型的值都是可以修改的。
Device ToolBar # 1：切换移动端模式。 2：添加更多的移动端设备，并且可以添加自定义尺寸的设备。 3：选择自适应模式，设备尺寸可以任意调整。 4：缩放。 5：节流模式，可以模拟网速的快慢，无网络等状态。 6：旋转，模拟屏幕旋转。 媒体查询 # 打开媒体查询工具：
打开之后，尺寸下面多了一栏，鼠标悬浮上去会显示，当前的宽度是什么设备的尺寸。
如果设置了媒体查询，会出现对应的一行，鼠标悬浮上去会显示匹配的规则。
上图中有三条媒体查询的规则：
.parent { width: 50vh; height: 50vh; background-color: aqua; } @media (min-width: 600px) { .parent { background-color: blueviolet; } } @media (max-width: 1000px) { .parent { background-color: blueviolet; } } @media (min-width: 600px) and (max-width: 1000px) { .</description></item></channel></rss>