<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on Frontend Learning</title><link>http://shipengqi.github.io/frontend-learn/</link><description>Recent content in 主要内容 on Frontend Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://shipengqi.github.io/frontend-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>HTML 标签</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/01_tags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/01_tags/</guid><description>HTML 标签 # HTML 页面的基本结构 # 一个 HTML 页面的基本结构：
&amp;lt;!doctype html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt; &amp;lt;base href=&amp;#34;/&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;!-- 设置不同尺寸的 favicon，浏览器会根据分辨率自动加载合适的 favicon --&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-16x16.ico&amp;#34; sizes=&amp;#34;16x16&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-32x32.ico&amp;#34; sizes=&amp;#34;32x32&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-48x48.ico&amp;#34; sizes=&amp;#34;48x48&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon.ico&amp;#34;&amp;gt; &amp;lt;!-- Fallback for older browsers --&amp;gt; &amp;lt;link rel=&amp;#34;apple-touch-icon&amp;#34; sizes=&amp;#34;180x180&amp;#34; href=&amp;#34;apple-touch-icon.png&amp;#34;&amp;gt; &amp;lt;!-- 针对苹果设备，苹果设备保存网页到桌面的图标 --&amp;gt; &amp;lt;link rel=&amp;#34;manifest&amp;#34; href=&amp;#34;site.webmanifest&amp;#34;&amp;gt; &amp;lt;!-- For PWA --&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;app-root&amp;gt;&amp;lt;/app-root&amp;gt; &amp;lt;!</description></item><item><title>概念</title><link>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/01_overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/01_overview/</guid><description>概念 # RxJS：Think of RxJS as Lodash for events。也就是说，RxJS 是一个类似 lodash 的工具库，不过处理的对象是 Events。这里的 Events，可以称之为流。
什么是流？例如，代码中每秒会输出一个数据，或者用户每一次对元素的点击，就像是在时间这个维度上，产生了一个数据集。这个数据集不像数组那样，它不是一开始都存在的，而是随着时间的流逝，一个一个数据被输出出来。这种异步行为产生的数据，就可以被称之为一个流，在 Rxjs 中，称之为 Observalbe（本质其实就是一个数据集合，只是这些数据不一定是一开始就设定好的，而是随着时间而不断产生的）。而 Rxjs，就是为了处理这种流而产生的工具，比如流与流的合并，流的截断，延迟，消抖等等操作。
import {interval, map} from &amp;#39;rxjs&amp;#39;; const sub = interval(1000).pipe( map(second =&amp;gt; second + &amp;#39;s&amp;#39;) ).subscribe(res =&amp;gt; { console.log(res); }); // Output: // 0s // 2s // 3s // 4s // 5s // ... 利用 interval 返回一个 Observable 流，每 1 秒产生一个数据，然后交给 map 操作符将内容进行转换，最后交过观察者打印结果。
Observable 的核心 # 创建 # import { Observable } from &amp;#39;rxjs&amp;#39;; const observable = new Observable(function subscribe(subscriber) { const timer = setInterval(() =&amp;gt; { // 可以多次调用 next 方法向外发送数据 subscriber.</description></item><item><title>CSS 常用属性</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/02_css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/02_css/</guid><description>CSS 常用属性 # 容器属性 # 盒子模型属性 # 一个元素的组成：内容 + 内边距 + 边框 + 外边距
width 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 box-sizing：盒子模型默认是 box-sizing: content-box。
border-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块) # div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。
块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行内元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行内元素设置宽高是无效的。另外包含 display: inline 的属性也是内级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 一个元素一旦成为了弹性布局或者网格布局的直接子元素，那么该元素之前的模式会失效，例如：</description></item><item><title>操作符</title><link>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/02_operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/02_operators/</guid><description>操作符 # 操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。并且前面的 Observable 保持不变。
操作符有两类：
Pipeable 操作符：是指可以使用 observable.pipe(operator) 或更常用的 observable.pipe(operatorFactory()) 语法将操作符管道化的操作符。操作符工厂函数包括 filter(...) 和 mergeMap(...) 等。 创建操作符可以作为独立函数调用，可以创建一个新的 Observable。例如：of(1, 2, 3)。 创建操作符 # range # range(start, length)，调用方法后返回 Observable 对象，被订阅后会发出指定范围的数值。
import { range } from &amp;#34;rxjs&amp;#34; range(0, 5).subscribe(n =&amp;gt; console.log(n)) // Output: // 0 // 1 // 2 // 3 // 4 of # 将参数列表作为数据流返回。
of(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, [], {}, true, 20).subscribe(v =&amp;gt; console.log(v)) // Output: // a // b // [] // {｝ // true // 20 from, fromEvent, fromPromise # // 将数组转为 Observable from([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;]).</description></item><item><title>Subject</title><link>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/03_subject/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/03_subject/</guid><description>Subject # RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，这意味着 Subject 确保每个观察者之间共享 Observable 的值。
而普通的 Observable 是单播的，它会为每一个观察者创建一次新的、独立的执行。当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。
在 RxJS 中有四种 Subject 分别是：Subject，BehaviorSubject，AsyncSubject，ReplaySubject；这四种 Subject 都是特殊的 Observable。
Subject 既是 Observable 也是 Observer。
Subject # Subject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，它会把订阅者添加到观察者列表中，每当有接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next 方法，把值一一送出。
import { Subject } from &amp;#39;rxjs&amp;#39;; const subject$ = new Subject&amp;lt;number&amp;gt;(); subject$.next(1); subject$.subscribe({ next: (v) =&amp;gt; console.log(`observerA: ${v}`), }); subject$.next(2); subject$.subscribe({ next: (v) =&amp;gt; console.log(`observerB: ${v}`), }); subject$.next(3); // Output: // observerA: 2 // observerA: 3 // observerB: 3 创建了一个 Subject 发出了一个值 1，但由于此时并没有订阅者，所以这个值不会被订阅到 创建了 observerA 又发出一个值 2，这时候 observerA 会接收到这个值 又创建一个 observerB 最后发出一个值 3，这时候已经订阅的都会接收到这个值 BehaviorSubject # BehaviorSubject，它有一个当前值的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到最后发出的值。</description></item><item><title>布局与定位</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/03_layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/03_layout/</guid><description>布局与定位 # 浮动布局 # 浮动布局的好处：
可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。
元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。
例如下面的 html，三个 &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。
&amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 如果不想有空格，可以像下面这样，把换行和空格去掉：
&amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 上面的方式，不好看，可以使用浮动解决：
.child { float: left } 第一个子元素 &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。
清除浮动 # 浮动会导致父元素的高度塌陷。
比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。
因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。
解决方式：
设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：
.parent { } .parent:after{ content: &amp;#34;&amp;#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。</description></item><item><title>实践</title><link>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/04_practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/framework/rxjs/04_practice/</guid><description>实践 # 优雅的资源释放 # 对于无限值必须要取消订阅，反之可以不需要。例如监听 DOM 元素的事件：
Observable.fromEvent(node, &amp;#39;input&amp;#39;) .subscribe(value =&amp;gt; { console.log(value); }); 因为如果不取消订阅，事件所关联的方法会一直被占用，导致内存泄露。
传统方式 # @Component({ selector: &amp;#39;app-demo&amp;#39;, template: ` &amp;lt;div&amp;gt;Hello, world!&amp;lt;/div&amp;gt; ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = new Subject&amp;lt;void&amp;gt;(); private timer; constructor() { this.timer = interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } 上面的在组件中定义了一个私有变量 _destroy$，是一个 Subject 对象，用于在组件销毁时发出信号以释放资源。通过 takeUntil(this._destroy$) 操作符来限制 Observable 的生命周期，在 _destroy$ 发出信号时停止发出值。
这种方式虽然使用了 takeUntil 来限制 Observable 的生命周期，但是仍然需要在 ngOnDestroy 钩子中手动调用 _destroy$.</description></item><item><title>过渡和动画</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/04_animation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/04_animation/</guid><description>过渡和动画 # 页面中元素的变化，按照变化发起的逻辑可以分为触发型和自动型。
让元素发生变化，有三种方式：
CSS：适合简单的变化效果， CSS+JS：稍微复杂的变化效果，需要配合一下交互的 JS：类似在 canvas 元素上进行 2D 或者 3D 图像绘制的 元素变化的主要的属性：
位置 尺寸 缩放，和尺寸类似，但是会带动元素整体，包裹内部元素进行缩放。 旋转 透明度 投影 颜色 边框 过渡效果 # 将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。
过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。
示例：
transition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：
transition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡缓动曲线。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义，贝塞尔曲线。可以使用一下工具来得到换动曲线： 浏览器开发者工具的 cubic-bezier 工具。 cubic-bezier easings steps，步数 transition-delay：过渡延迟时间。 steps # steps(count, start|end) 是一个特殊的时间函数，它和其他关键字 linear 等最大的区别就是，它不是一个连贯的变化，是一步一步的硬切换。</description></item><item><title>其他属性</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/05_other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/05_other/</guid><description>其他属性 # 渐变 # 线性渐变 # 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)
示例：
/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 # 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。</description></item><item><title>CSS 选择器</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/06_selector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/06_selector/</guid><description>CSS 选择器 # 通用选择器，* 匹配任何元素。 标签选择器，匹配所有对应标签的元素。 类名选择器，匹配所有 class 属性中包含对应类名的元素。 ID 选择器，匹配 id 属性等于指定值的元素。 属性选择器 [attr]：存在某个属性，无论该属性有没有值 [attr=value]：属性等于特定值 [attr~=value]：属性具有多个空格分隔的值中的一个。例如一个元素具有属性 class=&amp;quot;btn btn-primary&amp;quot;，那么可以被 [class~=&amp;quot;btn&amp;quot;] 所匹配。 [attr|=value]：属性值是特定值或以 {值}- 开始。例如选择器 [title|=&amp;quot;hello&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-1&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello1&amp;quot;，不可以匹配 [attr^=value]：属性值以特定值开始。例如选择器 [title^=&amp;quot;hello&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-1&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello1&amp;quot;，可以匹配 [attr$=value]：属性值以特定值结束。例如选择器 [title$=&amp;quot;abc&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，不可以匹配 一个元素具有属性 title=&amp;quot;hello-abc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;helloabc&amp;quot;，可以匹配 [attr*=value]：属性值包含特定值。例如选择器 [title*=&amp;quot;abc&amp;quot;]： 一个元素具有属性 title=&amp;quot;heabcllo&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-abc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;helloabc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;abchello&amp;quot;，可以匹配 组合选择器 # 例如 h1.test[title*=&amp;quot;abc&amp;quot;]，这是一个组合选择器，表示含有 class=test 和符合 [title*=&amp;quot;abc&amp;quot;] 的 h1 标签。
组合选择器的顺序是可以随意的，但是标签选择器因为没有特定的前缀符号，所以只能放在第一个，例如 .testh1 会被认为是 class=testh1。</description></item><item><title>响应式</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/07_responsive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/07_responsive/</guid><description>响应式 # 响应式的目的就是让页面在不同的设备，不同的尺寸上能够正常的合理的显示页面内容。
使用固定尺寸的方式开发页面，就会碰到尺寸不同导致页面显示不完整等问题：
电脑端浏览器的显示尺寸是可变的。 不同电脑的显示尺寸不同。 移动端设备屏幕小，尺寸多，浏览器的显示尺寸是固定的。 设备的交互方式不同，例如在电脑浏览器中的 :hover 在移动端是不存在的。 响应式的处理核心是基于浏览器的显示区域的宽度，然后来调整页面中元素的布局和尺寸。
响应式处理，变化的主要是三个方面：
元素尺寸 文字、图片 布局结构 交互方式 利用单位实现元素的逐步变化 # 实现元素尺寸的逐步变化，最常用的单位就是 % 和 vh、vw 等视窗单位。如果想要元素跟随父元素的尺寸逐步变化，那么可以使用 % 来实现。如果想要元素跟随视窗的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。
vh 和 vw 相对于浏览器整个显示区域的尺寸，但是对于移动端设备，这个尺寸是包括地址栏和功能栏的。例如，一个元素设置了 100vh 的高度，在移动端浏览器中，元素的一部分是会被地址栏工具栏覆盖的。这个时候就可以使用移动端专用的视窗单位：
lvh、lvw：l 表示 large。 svh、svw：s 表示 small。 dvh、dvw：d 表示 dynamic。 详细的使用方式：CSS 新 Viewport 视口单位 svh、lvh 和 dvh
文字大小的逐步变化 # 文字大小的尺寸设置一般是用 px，em 和 rem，这三种单位都可以算是固定单位。因为 em 是相对于父元素的字体大小。rem 是相对于根元素（html 标签）的字体大小。也就是说如果父元素或者根元素的字体大小不变，那么利用 em 或 rem 设置尺寸的元素的内部元素的文字大小肯定也不会变化。
如果想要文字的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。
通常，文字是不需要根据页面尺寸变化而变化的。
Flex 布局和 Grid 布局中元素的逐步变化 # Flex 布局和 Grid 布局中的子元素都是可以缩放的。</description></item><item><title>SVG</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/08_svg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/08_svg/</guid><description> SVG # SVG (Scaleable Vector Graphics) 可伸缩矢量图形，也即是说不管怎么放大，图形都不会失真。适合在响应式的网站中使用。
与矢量图相对应的是位图，位图放的比较大的时候就会失真。常见的位图格式如：png、jpg、gif。只要是有图片分辨率的都是位图。位图本质上，它是由一个个像素点组成的。图片文件里保存的是每个像素点的颜色值。所以它一旦放大了之后，相当于让多个像素点显示同一个颜色，这样就会造成模糊的效果。
矢量图保存的不是每个像素点的颜色值，而是图形的绘制逻辑。所以它本质上是文本文件，体积较小。
LottieFiles：一个基于 SVG 的开源的动画解决方案，可以直接在网页端，手机端制作动画效果，再导出某种格式的文件。LottieFiles 的 Marketplace 中，有很多的动画效果，可以直接使用。 Rive：基于 Canvas 实现的动画解决方案，大部分动画效果都可以实现，2D，3D。</description></item><item><title>Chrome 开发者工具</title><link>http://shipengqi.github.io/frontend-learn/docs/basic/html/09_chrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/basic/html/09_chrome/</guid><description>Chrome 开发者工具 # Chrome 的开发者工具查看元素的样式如下图：
右侧样式的排序，选择器的优先级高的会在上面。
use agent stylesheet 是浏览器给元素的默认样式。 :hov 给元素强制加上某种伪类，使元素显示对应的样式。 :cls 给元素添加 class 切换页面的深色模式：
Computed 包含盒子模型和元素最终显示出来的样式的值。
如果在修改一些元素的样式，发现不生效时，就可以在列表中，点击对应属性。它会把这个属性相关的所有设置都列出来。列表中的第一个就是最终生效的那个，下面的就是被覆盖的。
上面的盒子模型的值都是可以修改的。
Device ToolBar # 1：切换移动端模式。 2：添加更多的移动端设备，并且可以添加自定义尺寸的设备。 3：选择自适应模式，设备尺寸可以任意调整。 4：缩放。 5：节流模式，可以模拟网速的快慢，无网络等状态。 6：旋转，模拟屏幕旋转。 媒体查询 # 打开媒体查询工具：
打开之后，尺寸下面多了一栏，鼠标悬浮上去会显示，当前的宽度是什么设备的尺寸。
如果设置了媒体查询，会出现对应的一行，鼠标悬浮上去会显示匹配的规则。
上图中有三条媒体查询的规则：
.parent { width: 50vh; height: 50vh; background-color: aqua; } @media (min-width: 600px) { .parent { background-color: blueviolet; } } @media (max-width: 1000px) { .parent { background-color: blueviolet; } } @media (min-width: 600px) and (max-width: 1000px) { .</description></item></channel></rss>