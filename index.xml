<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on Frontend Learning</title><link>http://shipengqi.github.io/frontend-learn/</link><description>Recent content in 主要内容 on Frontend Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://shipengqi.github.io/frontend-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>HTML 标签</title><link>http://shipengqi.github.io/frontend-learn/docs/html/01_tags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/01_tags/</guid><description>HTML 页面的基本结构 # 一个 HTML 页面的基本结构：
&amp;lt;!doctype html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt; &amp;lt;base href=&amp;#34;/&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1&amp;#34;&amp;gt; &amp;lt;!-- 设置不同尺寸的 favicon，浏览器会根据分辨率自动加载合适的 favicon --&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-16x16.ico&amp;#34; sizes=&amp;#34;16x16&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-32x32.ico&amp;#34; sizes=&amp;#34;32x32&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon-48x48.ico&amp;#34; sizes=&amp;#34;48x48&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;icon&amp;#34; type=&amp;#34;image/x-icon&amp;#34; href=&amp;#34;favicon.ico&amp;#34;&amp;gt; &amp;lt;!-- Fallback for older browsers --&amp;gt; &amp;lt;link rel=&amp;#34;apple-touch-icon&amp;#34; sizes=&amp;#34;180x180&amp;#34; href=&amp;#34;apple-touch-icon.png&amp;#34;&amp;gt; &amp;lt;!-- 针对苹果设备，苹果设备保存网页到桌面的图标 --&amp;gt; &amp;lt;link rel=&amp;#34;manifest&amp;#34; href=&amp;#34;site.webmanifest&amp;#34;&amp;gt; &amp;lt;!-- For PWA --&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;app-root&amp;gt;&amp;lt;/app-root&amp;gt; &amp;lt;!-- &amp;lt;script&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &amp;lt;!</description></item><item><title>概念</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/01_overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/01_overview/</guid><description>概念 # RxJS：Think of RxJS as Lodash for events。也就是说，RxJS 是一个类似 lodash 的工具库，不过处理的对象是 Events。这里的 Events，可以称之为流。
什么是流？例如，代码中每秒会输出一个数据，或者用户每一次对元素的点击，就像是在时间这个维度上，产生了一个数据集。这个数据集不像数组那样，它不是一开始都存在的，而是随着时间的流逝，一个一个数据被输出出来。这种异步行为产生的数据，就可以被称之为一个流，在 Rxjs 中，称之为 Observalbe（本质其实就是一个数据集合，只是这些数据不一定是一开始就设定好的，而是随着时间而不断产生的）。而 Rxjs，就是为了处理这种流而产生的工具，比如流与流的合并，流的截断，延迟，消抖等等操作。
import {interval, map} from &amp;#39;rxjs&amp;#39;; const sub = interval(1000).pipe( map(second =&amp;gt; second + &amp;#39;s&amp;#39;) ).subscribe(res =&amp;gt; { console.log(res); }); // Output: // 0s // 2s // 3s // 4s // 5s // ... 利用 interval 返回一个 Observable 流，每 1 秒产生一个数据，然后交给 map 操作符将内容进行转换，最后交过观察者打印结果。
Observable 的核心 # 创建 # import { Observable } from &amp;#39;rxjs&amp;#39;; const observable = new Observable(function subscribe(subscriber) { const timer = setInterval(() =&amp;gt; { // 可以多次调用 next 方法向外发送数据 subscriber.</description></item><item><title>概述</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/01_overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/01_overview/</guid><description>NgModule # Angular 应用是由一个个模块组成的，称作 NgModule。
NgModule 是一组相关功能的集合，专注于某个应用领域，可以将组件和一组相关代码关联起来，是应用组织代码结构的一种方式。
NgModule 可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。
NgModule 是由 NgModule 装饰器函数装饰的类。
import { BrowserModule } from &amp;#39;@angular/platform-browser&amp;#39;; import { NgModule } from &amp;#39;@angular/core&amp;#39;; @NgModule({ imports: [ BrowserModule ] }) export class AppModule { } @NgModule 元数据 # NgModule 是一个带有 @NgModule() 装饰器的类。@NgModule() 元数据对象比较重要的属性：
declarations 属于当前 NgModule 的组件、指令、管道。 exports 导出当前 NgModule 的组件、指令、管道的列表。 imports 导入的 NgModule、组件、指令、管道的列表。 providers 当前 NgModule 所需的服务。 bootstrap 应用的主视图，称为根组件。它是应用中所有其它视图的宿主。只有 root module 才应该设置这个 bootstrap 属性。 组件 # 组件用来描述用户界面，它由三部分组成，组件类、组件模板、组件样式，它们可以被集成在组件类文件中，也可以是三个不同的文件。</description></item><item><title>CSS 常用属性</title><link>http://shipengqi.github.io/frontend-learn/docs/html/02_css/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/02_css/</guid><description>容器属性 # 盒子模型属性 # 一个元素的组成：内容 + 内边距 + 边框 + 外边距
width 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 box-sizing：盒子模型默认是 box-sizing: content-box。
border-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块) # div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。
块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行内元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行内元素设置宽高是无效的。另外包含 display: inline 的属性也是内级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 一个元素一旦成为了弹性布局或者网格布局的直接子元素，那么该元素之前的模式会失效，例如：</description></item><item><title>操作符</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/02_operators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/02_operators/</guid><description>概述 # 操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。并且前面的 Observable 保持不变。
操作符有两类：
Pipeable 操作符：是指可以使用 observable.pipe(operator) 或更常用的 observable.pipe(operatorFactory()) 语法将操作符管道化的操作符。操作符工厂函数包括 filter(...) 和 mergeMap(...) 等。 创建操作符可以作为独立函数调用，可以创建一个新的 Observable。例如：of(1, 2, 3)。 创建操作符 # range # range(start, length)，调用方法后返回 Observable 对象，被订阅后会发出指定范围的数值。
import { range } from &amp;#34;rxjs&amp;#34; range(0, 5).subscribe(n =&amp;gt; console.log(n)) // Output: // 0 // 1 // 2 // 3 // 4 of # 将参数列表作为数据流返回。
of(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, [], {}, true, 20).subscribe(v =&amp;gt; console.log(v)) // Output: // a // b // [] // {｝ // true // 20 from, fromEvent, fromPromise # // 将数组转为 Observable from([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;]).</description></item><item><title>组件模板</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/02_component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/02_component/</guid><description>数据绑定 # 数据绑定就是将组件类中的数据显示在组件模板中，当组件类中的数据发生变化时会自动被同步到组件模板中（数据驱动 DOM ）。
在 Angular 中使用差值表达式进行数据绑定，即 {{ }}。
&amp;lt;h2&amp;gt;{{message}}&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;{{getInfo()}}&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;{{a == b ? &amp;#39;相等&amp;#39;: &amp;#39;不等&amp;#39;}}&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;{{&amp;#39;Hello Angular&amp;#39;}}&amp;lt;/h2&amp;gt; &amp;lt;p [innerHTML]=&amp;#34;htmlSnippet&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;!-- 对数据中的代码进行转义 --&amp;gt; 属性绑定 # 普通属性 # 属性绑定分为两种情况，绑定 DOM 对象属性和绑定 HTML 标记属性。
使用 [属性名称] 为元素绑定 DOM 对象属性。
&amp;lt;img [src]=&amp;#34;imgUrl&amp;#34;/&amp;gt; 使用 [attr.属性名称] 为元素绑定 HTML 标记属性
&amp;lt;td [attr.colspan]=&amp;#34;colSpan&amp;#34;&amp;gt;&amp;lt;/td&amp;gt; 在大多数情况下，DOM 对象属性和 HTML 标记属性是对应的关系，所以使用第一种情况。但是某些属性只有 HTML 标记存在，DOM 对象中不存在，此时需要使用第二种情况，比如 colspan 属性，在 DOM 对象中就没有，或者自定义 HTML 属性也需要使用第二种情况。
class 属性 # &amp;lt;button class=&amp;#34;btn btn-primary&amp;#34; [class.active]=&amp;#34;isActive&amp;#34;&amp;gt;按钮&amp;lt;/button&amp;gt; &amp;lt;div [ngClass]=&amp;#34;{&amp;#39;active&amp;#39;: true, &amp;#39;error&amp;#39;: true}&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; ngClass 可以绑定多个类名。</description></item><item><title>Subject</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/03_subject/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/03_subject/</guid><description>概述 # RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，这意味着 Subject 确保每个观察者之间共享 Observable 的值。
而普通的 Observable 是单播的，它会为每一个观察者创建一次新的、独立的执行。当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。
在 RxJS 中有四种 Subject 分别是：Subject，BehaviorSubject，AsyncSubject，ReplaySubject；这四种 Subject 都是特殊的 Observable。
Subject 既是 Observable 也是 Observer。
Subject # Subject 其实是观察者模式的实现，所以当观察者订阅 Subject 对象时，它会把订阅者添加到观察者列表中，每当有接收到新值时，它就会遍历观察者列表，依次调用观察者内部的 next 方法，把值一一送出。
import { Subject } from &amp;#39;rxjs&amp;#39;; const subject$ = new Subject&amp;lt;number&amp;gt;(); subject$.next(1); subject$.subscribe({ next: (v) =&amp;gt; console.log(`observerA: ${v}`), }); subject$.next(2); subject$.subscribe({ next: (v) =&amp;gt; console.log(`observerB: ${v}`), }); subject$.next(3); // Output: // observerA: 2 // observerA: 3 // observerB: 3 创建了一个 Subject 发出了一个值 1，但由于此时并没有订阅者，所以这个值不会被订阅到 创建了 observerA 又发出一个值 2，这时候 observerA 会接收到这个值 又创建一个 observerB 最后发出一个值 3，这时候已经订阅的都会接收到这个值 BehaviorSubject # BehaviorSubject，它有一个当前值的概念。它保存了发送给消费者的最新值，当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到最后发出的值。</description></item><item><title>布局与定位</title><link>http://shipengqi.github.io/frontend-learn/docs/html/03_layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/03_layout/</guid><description>浮动布局 # 浮动布局的好处：
可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。
元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。
例如下面的 html，三个 &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。
&amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 如果不想有空格，可以像下面这样，把换行和空格去掉：
&amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; 上面的方式，不好看，可以使用浮动解决：
.child { float: left } 第一个子元素 &amp;lt;div class=&amp;quot;child&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。
清除浮动 # 浮动会导致父元素的高度塌陷。
比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。
因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。
解决方式：
设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：
.parent { } .parent:after{ content: &amp;#34;&amp;#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。</description></item><item><title>组件通讯</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/03_communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/03_communication/</guid><description>向组件内部传递数据 # Input 装饰器 # &amp;lt;app-favorite [isFavorite]=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/app-favorite&amp;gt; // favorite.component.ts import { Input } from &amp;#39;@angular/core&amp;#39;; export class FavoriteComponent { @Input() isFavorite: boolean = false; } 注意：在属性的外面加 [] 表示绑定动态值，对于布尔类型，不加 [] 表示绑定普通值，例如 true 在组件内接收后是字符串 &amp;quot;true&amp;quot;。
&amp;lt;app-favorite [is-Favorite]=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/app-favorite&amp;gt; import { Input } from &amp;#39;@angular/core&amp;#39;; export class FavoriteComponent { @Input(&amp;#34;is-Favorite&amp;#34;) isFavorite: boolean = false } 向组件外部传递数据 # Output 装饰器 # &amp;lt;!-- 子组件模板 --&amp;gt; &amp;lt;button (click)=&amp;#34;onClick()&amp;#34;&amp;gt;click&amp;lt;/button&amp;gt; // 子组件类 import { EventEmitter, Output } from &amp;#34;@angular/core&amp;#34; export class FavoriteComponent { @Output() change = new EventEmitter() onClick() { this.</description></item><item><title>实践</title><link>http://shipengqi.github.io/frontend-learn/docs/rxjs/04_practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/rxjs/04_practice/</guid><description>优雅的资源释放 # 对于无限值必须要取消订阅，反之可以不需要。例如监听 DOM 元素的事件：
Observable.fromEvent(node, &amp;#39;input&amp;#39;) .subscribe(value =&amp;gt; { console.log(value); }); 因为如果不取消订阅，事件所关联的方法会一直被占用，导致内存泄露。
传统方式 # @Component({ selector: &amp;#39;app-demo&amp;#39;, template: ` &amp;lt;div&amp;gt;Hello, world!&amp;lt;/div&amp;gt; ` }) export class GeneralComponent implements OnDestroy { private readonly _destroy$ = new Subject&amp;lt;void&amp;gt;(); private timer; constructor() { this.timer = interval(1000).pipe(takeUntil(this._destroy$)).subscribe(console.log); } ngOnDestroy() { this._destroy$.next(); this._destroy$.complete(); } } 上面的在组件中定义了一个私有变量 _destroy$，是一个 Subject 对象，用于在组件销毁时发出信号以释放资源。通过 takeUntil(this._destroy$) 操作符来限制 Observable 的生命周期，在 _destroy$ 发出信号时停止发出值。
这种方式虽然使用了 takeUntil 来限制 Observable 的生命周期，但是仍然需要在 ngOnDestroy 钩子中手动调用 _destroy$.next() 和 _destroy$.</description></item><item><title>组件生命周期</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/04_lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/04_lifecycle/</guid><description>概述 # 生命周期钩子执行顺序：
ngOnChanges：当组件的输入属性（@Input）发生变化时会调用。 ngOnInit：当组件初始化时被调用。这通常在 Angular 初始化组件并绑定所有输入属性后触发。 ngDoCheck：在每次 Angular 检查组件变化时被调用。它比 ngOnChanges 更加底层，允许自定义检测逻辑。 ngAfterContentInit：当组件的内容投影（&amp;lt;ng-content&amp;gt;）初始化完成后触发。这个钩子在 Angular 投影内容进入组件后调用一次。 ngAfterContentChecked：当 Angular 完成对组件内容投影的变更检测后调用。 ngAfterViewInit：当组件的视图（包括子组件的视图）初始化完成后调用。也就是说，它在视图的所有子组件和模板内容都加载完毕后触发。 ngAfterViewChecked：每次视图（包括子视图）变更检测之后调用。它会在 Angular 每次更新视图之后触发。 ngOnDestroy：当组件销毁之前调用。可以用来执行清理工作，如取消订阅、清理定时器等。 挂载阶段 # 挂载阶段的生命周期函数只在挂载阶段执行一次，数据更新时不再执行。
constructor
Angular 在实例化组件类时执行, 可以用来接收 Angular 注入的服务实例对象。
export class ChildComponent { constructor (private test: TestService) { console.log(this.test) // &amp;#34;test&amp;#34; } } ngOnInit
ngOnInit 会在组件的输入属性被绑定之后被调用，适合在组件加载时执行需要的初始化工作。
&amp;lt;app-child name=&amp;#34;张三&amp;#34;&amp;gt;&amp;lt;/app-child&amp;gt; export class ChildComponent implements OnInit { @Input(&amp;#34;name&amp;#34;) name: string = &amp;#34;&amp;#34; ngOnInit() { console.log(this.name) // &amp;#34;张三&amp;#34; } } ngAfterContentInit</description></item><item><title>过渡和动画</title><link>http://shipengqi.github.io/frontend-learn/docs/html/04_animation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/04_animation/</guid><description>概述 # 页面中元素的变化，按照变化发起的逻辑可以分为触发型和自动型。
让元素发生变化，有三种方式：
CSS：适合简单的变化效果， CSS+JS：稍微复杂的变化效果，需要配合一下交互的 JS：类似在 canvas 元素上进行 2D 或者 3D 图像绘制的 元素变化的主要的属性：
位置 尺寸 缩放，和尺寸类似，但是会带动元素整体，包裹内部元素进行缩放。 旋转 透明度 投影 颜色 边框 过渡效果 # 将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。
过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。
示例：
transition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：
transition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡缓动曲线。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义，贝塞尔曲线。可以使用一下工具来得到换动曲线： 浏览器开发者工具的 cubic-bezier 工具。 cubic-bezier easings steps，步数 transition-delay：过渡延迟时间。 steps # steps(count, start|end) 是一个特殊的时间函数，它和其他关键字 linear 等最大的区别就是，它不是一个连贯的变化，是一步一步的硬切换。</description></item><item><title>其他属性</title><link>http://shipengqi.github.io/frontend-learn/docs/html/05_other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/05_other/</guid><description>渐变 # 线性渐变 # 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)
示例：
/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 # 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。</description></item><item><title>指令</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/05_directive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/05_directive/</guid><description>概述 # 指令是 Angular 提供的操作 DOM 的途径。指令分为属性指令和结构指令。
属性指令：修改现有元素的外观或行为，selector 使用 [] 包裹。
结构指令：增加、删除 DOM 节点以修改布局，使用 * 作为指令前缀。
内置指令 # *ngIf # 根据条件渲染 DOM 节点或移除 DOM 节点。
&amp;lt;div *ngIf=&amp;#34;data.length == 0&amp;#34;&amp;gt;没有更多数据&amp;lt;/div&amp;gt; &amp;lt;div *ngIf=&amp;#34;data.length &amp;gt; 0; then dataList else noData&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;ng-template #dataList&amp;gt;课程列表&amp;lt;/ng-template&amp;gt; &amp;lt;ng-template #noData&amp;gt;没有更多数据&amp;lt;/ng-template&amp;gt; [hidden] # 根据条件显示 DOM 节点或隐藏 DOM 节点。
&amp;lt;div [hidden]=&amp;#34;data.length == 0&amp;#34;&amp;gt;课程列表&amp;lt;/div&amp;gt; &amp;lt;div [hidden]=&amp;#34;data.length &amp;gt; 0&amp;#34;&amp;gt;没有更多数据&amp;lt;/div&amp;gt; *ngFor # 遍历数据生成HTML结构
interface List { id: number name: string age: number } list: List[] = [ { id: 1, name: &amp;#34;张三&amp;#34;, age: 20 }, { id: 2, name: &amp;#34;李四&amp;#34;, age: 30 } ] &amp;lt;li *ngFor=&amp;#34; let item of list; let i = index; // 下标 let isEven = even; // 是否是第偶数个元素 let isOdd = odd; // 是否是第奇数个元素 let isFirst = first; // 是否是第一个元素 let isLast = last; // 是否是最后一个元素 &amp;#34; &amp;gt; &amp;lt;/li&amp;gt; trackBy # 在 Angular 中遍历数组时，会用到 ngFor 指令，如果数组中的数据改变了（新数组替换旧数组），Angular 会删除与数据关联的所有 DOM 元素，然后再次创建它们。这意味着将有很多 DOM 操作。</description></item><item><title>CSS 选择器</title><link>http://shipengqi.github.io/frontend-learn/docs/html/06_selector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/06_selector/</guid><description>概述 # 通用选择器，* 匹配任何元素。 标签选择器，匹配所有对应标签的元素。 类名选择器，匹配所有 class 属性中包含对应类名的元素。 ID 选择器，匹配 id 属性等于指定值的元素。 属性选择器 [attr]：存在某个属性，无论该属性有没有值 [attr=value]：属性等于特定值 [attr~=value]：属性具有多个空格分隔的值中的一个。例如一个元素具有属性 class=&amp;quot;btn btn-primary&amp;quot;，那么可以被 [class~=&amp;quot;btn&amp;quot;] 所匹配。 [attr|=value]：属性值是特定值或以 {值}- 开始。例如选择器 [title|=&amp;quot;hello&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-1&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello1&amp;quot;，不可以匹配 [attr^=value]：属性值以特定值开始。例如选择器 [title^=&amp;quot;hello&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-1&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello1&amp;quot;，可以匹配 [attr$=value]：属性值以特定值结束。例如选择器 [title$=&amp;quot;abc&amp;quot;]： 一个元素具有属性 title=&amp;quot;hello&amp;quot;，不可以匹配 一个元素具有属性 title=&amp;quot;hello-abc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;helloabc&amp;quot;，可以匹配 [attr*=value]：属性值包含特定值。例如选择器 [title*=&amp;quot;abc&amp;quot;]： 一个元素具有属性 title=&amp;quot;heabcllo&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;hello-abc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;helloabc&amp;quot;，可以匹配 一个元素具有属性 title=&amp;quot;abchello&amp;quot;，可以匹配 组合选择器 # 例如 h1.test[title*=&amp;quot;abc&amp;quot;]，这是一个组合选择器，表示含有 class=test 和符合 [title*=&amp;quot;abc&amp;quot;] 的 h1 标签。
组合选择器的顺序是可以随意的，但是标签选择器因为没有特定的前缀符号，所以只能放在第一个，例如 .testh1 会被认为是 class=testh1。</description></item><item><title>管道</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/06_pipe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/06_pipe/</guid><description>概述 # 管道的作用是转换组件模板数据。要在 HTML 模板中指定值的转换方式，使用管道操作符 |。
内置管道 # date 日期格式化 currency 货币格式化 uppercase 转大写 lowercase 转小写 json 格式化 json 数据 {{ date | date: &amp;#34;yyyy-MM-dd&amp;#34; }} {{ num | currency: &amp;#34;￥&amp;#34; }} // ￥{num} 自定义管道 # 需求：指定字符串不能超过规定的长度
// summary.pipe.ts import { Pipe, PipeTransform } from &amp;#39;@angular/core&amp;#39;; @Pipe({ name: &amp;#39;summary&amp;#39; }); export class SummaryPipe implements PipeTransform { transform (value: string, limit?: number) { if (!value) return null; let actualLimit = (limit) ?</description></item><item><title>依赖注入</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/07_di/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/07_di/</guid><description>概述 # 依赖注入 ( Dependency Injection ) 简称 DI，是面向对象编程中的一种设计原则，用来减少代码之间的耦合度。
class MailService { constructor(APIKEY) {} } class EmailSender { mailService: MailService constructor() { this.mailService = new MailService(&amp;#34;APIKEY1234567890&amp;#34;) } sendMail(mail) { this.mailService.sendMail(mail) } } const emailSender = new EmailSender() emailSender.sendMail(mail) EmailSender 类运行时要依赖 MailService 类。
以上写法的耦合度太高，代码并不健壮。如果 MailService 类改变了参数的传递方式，在 EmailSender 的构造函数中的写法也要跟着改变。
class EmailSender { mailService: MailService constructor(mailService: MailService) { this.mailService = mailService; } } const mailService = new MailService(&amp;#34;APIKEY1234567890&amp;#34;) const emailSender = new EmailSender(mailService) 在实例化 EmailSender 类时将它的依赖项通过 constructor 构造函数参数的形式注入到类的内部，这种写法就是依赖注入。</description></item><item><title>响应式</title><link>http://shipengqi.github.io/frontend-learn/docs/html/07_responsive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/07_responsive/</guid><description>概述 # 响应式的目的就是让页面在不同的设备，不同的尺寸上能够正常的合理的显示页面内容。
使用固定尺寸的方式开发页面，就会碰到尺寸不同导致页面显示不完整等问题：
电脑端浏览器的显示尺寸是可变的。 不同电脑的显示尺寸不同。 移动端设备屏幕小，尺寸多，浏览器的显示尺寸是固定的。 设备的交互方式不同，例如在电脑浏览器中的 :hover 在移动端是不存在的。 响应式的处理核心是基于浏览器的显示区域的宽度，然后来调整页面中元素的布局和尺寸。
响应式处理，变化的主要是三个方面：
元素尺寸 文字、图片 布局结构 交互方式 利用单位实现元素的逐步变化 # 实现元素尺寸的逐步变化，最常用的单位就是 % 和 vh、vw 等视窗单位。如果想要元素跟随父元素的尺寸逐步变化，那么可以使用 % 来实现。如果想要元素跟随视窗的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。
vh 和 vw 相对于浏览器整个显示区域的尺寸，但是对于移动端设备，这个尺寸是包括地址栏和功能栏的。例如，一个元素设置了 100vh 的高度，在移动端浏览器中，元素的一部分是会被地址栏工具栏覆盖的。这个时候就可以使用移动端专用的视窗单位：
lvh、lvw：l 表示 large。 svh、svw：s 表示 small。 dvh、dvw：d 表示 dynamic。 详细的使用方式：CSS 新 Viewport 视口单位 svh、lvh 和 dvh
文字大小的逐步变化 # 文字大小的尺寸设置一般是用 px，em 和 rem，这三种单位都可以算是固定单位。因为 em 是相对于父元素的字体大小。rem 是相对于根元素（html 标签）的字体大小。也就是说如果父元素或者根元素的字体大小不变，那么利用 em 或 rem 设置尺寸的元素的内部元素的文字大小肯定也不会变化。
如果想要文字的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。
通常，文字是不需要根据页面尺寸变化而变化的。
Flex 布局和 Grid 布局中元素的逐步变化 # Flex 布局和 Grid 布局中的子元素都是可以缩放的。</description></item><item><title>SVG</title><link>http://shipengqi.github.io/frontend-learn/docs/html/08_svg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/08_svg/</guid><description> 概述 # SVG (Scalable Vector Graphics) 可伸缩矢量图形，也即是说不管怎么放大，图形都不会失真。适合在响应式的网站中使用。
与矢量图相对应的是位图，位图放的比较大的时候就会失真。常见的位图格式如：png、jpg、gif。只要是有图片分辨率的都是位图。位图本质上，它是由一个个像素点组成的。图片文件里保存的是每个像素点的颜色值。所以它一旦放大了之后，相当于让多个像素点显示同一个颜色，这样就会造成模糊的效果。
矢量图保存的不是每个像素点的颜色值，而是图形的绘制逻辑。所以它本质上是文本文件，体积较小。
LottieFiles：一个基于 SVG 的开源的动画解决方案，可以直接在网页端，手机端制作动画效果，再导出某种格式的文件。LottieFiles 的 Marketplace 中，有很多的动画效果，可以直接使用。 Rive：基于 Canvas 实现的动画解决方案，大部分动画效果都可以实现，2D，3D。</description></item><item><title>服务</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/08_service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/08_service/</guid><description>创建服务 # import { Injectable } from &amp;#39;@angular/core&amp;#39;; @Injectable({ providedIn: &amp;#39;root&amp;#39; }) export class TestService { } 使用：
export class AppComponent { // 这里的 TestService 实际上就是获取示例对象的 Token（唯一标识） constructor (private _test: TestService) {} } 服务的作用域 # 使用服务可以轻松实现跨模块跨组件共享数据，这取决于服务的作用域。
在根注入器中注册服务，所有模块使用同一个服务实例对象。
import { Injectable } from &amp;#39;@angular/core&amp;#39;; @Injectable({ providedIn: &amp;#39;root&amp;#39; }) export class CarListService { } 在模块级别注册服务，该模块中的所有组件使用同一个服务实例对象。
新语法：
import { Injectable } from &amp;#39;@angular/core&amp;#39;; import { CarModule } from &amp;#39;./car.module&amp;#39;; @Injectable({ providedIn: CarModule, }) export class CarListService { } 老语法：</description></item><item><title>Chrome 开发者工具</title><link>http://shipengqi.github.io/frontend-learn/docs/html/09_chrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/html/09_chrome/</guid><description>Chrome 开发者工具 # Chrome 的开发者工具查看元素的样式如下图：
右侧样式的排序，选择器的优先级高的会在上面。
use agent stylesheet 是浏览器给元素的默认样式。 :hov 给元素强制加上某种伪类，使元素显示对应的样式。 :cls 给元素添加 class 切换页面的深色模式：
Computed 包含盒子模型和元素最终显示出来的样式的值。
如果在修改一些元素的样式，发现不生效时，就可以在列表中，点击对应属性。它会把这个属性相关的所有设置都列出来。列表中的第一个就是最终生效的那个，下面的就是被覆盖的。
上面的盒子模型的值都是可以修改的。
Device ToolBar # 1：切换移动端模式。 2：添加更多的移动端设备，并且可以添加自定义尺寸的设备。 3：选择自适应模式，设备尺寸可以任意调整。 4：缩放。 5：节流模式，可以模拟网速的快慢，无网络等状态。 6：旋转，模拟屏幕旋转。 媒体查询 # 打开媒体查询工具：
打开之后，尺寸下面多了一栏，鼠标悬浮上去会显示，当前的宽度是什么设备的尺寸。
如果设置了媒体查询，会出现对应的一行，鼠标悬浮上去会显示匹配的规则。
上图中有三条媒体查询的规则：
.parent { width: 50vh; height: 50vh; background-color: aqua; } @media (min-width: 600px) { .parent { background-color: blueviolet; } } @media (max-width: 1000px) { .parent { background-color: blueviolet; } } @media (min-width: 600px) and (max-width: 1000px) { .</description></item><item><title>表单</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/09_form/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/09_form/</guid><description>概述 # 在 Angular 中，表单有两种类型，分别为模板驱动表单和响应式表单。
模板驱动表单 # 概述 # 表单的控制逻辑写在组件模板中，适合简单的表单类型。
快速上手 # 引入依赖模块 FormsModule
import { FormsModule } from &amp;#34;@angular/forms&amp;#34; @NgModule({ imports: [FormsModule], }) export class AppModule {} 将 DOM 表单转换为 ngForm
&amp;lt;form #f=&amp;#34;ngForm&amp;#34; (submit)=&amp;#34;onSubmit(f)&amp;#34;&amp;gt;&amp;lt;/form&amp;gt; 声明表单字段为 ngModel
&amp;lt;form #f=&amp;#34;ngForm&amp;#34; (submit)=&amp;#34;onSubmit(f)&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; ngModel /&amp;gt; &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 获取表单字段值
import { NgForm } from &amp;#34;@angular/forms&amp;#34; export class AppComponent { onSubmit(form: NgForm) { console.log(form.value) } } 表单分组
当你的表单的表单项比较多，可以把相关的表单项分组。
&amp;lt;form #f=&amp;#34;ngForm&amp;#34; (submit)=&amp;#34;onSubmit(f)&amp;#34;&amp;gt; &amp;lt;div ngModelGroup=&amp;#34;user&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;username&amp;#34; ngModel /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div ngModelGroup=&amp;#34;contact&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;phone&amp;#34; ngModel /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; 分组后，访问表单数据，例如 username，就是 form.</description></item><item><title>自定义表单控件</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/10_custom_form/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/10_custom_form/</guid><description>自定义表单控件 # 创建自定义表单控件时，通常需要三步：
实现 ControlValueAccessor 接口：使自定义控件能够与 Angular 表单框架配合使用。 实现 Validator 接口：提供自定义的验证逻辑。 注册自定义控件为 Angular 表单控件。 实现 ControlValueAccessor 接口 # ControlValueAccessor 接口允许自定义控件与 Angular 的表单控件（FormControl, ngModel）进行交互。需要实现以下方法：
writeValue(value: any): void：这个方法会将父组件的表单值写入自定义控件。 registerOnChange(fn: any): void：当自定义控件的值发生变化时，调用该方法通知父组件。 registerOnTouched(fn: any): void：当控件被触摸时（比如失去焦点），会调用这个方法通知父组件。通常来说，将 onBlur() 事件会绑定到控件的 blur 事件上，并在 onBlur() 方法中调用它。。 setDisabledState(isDisabled: boolean): void：用于设置控件的禁用状态。可以根据 isDisabled 值来禁用或启用自定义控件。 writeValue 和 setDisabledState 通常在父组件中调用 CustomFormControl.setValue() 和 CustomFormControl.disable() 方法时会执行。父组件初始化控件时也会执行，例如：
this.myCustomCtrl = new FormControl({value: &amp;#39;&amp;#39;, disabled: true}); 实现 ControlValueAccessor 接口示例：
import { Component, forwardRef } from &amp;#39;@angular/core&amp;#39;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from &amp;#39;@angular/forms&amp;#39;; @Component({ selector: &amp;#39;app-custom-input&amp;#39;, template: `&amp;lt;input [value]=&amp;#34;value&amp;#34; (input)=&amp;#34;onInput($event)&amp;#34; /&amp;gt;`, providers: [ { provide: NG_VALUE_ACCESSOR, // 注册到 Angular 表单系统 useExisting: forwardRef(() =&amp;gt; CustomInputComponent), // 指向当前组件 multi: true // 表示可以有多个实现 } ] }) export class CustomInputComponent implements ControlValueAccessor { value: string = &amp;#39;&amp;#39;; onChange: any = () =&amp;gt; {}; onTouched: any = () =&amp;gt; {}; // 实现 ControlValueAccessor 接口 registerOnChange(fn: any): void { this.</description></item><item><title>路由</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/11_router/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/11_router/</guid><description>快速上手 # 创建页面组件、Layout 组件以及 Navigation 组件，供路由使用
创建首页页面组件ng g c pages/home 创建关于我们页面组件ng g c pages/about 创建布局组件ng g c pages/layout 创建导航组件ng g c pages/navigation 创建路由规则
// app.module.ts import { Routes } from &amp;#34;@angular/router&amp;#34; const routes: Routes = [ { path: &amp;#34;home&amp;#34;, component: HomeComponent }, { path: &amp;#34;about&amp;#34;, component: AboutComponent } ] 引入路由模块并启动
// app.module.ts import { RouterModule, Routes } from &amp;#34;@angular/router&amp;#34; @NgModule({ imports: [RouterModule.forRoot(routes, { useHash: true })], }) export class AppModule {} 添加路由插座</description></item><item><title>HttpClient</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/12_http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/12_http/</guid><description>该模块用于发送 Http 请求，用于发送请求的方法都返回 Observable 对象。
快速开始 # 引入 HttpClientModule 模块
// app.module.ts import { httpClientModule } from &amp;#39;@angular/common/http&amp;#39;; imports: [ httpClientModule ] 注入 HttpClient 服务实例对象，用于发送请求
// app.component.ts import { HttpClient } from &amp;#39;@angular/common/http&amp;#39;; export class AppComponent { constructor(private http: HttpClient) {} } 发送请求
import { HttpClient } from &amp;#34;@angular/common/http&amp;#34; export class AppComponent implements OnInit { constructor(private http: HttpClient) {} ngOnInit() { this.getUsers().subscribe(console.log) } getUsers() { return this.http.get(&amp;#34;https://jsonplaceholder.typicode.com/users&amp;#34;) } } 请求方法 # this.</description></item><item><title>其他</title><link>http://shipengqi.github.io/frontend-learn/docs/angular/13_other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/frontend-learn/docs/angular/13_other/</guid><description>Angular 操作 DOM # ElementRef # ElementRef 是一个包装器，提供了对原生 DOM 元素的引用，通常是通过 @ViewChild 或 @ContentChild 来访问模板中的元素，但也可以直接注入 ElementRef 来操作宿主元素。
当你直接注入 ElementRef 时，Angular 会自动将组件或指令的宿主元素传递给你。你可以通过 ElementRef 访问宿主元素，并执行一些 DOM 操作：
import { Component, ElementRef, OnInit } from &amp;#39;@angular/core&amp;#39;; @Component({ selector: &amp;#39;app-example&amp;#39;, template: `&amp;lt;p&amp;gt;This is an example component!&amp;lt;/p&amp;gt;` }) export class ExampleComponent implements OnInit { constructor(private elementRef: ElementRef) {} ngOnInit() { // 通过 ElementRef 访问宿主元素 console.log(this.elementRef.nativeElement); // 打印宿主元素 this.elementRef.nativeElement.style.backgroundColor = &amp;#39;lightblue&amp;#39;; // 动态修改背景色 } } 直接注入 ElementRef 虽然可以直接通过 nativeElement 操作 DOM，但更推荐使用 Renderer2 来确保代码的跨平台兼容性、安全性和稳定性。</description></item></channel></rss>