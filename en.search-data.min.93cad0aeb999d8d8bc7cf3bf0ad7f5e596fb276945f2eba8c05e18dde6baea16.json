[{"id":0,"href":"/frontend-learn/docs/basic/html/","title":"HTML 和 CSS","section":"前端基础","content":" HTML 和 CSS # HTML 超文本标记语言（HyperText Markup Language）：用来定义网页内容的标记语言。\n超文本：意思就是不止文本，还包括图片、音频、视频等。 标记：标记语言，就是用标记符号（HTML 标签）来标记文本，计算机就可以识别这些标记符号，从而对文本进行处理。 CSS 层叠样式表：用来定义 HTML 的显示样式。\nJavaScript： 脚本语言，用来定义与用户的交互。\n"},{"id":1,"href":"/frontend-learn/docs/basic/html/01_tags/","title":"HTML 标签","section":"HTML 和 CSS","content":" HTML 标签 # HTML 页面的基本结构 # 一个 HTML 页面的基本结构：\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Demo\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!doctype html\u0026gt;：声明文档类型是 html5。 \u0026lt;html\u0026gt;：根标签，一般只包含 head 和 body 标签。 \u0026lt;head\u0026gt;：标签内容一般不会显示在页面上，用于描述页面的信息。 \u0026lt;body\u0026gt;：页面的主要内容。 \u0026lt;title\u0026gt;：页面标题。 \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;..., .., ..\u0026quot;\u0026gt;：针对搜索引擎的页面关键字。 \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;...\u0026quot;\u0026gt;：针对搜索引擎的页面描述。 \u0026lt;style\u0026gt;：书写 css 样式。 常用标签 # h1-h6 标题，块级标签，占据一行 div 块级容器标签 p 段落，块级标签，占据一行 ul 无序列表 ol 有序列表 a 链接，\u0026lt;a href=\u0026quot;#element-id\u0026quot;\u0026gt; 可以进行页面内位置的跳转。 form 表单标签， action 属性是提交的页面（例如 https://www.baidu.com/s ） method 提交的方法，get 提交的数据会在链接上显示，一般用来搜索，post 提交的数据在 body 里面. "},{"id":2,"href":"/frontend-learn/docs/basic/html/02_css/","title":"CSS 属性","section":"HTML 和 CSS","content":" CSS 属性 # 容器属性 # 盒子模型属性 # 一个元素的组成：内容 + 内边距 + 边框 + 外边距\nwidth 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 box-sizing：盒子模型默认是 box-sizing: content-box。\nborder-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块/弹性元素) # div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。\n块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行级元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行级元素设置宽高是无效的。另外包含 display: inline 的属性也是行级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 背景 # 背景/背景颜色/背景图片\n盒子阴影 # 字体属性 # 声明使用的字体：font-family，取决于系统是否安装有对应的字体，例如 微软雅黑，黑体等。 字体样式：font-style，normal 默认的样式。 italic 斜体 字体大小，font-size。 字体颜色，color。 字体的粗细，font-weight，值可以是 100-900 或者 bold/bolder/lighter/normal，取决于系统是否安装有对应的字体。 字体排布，text-algin 值可以是 center/left/right。 字体行高，line-height，设置一行文字的高度。 字体修饰：text-decoration underline 下划 overline 上划线 line-through 删除线 字体阴影：text-shadow，text-shadow: {x 偏移值} {y 偏移值} {模糊度} {颜色}，text-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。 所有的字体属性都会继承父元素的字体属性，所以在 html 元素上设置字体属性，会使所有的元素都会默认继承 html 上的字体属性。\n字体图标 # 字体图标是用特殊的字体来显示图标，代替图片。\n字体图标的优势：\n可以使用字体属性，随时调整大小和颜色。 图标调整大小，不会因为过大而失真，因为字体是矢量图。 字体文件 size 普遍小于图片，可以降低服务器的带宽压力。 使用字体图标的方式：\n首先需要在 iconfont 下载字体图标。\nUnicode # 这个是最原始的方式，兼容性最好，支持 IE6+，以及所有现代浏览器。支持字体属性，但是由于是字体，所以不支持多色。只能使用单色图标。\n注意：新版 iconfont 支持两种方式引用多色图标：SVG symbol 引用方式和彩色字体图标模式。（使用彩色字体图标需要在「编辑项目」中开启「彩色」选项后并重新生成。）\n使用步骤如下：\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 声明字体，src 是字体文件的路径，多个文件是针对不同的浏览器 */ @font-face { font-family: \u0026#39;iconfont\u0026#39;; src: url(\u0026#39;iconfont.woff2?t=1723520893571\u0026#39;) format(\u0026#39;woff2\u0026#39;), url(\u0026#39;iconfont.woff?t=1723520893571\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;iconfont.ttf?t=1723520893571\u0026#39;) format(\u0026#39;truetype\u0026#39;); } /* 定义使用 iconfont 的样式 */ .iconfont { font-family: \u0026#34;iconfont\u0026#34; !important; /* 使用 iconfont 字体 */ font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } \u0026lt;/style\u0026gt; \u0026lt;!-- 挑选相应图标并获取字体编码（例如 \u0026amp;#x33;），应用于页面 --\u0026gt; \u0026lt;span class=\u0026#34;iconfont\u0026#34;\u0026gt;\u0026amp;#x33;\u0026lt;/span\u0026gt; Font Class # 主流方式。Font Class 是 Unicode 使用方式的一种变种，兼容性良好，兼容 IE8+，和所有现代浏览器（IE8 以上才支持伪元素）。\nFont Class 解决了 Unicode 书写不直观，语意不明确的问题。可以很容易分辨这个 icon 是什么。因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\n使用步骤如下：\n\u0026lt;!-- 引入项目下面生成的 fontclass 代码 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./iconfont.css\u0026#34;\u0026gt; \u0026lt;!-- 挑选相应图标并获取类名，应用于页面 --\u0026gt; \u0026lt;span class=\u0026#34;iconfont icon-xxx\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Font Class 就是使用了 :before 伪元素来实现的。\n例如：\n.icon-mtiIcon-yingyongshebei-fangbaocha:before { content: \u0026#34;\\e713\u0026#34;; } Symbol # 未来的主流方式。这种其实是做了一个 svg 的集合。支持多色图标，支持字体属性，但是兼容性较差。浏览器渲染 svg 的性能一般。\n转换 # 2D 转换 # 2D 转换有 2 个轴, x，y。\n平移：transform: translate(x, y)，x 和 y 可以分开设置（transform: translateX(200px) transform: translateY(100px)） 旋转：transform: rotate(x)，transform: rotate(30deg) 顺时针旋转 30 度，负数就是逆时针旋转。 3D 转换 # 3D 转换实现 3D 立体效果，有 3 个轴, x，y，z。\n透视点：眼睛与屏幕之间的距离。perspective （perspective: 1000px）意思是距离屏幕 1000 像素点的距离（一般在 \u0026lt;body\u0026gt; 上设置透视点）。透视点的位置默认是屏幕的正中央，perspective-origin 可以修改透视点的位置，例如 perspective-origin: left buttom 将透视点的位置改为左下。如果子元素需要保留 3D 效果，需要单独设置 transform-style: preserve-3d（一般在实现 3D 效果的子元素上设置 transform-style: preserve-3d）。 平移：transform: translate3d(x, y, z)，也可以分开设置，3D 比 2D 多了一个 translateZ(100px)。 旋转：transform: rotate3d(x, y,z, 30deg) 绕着 x，y，z 确定的轴旋转 30 度，rotateX(45deg) 绕着 X 轴旋转 45 度。rotateY() 绕着 Y 轴旋转。rotateZ() 绕着 Z 轴旋转。 放大和缩小： 放大：transform: scale(3) 放大 3 倍，transform: scale(0.5, 2) 表示水平缩小到 0.5 倍、垂直放大 2 倍。也可以分别设置 transform: scaleX(3) 水平放大 3 倍。scaleY 垂直缩放。 倾斜：transform: skew(15deg, 0deg) 基于 X 轴倾斜 15 度，Y 轴 0 度。值可以为负数。 过渡和动画 # 过渡效果 # 将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。\n过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。\n示例：\ntransition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：\ntransition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡变化的速度。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义。可以在浏览器的 cubic-bezier 工具中修改。 transition-delay：过渡延迟时间。 动画效果 # 动画效果的格式：\nanimation 的默认值 none 0 ease 0 1 normal none running。 关键帧，@keyframes {动画名称} animation 也可以分开设置：\nanimation-name：定义动画名称。 animation-duration：动画时间。animation-duration 属性是必须的，否则时长为 0，就不会播放动画了。 animation-delay：延迟时间。 animation-timing-function：动画速度，默认是 ease。 ease 先慢后快。 linear 线性。 steps() 步数。 cubic-bezier() 自定义。可以在浏览器的 cubic-bezier 工具中修改。 animation-iteration-count 迭代次数，infinite 表示无限。 infinite 无限次。 n 表示 n 次。 animation-direction：方向，默认是 normal，alternate 表示往返动画。 normal 默认值，正常播放。 reverse 反向播放。 alternate 往返动画。 alternate-reverse 反向往返动画。 animation-fill-mode：最后填充模式，也就是动画结束时，要应用到元素的样式。默认值是 none。 none 不填充。 forwards 应用动画结束时最后一帧的样式。 backwards 应用动画结束时第一帧的样式。 both 遵循 forwards 和 backwards 的规则，从而在两个方向上扩展动画属性。 animation-play-state：动画状态，默认值是 running。 running 正在播放。 paused 暂停。 示例：\n#div1 { /*3 次动画*/ animation: demo1 2s 3; /*animation: demo1 2s infinite alternate; 无限次的往返动画*/ } @keyframes demo1 { from { transform: translateX(0px); } to { transform: translateX(500px); } } @keyframes demo2 { 0% { transform: translateX(0px); background: red; } 20% { transform: translateX(500px); background: blue; } 70% { transform: translateX(500px); background: green; } 100% { transform: translateX(500px); background: yellow; } } @keyframes 用来设置关键帧，动画的中间过程会被补全。animation-timing-function 就是设置补全动画的速度。\nfrom 和 to 是关键帧，from 是动画开始时的状态，to 是动画结束时的状态。 0% 和 100% 是关键帧，0% 是动画开始时的状态，100% 是动画结束时的状态。还可以设置 10%，20% 等。 过渡和动画的区别 # 过渡的优点在于简单易用，但是它有几个很大的局限：\n需要事件触发，所以没法在网页加载时自动发生。 是一次性的，不能重复发生，除非一再触发。 只能定义开始状态和结束状态，不能定义中间状态。 一条过渡规则，只能定义一个属性的变化，不能涉及多个属性。 动画通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果，可以解决过渡的不足。\n常用单位 # %：百分比。 px：像素单位。 em：相对单位，相对于父元素的字体大小。不建议使用。2em 就是父元素 font-size 的两倍。1em 就是 1 倍。 rem：相对单位，相对于根元素（html 标签）的字体大小。 vw：viewport width 视窗宽度。1vw 就等于视窗宽度的 1%。 vh：viewport height 视窗宽度。1vh 就等于视窗高度的 1%。 伪元素 # 伪元素用于创建一些不在 DOM 树中的元素，‌并为其添加样式。‌例如，‌:before 和 :after 伪元素可以在一个元素前或后增加一些文本，‌并为这些文本添加样式。‌虽然用户可以看到这些文本，但是这些文本实际上不在 DOM 树中。\nMDN Web Docs (Pseudo-elements)。\n::before :before # 可以在元素的内容前面插入新内容。\n/* 在每个 h1 元素前面插入一幅图片 */ h1:before { content:url(smiley.gif); } ::after :after # 可以在元素的内容之后插入新内容。\n/* 在每个 h1 元素后面插入一幅图片 */ h1:after { content:url(smiley.gif); } 伪类 # 伪类用于当已有元素处于某个状态时，‌为其添加对应的样式。‌例如链接的四种状态：\na:link：普通的、未被访问的链接。 a:visited：用户已访问的链接。 a:hover： 鼠标指针位于链接的上方。 a:active：链接被点击的时刻。 MDN Web Docs (Pseudo-classes)。\n状态伪类 # 状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的。\n状态伪类的顺序很重要，顺序错误可能会导致没有效果。\n例如为链接的不同状态设置样式时，必须按照以下次序规则：\na:hover 必须位于 a:link 和 a:visited 之后，a:active 必须位于 a:hover 之后。\n\u0026lt;!-- 设置四种状态的背景颜色 --\u0026gt; a:link { background-color:#B2FF99; } a:visited { background-color:#FFFF85; } a:hover { background-color:#FF704D; } a:active { background-color:#FF704D; } 常用的状态伪类还有 :focus。\n结构化伪类 # 结构化伪类是 CSS3 新增的选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，可以减少 class 和 id 属性的定义，使文档结构更简洁。\n例如 :first-child 用来选择父元素的第一个子元素。\n/* 第一个子元素是 p 元素 */ p:first-child { color:blue; } /* 匹配的 p 元素中的第一个 i 元素 */ p \u0026gt; i:first-child { color:blue; } /* 第一个子元素是 p 元素的任意元素中的所有 i 元素 */ p:first-child i { color:blue; } "},{"id":3,"href":"/frontend-learn/docs/basic/html/03_layout/","title":"布局","section":"HTML 和 CSS","content":" 布局 # 浮动布局 # 浮动布局的好处：\n可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。\n元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。\n例如下面的 html，三个 \u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 如果不想有空格，可以像下面这样，把换行和空格去掉：\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上面的方式，不好看，可以使用浮动解决：\n.child { float: left } 第一个子元素 \u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。\n清除浮动 # 浮动会导致父元素的高度塌陷。\n比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。\n因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。\n解决方式：\n设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：\n.parent { } .parent:after{ content: \u0026#34;\u0026#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。\n弹性布局 # 弹性布局可以更方便的布局，但是对浏览器要求较高。\n概念：\n弹性容器：设置了 display: flex; 的元素即为弹性容器。 弹性子元素：弹性容器里的直接子元素。 display: flex：如果一个元素的设置了这个属性（弹性容器），那么他的直接子元素（孙子元素就不是弹性布局），就会按着弹性布局的方式来布局。\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 如果 parent 不是弹性布局，那么三个 child 都是块元素，每个元素会占据一整行。但是 parent 添加了 display: flex; 属性以后，三个子元素会在一行并排显示，不会有间距。\n直接子元素是弹性布局，但是parent 元素本身还是块级布局。\n弹性主轴和侧轴 # 弹性布局有一个主轴和一个侧轴：\n主轴：默认是水平向右，可以修改为水平向左或竖直向上，竖直向下。 侧轴：默认是竖直向下，可以修改为竖直向上或水平向左，水平向右， 弹性布局的子元素默认是在主轴上一行或者一竖，不会换行，默认情况下（flex-wrap: nowrap）如果一行子元素的宽度或者高度超过了父元素，所有的子元素就会等比例缩小。\n设置主轴的方向：\nflex-derection: row：默认是 row。 row 水平向右。 row-reverse 水平向左。 column 竖直向下。 column-reverse 竖直向上。 设置主轴的排布：\njustify-content: flex-start：默认是 flex-start。 flex-start 靠近主轴的起点。 flex-end 靠近主轴的终点。 center 主轴居中。 space-between 平均分布，和主轴的起点和终点没有间距。 space-around 平均分布，和主轴的起点和终点有间距，两边的间距是中间的一半。 space-evenly 平均分布，间距一致。 弹性布局，设置水平居中只需要 justify-content:center 就可以实现，如果不是弹性布局，可以用下面的方式：\ndisplay: block; /* 设置为块级元素 */ margin: 0 auto; /* auto 设置水平居中，必须是块元素 */ 设置侧轴的排布：\nalign-items: stretch：默认是 stretch。 stretch 拉伸，如果子元素没有设置高度或宽度，那么子元素会被拉伸到和父元素一样的高度或宽度。 flex-start 靠近侧轴的起点。 flex-end 靠近侧轴的终点。 center 侧轴居中。单行的侧轴没有平均分布。 换行：\nflex-wrap: nowrap：默认是 nowrap。 nowrap 不换行。 wrap 换行，如果侧轴排布是 stretch，换行以后是两行，那么两行会被拉伸，各占一半。 多行存在的时候，侧轴分布：\nalign-content: flex-start： flex-start 多行都向侧轴的起点靠拢。 flex-end 多行都向侧轴的终点靠拢。 center 多行居中。 space-around 平均分布，和侧轴的起点和终点有间距，两边的间距是中间的一半。 space-between 平均分布，和侧轴的起点和终点没有间距。 space-evenly 平均分布，间距一致。 弹性子元素会存在多个，如果要单独设置一个子元素侧轴的分布，可以给弹性子元素添加属性：\nalign-self: flex-start： flex-start 靠近侧轴的起点。 flex-end 靠近侧轴的终点。 center 侧轴居中。 主轴是不能单独设置一个子元素的分布的。\n弹性子元素的排序 # 如果要设置弹性子元素的排序，可以给每个子元素添加属性：\norder: {num} 子元素会沿主轴方向从小到大排序。 示例：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } .c1 { order: 3; background: skyblue; } .c2 { order: 2; background: green; } .c3 { order: 1; background: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child c1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 弹性子元素剩余空间配置 # 给子元素添加属性 flex: {num}，占据剩余份额的份数。flex: 1 就表示占据剩余空间的 1 份。\n示例：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; background: gray; } .child { width: 100px; height: 100px; } /* 剩余空间被分为 3 份，c1 占 1/3，c2 占 2/3 */ .c1 { flex: 1; background: skyblue; } .c2 { flex: 2; background: green; } .c3 { order: 1; background: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child c1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 上面的示例，每个子元素的宽度为 100px，那么剩余空间就是 300px。c1 会占据剩余空间的 100px，c2 占 200px。\n定位 # 定位：可以设置元素具体在某个位置上。元素默认就是 static，也就是没有定位。\nrelative、absolute、fixed 这三个属性值有一个共同点，都是相对于某个基点的定位，只是基点不同。\n相对定位 # position: relative：相对于默认位置（即 static 时的位置）的定位，虽然形状移动了，但是原来的位置依然占据着。必须配合 left/right/top/bottom 属性使用，用来指定偏移的方向和距离。\ndiv { position: relative; top: 20px; } 上面的示例，div 元素从默认位置向下偏移 20px（即距离顶部 20px）。\n绝对定位 # position: absolute：相对于最接进自身并且已定位的父元素或者祖先元素（不是 static 的元素）。必须配合 left/right/top/bottom 属性使用。\n设置了绝对定位的元素，会脱离文档流，不会占据空间。正常的元素会顶上去。\n固定定位 # position: fixed：固定在浏览器窗口中的某个位置，相对于浏览器窗口定位。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。配合 left/right/top/bottom 属性使用。\n粘性定位 # sticky 会产生动态效果，很像 relative 和 fixed 的结合。比如，网页的搜索工具栏，初始加载时，在自己的默认位置（relative 定位），页面向下滚动时，工具栏可以在距离浏览器相对应的位置固定住，始终停留在页面头部（fixed 定位）。等到页面重新向上滚动回到原位，工具栏也会回到默认位置。必须配合 left/right/top/bottom 属性使用。\n当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 sticky 元素的距离达到生效门槛，relative 定位自动切换为 fixed 定位；等到父元素完全脱离视口时（即完全不可见），fixed 定位自动切换回 relative 定位。\n层 # z-index: {num} 设置层级：\n同一个父元素下，数值越大，越上层。 不同的父元素下的子元素，就向上追溯到同一父元素下比较，谁的父元素的层级大，谁就在上层。子元素的 z-index 就没用了。 "},{"id":4,"href":"/frontend-learn/docs/basic/html/04_responsive/","title":"响应式","section":"HTML 和 CSS","content":" 响应式 # 移动端响应式 # 声明视窗的大小：\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\u0026quot;\u0026gt;\nviewport 声明视窗。只适用于移动端。 width=device-width 宽度等于设备宽度。 initial-scale=1 初始化比例是 1。 minimum-scale=1 最小的缩小比例是 1。 maximum-scale=1 最大的放大比例是 1。 user-scalable=no 用户不允许缩放。 对于移动端设备，以 iphone6 为例，视网膜分辨率为 750*1334，但是在 chrome 的 device toolbar 中选择 iphone6 显示的分辨率确实 375*667。这是因为视网膜分辨率指得时物理分辨率，像素点确实是有这么多，device toolbar 中的分辨率是系统分辨率，是可以自己调整的。\n使用系统分辨率，是因为现在移动端设备的分辨率很高，但是尺寸较小，例如一个 16 寸的笔记本和一个 6 寸的手机，分辨率都是 1920*1080，当把笔记本上一个16px 大小的字体放到手机上，就太小了。所以说使用系统分辨率，是放大了。\n对于不同的移动端设备如何统一设置 # 不同的移动端设备分辨率，尺寸都不同，可以先针对一种设备，以 iphone6 为例，设计好页面的样式之后，设置 content=\u0026quot;width=375,user-scalable=no\u0026quot;，禁止用户缩放，指定宽度为 iphone6 的宽度，那么不同分辨率的设备（移动端）都会自适应这个宽度。\n媒体查询 响应式的解决方案 # 响应式：根据不同屏幕的大小，显示不同的样式，从而更好的适配屏幕去显示内容。可以更好的去布局排版。\n语法：\n@media not|only mediatype and (mediafeature and|or|not mediafeature) { CSS-Code; } mediatype 媒体类型：\nall：所有设备。 print：用于打印机和打印预览。 screen：用于电脑屏幕，平板电脑，智能手机等。。 speech：应用于屏幕阅读器等发声设备。 示例：\n/* 屏幕小于 640px 时，改变 h1 的颜色*/ @media screen and (max-width: 640px) { h1 { color: #0055bb; } } /* 屏幕大于 1200px 时，改变 h1 的颜色*/ @media screen and (min-width: 1200px) { h1 { color: #264D73; } } /* 屏幕大于 640px 并且小于 1200px 时，改变 h1 的颜色*/ @media screen and (min-width: 640px) and (max-width: 1200px) { h1 { color: #66bbff; } } "},{"id":5,"href":"/frontend-learn/docs/basic/html/05_other/","title":"其他","section":"HTML 和 CSS","content":" 其他 # RGBA # RGB 是一种色彩标准，由红（Red）、绿（Green）、蓝（Blue）3 种颜色变化来得到各种颜色。而 RGBA，其实就是在 RGB 基础上增加了一个透明度 Alpha。\nrgba(R, G, B, A) R，指的是红色值（Red）；G，指的是绿色值（Green）；B，指的是蓝色值（Blue）；A，指的是透明度（Alpha）。\nR、G、B 这三个可以为整数，取值范围是 0~255 或者 0%~100%。参数 A 为透明度，取值范围为 0.0~1.0。\nRGBA 和 opacity 的区别 # RGBA 和 opacity 属性都可以设置透明度，这两种方式的区别是：\n在元素中使用了 opacity，那么其后代元素都会受其影响。 RGBA 可以为颜色单独设置透明度，不影响整个元素的透明度，也不会影响到元素的其他属性。 示例：\n/* 设置背景颜色的透明度，而不会影响整个元素 */ background-color:rgba(255,0,255,1.0); /* bg 后代元素以及文本内容都会受到影响 */ .bg { background-color:rgb(255, 0, 255); opacity:0.3; } 渐变 # 线性渐变 # 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)\n示例：\n/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 # 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。\n/* 基本的径向渐变 */ /* 默认情况下，渐变的中心点是 50% 50% 的位置 */ /* 椭圆 */ radial-gradient(red, blue); 滤镜属性 # -webkit-filter：滤镜属性。\nblur() 设置元素的模糊度，默认是 0px。 例如：-webkit-filter: blur(20px), blur() 中的值越大越模糊。 grayscale() 灰度，正常是 0%，也可以写数字。例如：-webkit-filter: grayscale(100%)。 sepia() 褐色，正常是 0% 可以写数字。例如：-webkit-filter: sepia(100%) 。 brightness() 亮度，正常亮度 100% 可以写数字，例如：-webkit-filter: brightness(100%) 。如果需要过度曝光的效果可以 brightness(500%)。 contrast() 对比度，正常是 100% 可以写数字，例如：-webkit-filter: contrast(1000%) 和 -webkit-filter: contrast(10) 是一个意思。 saturate() 饱和度，正常是 100% 可以写数字，例如：-webkit-filter: saturate(1000%)。 hue-rotate() 色相旋转，正常是 0deg 可以写数字，例如：-webkit-filter: hue-rotate(45deg)。 invert() 色相反转，底片效果，正常是 0 可以写数字，-webkit-filter: invert(100%)。 多个属性组合：-webkit-filter: blur(20px) brightness(100%)。\n滚动条属性 # overflow 属性用于在内容超出容器时，如何处理内容的显示。\n容器必须有一个指定的高度，overflow 才会生效。\noverflow 也可以分别设置 X 轴 overflow-x 和 Y 轴 overflow-y。\ndiv { overflow: hidden; /* overflow-x: hidden; overflow-y: hidden; */ } div { overflow: auto hidden; /* overflow-x: auto; overflow-y: hidden; */ } 常用的值：\nvisible：默认值，不会出现滚动条，溢出内容会直接显示在容器外部。 hidden：不会出现滚动条，溢出内容会被裁剪，超出容器的部分不可见。 scroll：显示滚动条，超出容器的内容，可以滚动滚动条来显示。 auto：在内容有溢出时才显示滚动条，没有溢出则不显示滚动条。 overlay：和 auto 差不多，不同的是 auto 显示的滚动条会在容器内占据一个位置，会导致内容发生位移。overlay 则是会覆盖在容器右侧，不会占据位置 滚动条的样式 # 主要涉及以下几个伪元素属性，-webkit 表示只对 webkit 内核浏览器有效。\n::-webkit-scrollbar：设置滚动条的整体样式，可以设置尺寸等。必须要设置宽高，否则不生效。 ::-webkit-scrollbar-button：滚动条两端的按钮（上下箭头）。不设置则不出现。 ::-webkit-scrollbar-thumb：滚动条上的滚动滑块。必须要设置，否则不会出现滑块。 ::-webkit-scrollbar-track：滚动条轨道。不设置则不出现轨道。 ::-webkit-scrollbar-track-piece：滚动条没有滑块的轨道部分。 ::-webkit-scrollbar-corner：当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。 示例：\n/* 滚动条所在容器 */ .scroll-container { margin: 10px; width: 200px; height: 250px; overflow: overlay; background-color: #fff; } /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/ .scroll-container::-webkit-scrollbar { width:16px; height:16px; background-color:#F5F5F5; } /*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; } 伪类属性 # 滚动条的样式还可以搭配一些伪类属性来进行优化：\n:horizontal：适用于任何水平方向上的滚动条。 :vertical：适用于任何垂直方向的滚动条。\n/*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; \u0026amp;:horizontal { background-color: blue; } } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; \u0026amp;:vertical { background-color: red; } } 换行属性 # 文本换行的属性：\noverflow-wrap # 当一个不能被分开的字符串太长而不能填充其 div 时，为防止其溢出，浏览器是否允许这样的单词中断换行。\nnormal：默认换行行为，换行符将出现在空格和连字符处。 anywhere：在字符串之间的任意点来进行中断，仅当在其行上显示单词会导致溢出时，浏览器才会中断该单词。 break-word：如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 word-break # 用于指定怎样在单词内进行断行。可以使用该属性在内容发生溢出的确切位置拆分单词并将其换行到下一行。\nnormal：默认的断行规则。 break-all：对于 non-CJK (CJK 指中文/日文/韩文) 的文本，可在任意字符间断行。 keep-all：即使内容溢出，浏览器也不会将分词应用于 CJK 文本。 应用 keep-all 值的效果与非 CJK 书写系统的正常效果相同。简单来说就是，像英语这种 CJK 文本不 会断行，像中文这种 Non-CJK 文本表现同 normal。 break-word：弃用。 white-space # 用来设置如何处理元素中的空白。\nnormal：默认的断行规则。 nowrap：防止文本自动换行。 pre：文本之间的空白会被浏览器保留。其行为方式类似 HTML 中的 \u0026lt;pre\u0026gt; 标签。 line-break # 用来处理如何断开带有标点符号的中文、日文或韩文文本的行。简而言之，该属性可以用来处理过长的标点符号。\ntext-overflow # 属性指定当文本溢出包含它的元素时，应该如何显示。可以设置溢出后，文本被剪切、显示省略号 (...) 或显示自定义字符串（不是所有浏览器都支持）。\nclip：剪切文本。 ellipsis：显示省略符号 ... 来代表被修剪的文本。 string：使用给定的字符串来代表被修剪的文本。 initial：设置为属性默认值。 inherit：从父元素继承该属性值。 text-overflow 需要配合以下两个属性使用：\nwhite-space: nowrap; overflow: hidden; clientHeight、offsetHeight、scrollHeight # 每个元素都具有以和元素高度、滚动、位置相关的属性。这些属性通常用于计算元素的实际高度，尤其在涉及到滚动的情况下。\nclientWidth、clientHeight、clientLeft、clientTop # clientWidth：只读属性，表示元素的内部宽度，单位 px，包括 padding 但不包括 border margin 和垂直滚动条的宽度。对于 inline 的元素这个属性一直是 0。 clientHeight：只读属性，表示元素内容的高度，单位 px，包括 padding 但不包括 border margin 和水平滚动条的高度。对于 inline 的元素这个属性一直是 0。 clientLeft：只读属性，表示元素左边框的宽度，单位 px，不包括左外边距和左内边距。 clientTop：只读属性，表示元素顶部边框的宽度，单位 px，不包括顶部外边距或内边距。\noffsetWidth、offsetHeight、offsetLeft、offsetTop # offsetWidth：只读属性，表示元素的布局宽度，单位 px，包括 padding border margin 和垂直滚动条的宽度。 offsetHeight：只读属性，表示元素内容的高度，单位 px，包括 padding border margin 和水平滚动条的高度。 offsetLeft：只读属性，表示元素左上角相对于 offsetParent 左边界的偏移，单位 px，如果元素被隐藏则是 0。 offsetTop：只读属性，表示元素相对于 offsetParent 元素的顶部内边距的距离，单位 px，如果元素被隐藏则是 0。\nscrollWidth、scrollHeight、scrollLeft、scrollTop # scrollWidth：只读属性，表示元素内容的总宽度，包括由于溢出而被隐藏的部分。没有水平滚动条的情况下，scrollWidth 值与元素视图填充所有内容所需要的最小值 clientWidth 相同。 scrollHeight：只读属性，表示元素内容的总高度，包括由于溢出而被隐藏的部分。没有垂直滚动条的情况下，scrollHeight 的值与元素视图填充所有内容所需要的最小值 clientHeight 相同。 scrollLeft：可读可写，代表在有滚动条时，滚动条向右（向左）滚动的距离也就是元素左边（右边）被遮住部分的宽度。在没有滚动条时 scrollLeft = 0。 scrollTop：可读可写，代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时 scrollTop = 0。\n应用 # 判断是否有垂直滚动条 # 如果 scrollHeight = clientHeight 则表示没有垂直滚动条。\n判断是否有水平滚动条 # 如果 scrollWidth = clientWidth 则表示没有水平滚动条。\n判断滚动区域是否滚动到底 # scrollTop + clientHeight \u0026gt;= scrollHeigh，scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的，因此确定滚动区域是否滚动到底的唯一方法是查看滚动量是否足够接近某个阈值：\nMath.abs(element.scrollHeight - element.clientHeight - element.scrollTop) \u0026lt; 1 tabindex # tabindex 全局属性，表示元素是否可以被聚焦，以及是否能用 Tab 键选中。MDN Web Docs (tabindex)。\n支持聚焦的元素 # \u0026lt;button\u0026gt; 有 herf 属性的 \u0026lt;a\u0026gt; 有 herf 属性的 \u0026lt;link\u0026gt; type 不是 hidden 的 \u0026lt;input\u0026gt; \u0026lt;select\u0026gt; \u0026lt;textarea\u0026gt; 默认情况下，在使用 Tab 键聚焦元素时，聚焦顺序等于元素在源当前 DOM 中的先后顺序。\ntabindex 的值 # tabindex=负值 (例如 tabindex=\u0026quot;-1\u0026quot;)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用 JS 做页面小组件内部键盘导航的时候非常有用。 tabindex=\u0026quot;0\u0026quot;，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的 DOM 结构来决定的。 tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序是 tabindex 的数值越大顺序越靠后。如果多个元素拥有相同的 tabindex，它们的相对顺序按照他们在当前 DOM 中的先后顺序决定。tabindex=0 的顺序会被放到最后。 例如：1,1,2,2,2,2,3,4,5,0,0,0 ...。tabindex 是非法值、或者没有 tabindex 值的元素，也是放到最后。 div 默认情况下是不会被聚焦的，就可以添加属性 tabindex，让 div 元素可以被聚焦。如果在 div 上设置了 tabindex 属性，它的子元素内容不能使用箭头键来滚动，除非在内容上也设置 tabindex。\n"}]