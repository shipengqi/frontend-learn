[{"id":0,"href":"/frontend-learn/docs/basic/html/","title":"HTML 和 CSS","section":"前端基础","content":" HTML 和 CSS # HTML 超文本标记语言（HyperText Markup Language）：用来定义网页内容的标记语言。\n超文本：意思就是不止文本，还包括图片、音频、视频等。 标记：标记语言，就是用标记符号（HTML 标签）来标记文本，计算机就可以识别这些标记符号，从而对文本进行处理。 CSS 层叠样式表：用来定义 HTML 的显示样式。\nJavaScript： 脚本语言，用来定义与用户的交互。\n"},{"id":1,"href":"/frontend-learn/docs/basic/html/01_tags/","title":"HTML 标签","section":"HTML 和 CSS","content":" HTML 标签 # HTML 页面的基本结构 # 一个 HTML 页面的基本结构：\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Demo\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;!-- 设置不同尺寸的 favicon，浏览器会根据分辨率自动加载合适的 favicon --\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon-16x16.ico\u0026#34; sizes=\u0026#34;16x16\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon-32x32.ico\u0026#34; sizes=\u0026#34;32x32\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon-48x48.ico\u0026#34; sizes=\u0026#34;48x48\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/x-icon\u0026#34; href=\u0026#34;favicon.ico\u0026#34;\u0026gt; \u0026lt;!-- Fallback for older browsers --\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;apple-touch-icon.png\u0026#34;\u0026gt; \u0026lt;!-- 针对苹果设备，苹果设备保存网页到桌面的图标 --\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;site.webmanifest\u0026#34;\u0026gt; \u0026lt;!-- For PWA --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!doctype html\u0026gt;：声明文档类型是 html5。 \u0026lt;html\u0026gt;：根标签，一般只包含 head 和 body 标签。 \u0026lt;head\u0026gt;：标签内容一般不会显示在页面上，用于描述页面的信息。 \u0026lt;body\u0026gt;：页面的主要内容。 \u0026lt;title\u0026gt;：页面标题。 \u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;..., .., ..\u0026quot;\u0026gt;：针对搜索引擎的页面关键字。 \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;...\u0026quot;\u0026gt;：针对搜索引擎的页面描述。 \u0026lt;style\u0026gt;：书写 css 样式。 \u0026lt;link\u0026gt;：一般用来加载 css 文件或者 favicon。 \u0026lt;script\u0026gt;：用来加载 javascript 文件。\u0026lt;script\u0026gt; 一般会放在 \u0026lt;body\u0026gt; 标签里的最下面，原因： 当 javascript 文件比较大的时候，会阻塞页面中的其他元素的加载，导致整个页面加载缓慢。 另外 javascript 可能会处理页面中元素，如果 javascript 先加载，但是元素还没有生成，会导致报错。 常用标签 # 常用的标签，后期都是可以使用 CSS 去自定义样式。那为什么要定义这么多标签，而不是使用一个标签再配合 CSS 实现样式，这是因为一个重要的概念，语义化。\n语义化的好处：\n可读性更好。 对搜索引擎友好。 文本类标签 # 文本结构 # h1-h6 标题，块级标签，占据一行 p 段落，块级标签，占据一行 文本修饰 # em: 强调 strong: 加粗 u: 下划线 sup: 上标 sub: 下标 通用 # span 一个通用标签，可以用它来替换所有的文本标签。 列表 # ul 无序列表 ol 有序列表 其他 # br 换行，单标签 hr 横线，单标签 结构化标签 # 结构化标签没有默认的样式。\n常规结构 # header: 页面头部 nav: 导航 main: 主要区域 footer: 页脚 文章结构 # article: 文档内容 section: 文档中的通用区块，通常包含一组相关的内容 aside: 文档中附加区块，通常包含侧边栏、广告等 通用 # div：（Division）块级容器标签 媒体资源标签 # img：图片 svg：矢量图 video：视频 audio：音频 canvas：画布 表单标签 # form 表单标签， action 属性是提交的页面（例如 https://www.baidu.com/s ） method 提交的方法，get 提交的数据会在链接上显示，一般用来搜索，post 提交的数据在 body 里面. input、textarea 输入或选择 select：下拉列表 option：选项 button：按钮 label：标签 链接 # a 链接，\u0026lt;a href=\u0026quot;#element-id\u0026quot;\u0026gt; 可以进行页面内位置的跳转。 实体符号 # HTML 中的预留字符必须被替换为实体符号才可以使用。例如在 HTML 中不能使用 \u0026lt; \u0026gt;，浏览器会误认为它们是标签。\n如果希望正确地显示预留字符，必须在 HTML 源代码中使用实体符号。\nMDN Web Docs (Entity)。\n"},{"id":2,"href":"/frontend-learn/docs/basic/html/02_css/","title":"CSS 常用属性","section":"HTML 和 CSS","content":" CSS 常用属性 # 容器属性 # 盒子模型属性 # 一个元素的组成：内容 + 内边距 + 边框 + 外边距\nwidth 和 height 定义宽高。 padding 内边距，定义内容和边框的间距。 border 定义边框。 margin 外边距，定义边框和其他元素的间距。 box-sizing：盒子模型默认是 box-sizing: content-box。\nborder-box：不会因为 border、padding 而改变元素的大小，会改变内容的大小。例如定义了元素的宽高都为 300px，那么 内容 + 内边距 + 边框 就是 300px。 content-box：默认值，会因为 border 和 padding 而改变大小，但是不会改变内容的大小。例如定义了元素的宽高都为 300px，内容的宽高就是 300px，不包含 内边距 和 边框。 元素类型 (块级/行级/行块) # div 默认就是块级元素，浏览器会自动给 div 添加 display: block 的属性 （user agent stylesheet 就是浏览器添加的属性）。\n块级元素（div p）：默认会占据一整行，可以定义宽高。包含 display: block 的属性。定义宽高以后仍然会占据一整行，元素的宽度不够一整行，那么剩下的会是外边距来占满一整行。 行内元素（span）：会根据内容自身的大小来占据大小，没有宽高。也就是说对行内元素设置宽高是无效的。另外包含 display: inline 的属性也是内级元素。也可以通过添加 display: block 的属性来变成块级元素。 行块元素：不会占据一整行，但是可以有宽高，包含 display: inline-block 属性的元素就是行块元素。 一个元素一旦成为了弹性布局或者网格布局的直接子元素，那么该元素之前的模式会失效，例如：\n\u0026lt;div style=\u0026#34;display: flex\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;height: 100px;width: 100px\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 上面的 span 尽管是一个行内元素，但是可以设置宽高。\n背景 # background：复合属性，background: {color} {image} {repeat} {position} {size}。 background-clip：背景的绘制区域。 border-box：默认值，边框区域 padding-box：内边距区域 content-box：内容区域 background-color：背景颜色。设置单色背景时有效。对图片背景，渐变背景无效。 background-image：背景图片。 background-repeat：背景重复，对图片背景有效。 no-repeat：不重复 repeat：重复 repeat-x：只重复水平方向 repeat-y：只重复垂直方向 background-origin：背景的绘制起点，对图片背景有效。 border-box：从边框区域开始绘制 padding-box：从内边距区域开始绘制 content-box：从内容区域开始绘制 background-position：绘制背景图片的位置。left right bottom 或者 x y 坐标。如果不设置这个属性，那么绘制背景会从背景图片的左上角开始绘制。设置该属性，例如 background-position: 10px 10px，会根据 background-origin 的值，再偏移 10px 10px 位置开始绘制。left 就是从背景图片左侧居中的位置开始绘制。right bottom 就是右下角位置开始绘制。 background-size：背景大小。背景图片的大小可以大于或者小于绘制背景的区域，这个时候就可以设置该值俩调整背景图片的显示。 cover：横向或者纵向等比例缩放背景图片，完整的覆盖整个背景绘制区域。多余的部分就不显示了。 contain：横向或者纵向等比例缩放背景图片去放到背景绘制区域。 {width} {height}：背景大小。 background-attachment：背景是否固定，scroll 滚动，fixed 固定。 多层背景 # 背景是可以设置多层的：background: linear-gradient(yellow, orange), url(1.jpg), url(2.jpg), red。\n上面的示例就设置成了一个四层背景。越靠前的背景会覆盖后面的背景。单色背景的优先级是最低的（跟顺序无关），并且只能设置一个。\n盒子阴影 # box-shadow：{x 偏移值} {y 偏移值} {模糊度} {扩散} {颜色} {内阴影}，box-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。\n字体属性 # 声明使用的字体：font-family，取决于系统是否安装有对应的字体，例如 微软雅黑，黑体等。 字体样式：font-style，normal 默认的样式。 italic 斜体 字体大小，font-size。 字体颜色，color。 字体的粗细，font-weight，值可以是 100-900 或者 bold/bolder/lighter/normal，取决于系统是否安装有对应的字体。 字体排布，text-algin 值可以是 center/left/right。 字体行高，line-height，设置一行文字的高度。 字体修饰：text-decoration underline 下划 overline 上划线 line-through 删除线 字体阴影：text-shadow，text-shadow: {x 偏移值} {y 偏移值} {模糊度} {颜色}，text-shadow: 10px 0 0 red,10px 0 0 red; 多组值，会有一个渐变的效果。可以配合动画实现闪光的效果。 所有的字体属性都会继承父元素的字体属性，所以在 html 元素上设置字体属性，会使所有的元素都会默认继承 html 上的字体属性。\n字体设置 # font-family 设置的字体可以分为两类\n系统已经安装的字体。 远程获取的字体。 font-family 可以设置多个值，用逗号隔开。例如：font-family: \u0026quot;微软雅黑\u0026quot;, \u0026quot;黑体\u0026quot;, \u0026quot;宋体\u0026quot;, \u0026quot;楷体\u0026quot;, \u0026quot;Arial\u0026quot;;。这里会先去匹配第一个字体，如果没有，就会去匹配第二个字体，以此类推。全都没有就会使用默认的字体。一般情况下，会把比较常见的，大部分系统都有的字体放到后面，起到一个保底的作用。\n对于不同的系统，可能默认的字体都不太一样，如果想要简单使用系统的默认字体，就可以使用关键字 system-ui，font-family: system-ui。前提是浏览器支持。\n对于远程获取的字体，尽量避免使用，尤其时中文字体，体积较大，会导致网站加载较慢。\n引入在线字体：\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; \u0026lt;link href=\u0026#34;https://fonts.googleapis.com.css2?family=Matemasie\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;!-- 注意要放在自己的 css 文件前面 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- 或者 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; @import url(\u0026#39;https://fonts.googleapis.com.css2?family=Matemasie\u0026amp;display=swap\u0026#39;) \u0026lt;/style\u0026gt; \u0026lt;!-- 注意要放在自己的 css 文件前面 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; 对于在线字体最好的方式就是先下载下来，放到自己的项目中再引用。参考下面的字体图标。\n@font-face { /* font-display */ /* 常用的可选值 block 字体文件加载时，显示空白 swap 字体文件加载时，显示备用字体，加载完成后切换 fallback 字体文件加载时，开始的很短的一段时间比如 100ms 会显示空白，如果短时间加载完成就切换，如果加载时间过长就不会再切换 */ } 字体图标 # 字体图标是用特殊的字体来显示图标，代替图片。\n字体图标的优势：\n可以使用字体属性，随时调整大小和颜色。 图标调整大小，不会因为过大而失真，因为字体是矢量图。 字体文件 size 普遍小于图片，可以降低服务器的带宽压力。 使用字体图标的方式：\n首先需要在 iconfont 下载字体图标。\nUnicode # 这个是最原始的方式，兼容性最好，支持 IE6+，以及所有现代浏览器。支持字体属性，但是由于是字体，所以不支持多色。只能使用单色图标。\n注意：新版 iconfont 支持两种方式引用多色图标：SVG symbol 引用方式和彩色字体图标模式。（使用彩色字体图标需要在「编辑项目」中开启「彩色」选项后并重新生成。）\n使用步骤如下：\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 声明字体，src 是字体文件的路径，多个文件是针对不同的浏览器 */ @font-face { font-family: \u0026#39;iconfont\u0026#39;; src: url(\u0026#39;iconfont.woff2?t=1723520893571\u0026#39;) format(\u0026#39;woff2\u0026#39;), url(\u0026#39;iconfont.woff?t=1723520893571\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;iconfont.ttf?t=1723520893571\u0026#39;) format(\u0026#39;truetype\u0026#39;); /* font-display */ /* 可选值 block 字体文件加载时，显示空白 swap 字体文件加载时，显示备用字体，加载完成后切换 fallback 字体文件加载时，开始的很短的一段时间比如 100ms 会显示空白，如果短时间加载完成就切换，如果加载时间过长就不会再切换 */ } /* 定义使用 iconfont 的样式 */ .iconfont { font-family: \u0026#34;iconfont\u0026#34; !important; /* 使用 iconfont 字体 */ font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } \u0026lt;/style\u0026gt; \u0026lt;!-- 挑选相应图标并获取字体编码（例如 \u0026amp;#x33;），应用于页面 --\u0026gt; \u0026lt;span class=\u0026#34;iconfont\u0026#34;\u0026gt;\u0026amp;#x33;\u0026lt;/span\u0026gt; Font Class # 主流方式。Font Class 是 Unicode 使用方式的一种变种，兼容性良好，兼容 IE8+，和所有现代浏览器（IE8 以上才支持伪元素）。\nFont Class 解决了 Unicode 书写不直观，语意不明确的问题。可以很容易分辨这个 icon 是什么。因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\n使用步骤如下：\n\u0026lt;!-- 引入项目下面生成的 fontclass 代码 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./iconfont.css\u0026#34;\u0026gt; \u0026lt;!-- 挑选相应图标并获取类名，应用于页面 --\u0026gt; \u0026lt;span class=\u0026#34;iconfont icon-xxx\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Font Class 就是使用了 :before 伪元素来实现的。\n例如：\n.icon-mtiIcon-yingyongshebei-fangbaocha:before { content: \u0026#34;\\e713\u0026#34;; } Symbol # 未来的主流方式。这种其实是做了一个 svg 的集合。支持多色图标，支持字体属性，但是兼容性较差。浏览器渲染 svg 的性能一般。\n常用单位 # 绝对单位 # px：像素单位。 pt、in：打印单位。 相对单位 # %：百分比。占父元素宽度或高度的百分比。 em：相对于父元素的字体大小。不建议使用。2em 就是父元素 font-size 的两倍。1em 就是 1 倍。 rem：相对于根元素（html 标签）的字体大小。2rem 就是根元素 font-size 的两倍。不仅可以用来设置字体大小，也可以用设置宽高。最终都会换算成 px。 vw：viewport width 视口单位，视口指的是浏览器的显示区域。视口宽度。20vw 就是视口宽度的 20%。 vh：viewport height 视口单位，视口高度。1vh 就等于视口高度的 1%。 vmin、vmax：vmin 是选择视口宽度或者高度中较小的那个。vmax 是选择视口宽度或者高度中较大的那个。例如 30vmax 当浏览器显示区域的高度大于宽度时，那就表示视口高度的 30%。不常用。 svh lvh dvh svw lvw dvw：移动端单位。 颜色 # 关键字 # 常见的颜色关键字：red、green、blue、yellow 等等。\n十六进制 # 十六进制颜色是由 6 个十六进制字符组成的。例如 #FF0000 表示红色。如果两个字符相同，那么可以简写为一个字符。例如 #F00 表示红色。\n其实十六进制颜色后面还可以加两位表示透明度。例如 #FF000080 表示红色，透明度为 0.5。\nRGB/RGBA # RGB 是一种色彩标准，由红（Red）、绿（Green）、蓝（Blue）3 种颜色变化来得到各种颜色。而 RGBA，其实就是在 RGB 基础上增加了一个透明度 Alpha。\nrgb(R, G, B) rgba(R, G, B, A) R，指的是红色值（Red）；G，指的是绿色值（Green）；B，指的是蓝色值（Blue）；A，指的是透明度（Alpha）。\nR、G、B 这三个可以为整数，取值范围是 0~255 或者 0%~100%。参数 A 为透明度，取值范围为 0.0~1.0。\nHSL/HSLA # HSL 是一种色彩标准，由色相（Hue）、饱和度（Saturation）、亮度（Lightness）3 种颜色变化来得到各种颜色。A 为透明度，取值范围为 0.0~1.0。\nhsl(H, S, L) hsla(H, S, L, A) 颜色的透明度和 opacity 的区别 # 十六进制颜色，RGBA，HSLA，opacity 属性都可以设置透明度。颜色透明度和 opacity 的区别是：\n在元素中使用了 opacity，那么其后代元素都会受其影响。 RGBA 等颜色透明度可以为颜色单独设置透明度，不影响整个元素的透明度，也不会影响到元素的其他属性。 示例：\n/* 设置背景颜色的透明度，而不会影响整个元素 */ background-color:rgba(255,0,255,1.0); /* bg 后代元素以及文本内容都会受到影响 */ .bg { background-color:rgb(255, 0, 255); opacity:0.3; } CSS 值的类型 # CSS 值的类型可以分为三类：\n特定关键字：例如颜色关键字，例如 red、green、blue 等。 自定义值：例如 100px、200px 等。 全局值：例如 inherit、initial、unset 等。 inherit：继承父元素的属性。继承可以分为默认继承（指的是子元素没有设置对应属性，就会继承父元素的属性，大部分属性都不会默认继承，默认继承的主要是文字属性）和主动继承。 initial：将元素的属性重置为默认值。 unset：会根据属性是不是可继承的来决定应用 inherit 还是 initial。 变量 # 声明变量，变量名前加 --，变量名大小写敏感：\nbody { --foo: #7F583F; --bar: #F7EFD2; } 上面的示例声明了两个变量：--foo 和 --bar。\n用 -- 表示变量是因为 $ 被 Sass 用掉了，@ 被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用 -- 了。\nvar 函数 # var() 函数用于读取变量。\na { color: var(--foo); text-decoration-color: var(--bar); } var() 函数使用第二个参数，表示变量的默认值（例如 color: var(--foo, #7F583F);）。如果该变量不存在，就会使用这个默认值。\n数值与单位直接写在一起，是无效的：\n.foo { --gap: 20; /* 无效 */ margin-top: var(--gap)px; } /* 必须使用calc()函数 */ .foo { --gap: 20; margin-top: calc(var(--gap) * 1px); } 作用域 # 同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的\u0026quot;层叠\u0026quot;（cascade）规则是一致的。\n\u0026lt;style\u0026gt; :root { --color: blue; } div { --color: green; } #alert { --color: red; } * { color: var(--color); } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;蓝色\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;绿色\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;alert\u0026#34;\u0026gt;红色\u0026lt;/div\u0026gt; 变量的作用域就是它所在的选择器的有效范围。\nbody { --foo: #7F583F; } .content { --bar: #F7EFD2; } 变量 --foo 的作用域是 body 选择器的生效范围，--bar 的作用域是 .content 选择器的生效范围。\n全局的变量通常放在根元素 :root 里面：\n:root { --main-color: #06c; } "},{"id":3,"href":"/frontend-learn/docs/basic/html/03_layout/","title":"布局与定位","section":"HTML 和 CSS","content":" 布局与定位 # 浮动布局 # 浮动布局的好处：\n可以让元素向左或者向右靠拢 可以解决一些边距问题 可以实现文字包围图片的样式 float: left/right; 会让元素脱离文档流。\n元素之间的多个空白，会合并成一个空格。如果不处理会出现一些莫名其妙的间距。用浮动就可以解决这个问题。元素脱离了文档流，空白也就默认被忽略了。 并且会紧紧靠近父元素的边缘，或者同样是浮动元素的边缘。\n例如下面的 html，三个 \u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 之间都有换行和空格，html 会将多个空白空格合并为一个空格。就会造成页面的元素之间看起来有间距， 其实就是一个空格。\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 如果不想有空格，可以像下面这样，把换行和空格去掉：\n\u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上面的方式，不好看，可以使用浮动解决：\n.child { float: left } 第一个子元素 \u0026lt;div class=\u0026quot;child\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 就会去找父元素的左边边缘，第二个第三个也一样，但是第二个第三个由于中间有浮动元素，就会选择靠近浮动元素的边缘。\n清除浮动 # 浮动会导致父元素的高度塌陷。\n比如 div 块容器会占一整行，如果该元素里面包含有浮动元素，会导致该元素的高度没有了。\n因为浮动元素脱离了文档流，父元素会认为没有子元素，高度也就没有了。\n解决方式：\n设置父元素的高度（前提是父元素的高度是已知的）。 父元素的高度未知的情况下，可以通过清除浮动的方式，原理就是让父元素重新计算元素的高度。 在父元素最后添加一个子元素 div，并给子元素添加属性 clear: both;，缺点是会多一个空的 div。 终极方案：原理与上个方法一样，通过伪元素来清除浮动。 伪元素来清除浮动：\n.parent { } .parent:after{ content: \u0026#34;\u0026#34;; display: block; clear: both; } 上面的示例中给父元素的类 parant 添加了一个 :after 伪元素。\n弹性布局 # 弹性布局可以更方便的布局，但是对浏览器要求较高。\n概念：\n弹性容器：设置了 display: flex; 的元素即为弹性容器。 弹性子元素（项目）：弹性容器里的直接子元素。 display: flex：如果一个元素的设置了这个属性（弹性容器），那么他的直接子元素（孙子元素就不是弹性布局），就会按着弹性布局的方式来布局。\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 如果 parent 不是弹性布局，那么三个 child 都是块元素，每个元素会占据一整行。但是 parent 添加了 display: flex; 属性以后，三个子元素会在一行并排显示，不会有间距。\n直接子元素是弹性布局，但是parent 元素本身还是块级布局。\n弹性主轴和侧轴 # 弹性布局有一个主轴和一个侧轴：\n主轴：默认是水平向右，可以修改为水平向左或竖直向上，竖直向下。 侧轴（交叉轴）：默认是竖直向下，可以修改为竖直向上或水平向左，水平向右， 弹性布局的子元素默认是在主轴上一行或者一竖，不会换行，默认情况下（flex-wrap: nowrap）如果一行子元素的宽度或者高度超过了父元素，所有的子元素就会等比例缩小。\n设置主轴的方向：\nflex-derection: row：默认是 row。 row：水平向右。 row-reverse：水平向左。 column：竖直向下。 column-reverse：竖直向上。 设置主轴的排布：\njustify-content: flex-start：默认是 flex-start。 flex-start：靠近主轴的起点。 flex-end：靠近主轴的终点。 center：主轴居中。 space-between：平均分布，和主轴的起点和终点没有间距。 space-around：平均分布，和主轴的起点和终点有间距，两边的间距是中间的一半。 space-evenly：平均分布，间距一致。 弹性布局，设置水平居中只需要 justify-content:center 就可以实现，如果不是弹性布局，可以用下面的方式：\ndisplay: block; /* 设置为块级元素 */ margin: 0 auto; /* auto 设置水平居中，必须是块元素 */ 设置侧轴的排布：\nalign-items: stretch：默认是 stretch。 stretch：拉伸，如果子元素没有设置高度或宽度，那么子元素会被拉伸到和父元素一样的高度或宽度。 flex-start：靠近侧轴的起点。 flex-end：靠近侧轴的终点。 center：侧轴居中。单行的侧轴没有平均分布。 换行：\nflex-wrap: nowrap：默认是 nowrap。 nowrap：不换行。 wrap：换行，如果侧轴排布是 stretch，换行以后是两行，那么两行会被拉伸，各占一半。 多行存在的时候，侧轴分布：\nalign-content: flex-start： flex-start：多行都向侧轴的起点靠拢。 flex-end：多行都向侧轴的终点靠拢。 center：多行居中。 space-around：平均分布，和侧轴的起点和终点有间距，两边的间距是中间的一半。 space-between：平均分布，和侧轴的起点和终点没有间距。 space-evenly：平均分布，间距一致。 弹性子元素会存在多个，如果要单独设置一个子元素侧轴的分布，可以给弹性子元素添加属性：\nalign-self: flex-start： flex-start：靠近侧轴的起点。 flex-end：靠近侧轴的终点。 center：侧轴居中。 主轴是不能单独设置一个子元素的分布的。\n弹性子元素的排序 # 如果要设置弹性子元素的排序，可以给每个子元素添加属性：\norder: {num} 子元素会沿主轴方向从小到大排序。 示例：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; } .child { width: 200px; height: 200px; } .c1 { order: 3; background: skyblue; } .c2 { order: 2; background: green; } .c3 { order: 1; background: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child c1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 弹性子元素剩余空间配置 # 给子元素添加属性 flex: {num}，占据剩余份额的份数。flex: 1 就表示占据剩余空间的 1 份。\n示例：\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .parent { display: flex; width: 600px; height: 600px; background: gray; } .child { width: 100px; height: 100px; } /* 剩余空间被分为 3 份，c1 占 1/3，c2 占 2/3 */ .c1 { flex: 1; background: skyblue; } .c2 { flex: 2; background: green; } .c3 { order: 1; background: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child c1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child c3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 上面的示例，每个子元素的宽度为 100px，那么剩余空间就是 300px。c1 会占据剩余空间的 100px，c2 占 200px。\nflex-grow、flex-shrink、flex-basis # flex 是一个复合属性（flex: {flex-grow} {flex-shrink} {flex-basiss}），它有三个属性：flex-grow、flex-shrink、flex-basis ，分别是用来设置弹性子元素的拉伸、收缩和基准值。\nflex-grow：默认值 0。和 flex: {num} 的作用是一样的。 flex-shrink：默认值 1。和 flex: {num} 的作用是相反的，当子元素的大小超过了主轴或者侧轴，那么设置了 flex-shrink 的子元素就会自动收缩。如果设置了换行，那么这个属性就没有用了。 flex-basis：默认值 auto。设置主轴方向的元素的尺寸。如果主轴是横向的，那设置的就是宽度，如果是纵向的，那设置的就是高度。 inline-flex # display: inline-flex 和 display: flex 的唯一区别就是会把元素本身变为行内元素，元素内部的子元素仍然是弹性子元素。\n网格布局 # 弹性布局是基于轴线的布局，可以看作是一维布局，网格布局将容器划分成行和列，产生单元格，可以看作是二维布局。\n概念：\n网格容器：设置了 display: grid; 的元素即为网格容器。 项目：网格容器里的直接子元素。 grid-template-columns：设置网格容器的列宽和列的数量，例如 grid-template-columns: 100px 200px 100px; 表示网格容器有三列，列宽分别是 100px、200px、100px。 grid-template-rows：设置网格容器的行高和行的数量，例如 grid-template-rows: 100px 200px; 表示网格容器有两行，行高分别是 100px、200px。 网格布局，是看不到网格线的，开发过程中，可以在浏览器中查看元素，选择 grid 标签，如下图：\n划分网格 # fr、auto、minmax # fr、auto、minmax 是网格布局的三个关键字，用来设置网格容器的列宽和行高。都是具有一定收缩性和扩展性的。\n优先级：minmax() \u0026gt; fr \u0026gt; auto。\nfr 和 auto 最小值都是 0，过多内部存在子元素，那么最小值就是子元素的宽或者高。\nfr # fr：单位（fraction），有点类似于弹性布局的 flex-grow，fr 的作用也是把整个容器内剩余的空间做均分，然后按照 fr 来分配。例如 grid-template-columns: 60px 1fr; 表示网格容器有两列，第一列的宽度是 60px，第二列的宽度是剩余的宽度。所有列都用 fr 来表示，例如 grid-template-columns: 1fr 1fr; 表示网格容器有两列，宽度各占一半。fr 可以快速的把整个网格空间利用起来，例如实现一个九宫格 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr;\nauto # auto 是用来设置宽高的默认值，但是在网格容器中，有一些特别的用处。\n\u0026lt;head\u0026gt; \u0026lt;style\u0026gt; .child3 { height: 30px; width: 100px; background-color: salmon; } .grid-container { height: 600px; width: 600px; background-color: black; display: grid; grid-template-columns: 60px 60px auto; grid-template-rows: 100px 200px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;grid-container\u0026#34;\u0026gt; \u0026lt;div\u0026gt;111\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;222\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child3\u0026#34;\u0026gt;333\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 上面的示例，效果如下图：\nchild3 元素的宽度是 100px，但是这个元素所在的单元格的宽度是 auto，auto 忽略了子元素的宽度，占满了剩余空间。但是如果新增一例 1fr：\n.grid-container { /* ... */ grid-template-columns: 60px 60px auto 1fr; grid-template-rows: 100px 200px; } auto 会自动收缩，正好等于子元素的宽度，如下图：\n如果有多个 auto，例如 grid-template-columns: 60px 60px auto auto; 包含了两列 auto，这两列会把剩余空间平分，如下图：\n但是一旦有了一列 fr，例如 grid-template-columns: 60px 60px auto auto 1fr;，所有的 auto 都会自动收缩。\nminmax() # minmax({min}, {max})：用来设置一个范围，例如 grid-template-columns: minmax(100px, 200px); 表示网格容器的第一列的宽度在 100px 到 200px 之间。\n注意 min 值不要设置的比 max 大，例如 minmax(200px, 100px) 或者 minmax(1fr, 100px)。\nminmax() 的优先级是高于 auto 的，它会在最大的范围中去压缩 auto 的空间。\nrepeat # repeat({重复次数}, {尺寸})：用来设置重复的列或者行，例如 grid-template-columns: repeat(3, 100px); 表示网格容器有三列，列宽都是 100px。\nauto-fill # auto-fill：会按照尺寸去尽可能的生成最多的列或者行，例如：\n.grid-container { height: 600px; width: 650px; background-color: black; display: grid; grid-template-columns: repeat(auto-fill, 100px); grid-template-rows: 100px 200px; } 上面的示例，repeat(auto-fill, 100px) 根据当前容器的剩余空间 650px 最多就只能生成 6 列。\nauto-fit # auto-fit：也是按照尺寸去尽可能的生成最多的列或者行，但是和 auto-fill 不同的是，它最终生成的列，如果没有元素，那么它会收缩为 0。\n如果 auto-fit 的尺寸设置为 minmax，例如 grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));，那么会生成的列是会把剩余空间均分的。 但如果 auto-fill 的尺寸设置为 minmax，例如 grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));，那么会按照 min 也就是 100px 去生成列。\ngap # gap：设置网格容器的行间距和列间距。\n统一设置间距，例如 grid-gap: 10px; 表示网格容器的行间距和列间距都是 10px。 分别设置行和列的间距，例如 grid-gap: 10px 20px; 表示网格容器的行间距是 10px，列间距是 20px。也可以分开设置，例如 row-gap: 10px; column-gap: 20px;： row-gap：行间距。 column-gap：列间距。 网格排布 # 网格布局的排列顺序默认是先行后列，例如下面的一个九宫格的示例：\n\u0026lt;style\u0026gt; .grid-container { height: 300px; width: 600px; background-color: black; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 16px; font-size: 4rem; color: white; } .child { padding: 8px; } .child1 { background-color: #0055bb; } .child2 { background-color: #66bbff; } .child3 { background-color: #8440f1; } .child4 { background-color: #b88dff; } .child5 { background-color: #ff6666; } .child6 { background-color: #ffdd66; } .child7 { background-color: green; } .child8 { background-color: greenyellow; } .child9 { background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;grid-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;child child1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child5\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child7\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child8\u0026#34;\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;child child9\u0026#34;\u0026gt;9\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 显示效果：\n元素先从第一行开始，从左到右排列。\n使用 grid-auto-flow: column 设置为先列后行。\ngrid-auto-flow 属性除了设置成 row 和 column，还可以设成 row dense 和 column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。\n例如 row dense，表示\u0026quot;先行后列\u0026quot;，并且尽可能紧密填满，尽量不出现空格。\n网格元素的尺寸 # 网格中的子元素如果没有设置尺寸，那么默认会拉伸到所在网格的大小。\n网格中子元素的大小和网格的大小是没有关系的：\n如果网格的宽或者高是一个可变的值，例如 1fr，子元素的宽高大于 1fr 的时候会把网格撑开。 如果网格的宽或者高是一个固定的值，例如 200px，子元素的宽高大于 200px 的时候，子元素会忽略网格的大小。 order # 网格子元素和弹性子元素一样也可以设置 order 属性来排序。网格子元素的 order 属性默认是 0.\n按网格线设置元素位置 # 网格边缘上的数字就是网格线的编号。列和行的网格线都是从 1 开始编号。下图中的负数，是反向编号，方便从后开始查找网格线。\n每个网格都是由四根网格线包围的，例如上图中的元素 1，它是有行的 1 号、2 号，列的 1 号、2 号网格线包围的。可以通过指定元素上下左右的 4 根网格线来设置元素在网格中的位置。\n例如上图，如果要把 7 号元素放到 2 号元素的位置：\n.child7 { background-color: green; grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; } 也可以占据多格，例如：\n.child7 { background-color: green; grid-column-start: 2; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3; } grid-column-start: 2; 和 grid-column-end: 4; 可以简写成 grid-column: 2 / 4; grid-row-start: 1; 和 grid-row-end: 3; 可以简写成 grid-row: 1 / 3; 自定义网格线名称 # 网格线虽然后编号，但是不容易记住，可以在定义列和行时自定义网格的名称。\ngrid-template-columns: [line1 aaa] 100px [line2] 200px [line3] 300px [line4]， 第一列 100px 左边的网格线（编号 1）命名 line1 和 aaa。 第二列 200px 左边的网格线（编号 2）命名为 line2。 第三列 300px 左边的网格线（编号 3）命名为 line3，右边的网格线（编号 4）命名为 line4。 grid-template-rows: [line5] 100px [line6] 100px 100px 网格线可以定义多个名字，用空格分隔，如 [line1 aaa]。 不需要定义所有的网格线名称，只定义需要用到的即可。如 [line5] 100px [line6] 100px 100px。 定义了名称的网格线，编号仍然是可以使用的。 grid-template-areas # 网格布局是可以预先将网格划分区域的，一个区域由一个或多个单元格组成。grid-template-areas 属性用于定义区域。\n.grid-container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: \u0026#39;a a b\u0026#39; \u0026#39;c c b\u0026#39; \u0026#39;d e f\u0026#39;; } 面代码先划分出一个九宫格，然后定义了每个单元格所属的区域。\n如果某些单元格不需要利用，则使用 . 表示：\n.grid-container { grid-template-areas: \u0026#39;a a b\u0026#39; \u0026#39;c c b\u0026#39; \u0026#39;. . .\u0026#39;; } .child1 { background-color: #0055bb; grid-area: a; } .child2 { background-color: #66bbff; grid-area: b; } .child3 { background-color: #8440f1; grid-area: c; } 注意：\n划分区域的方式的缺点就是每一个单元格都要去设置区域，不用的单元格也要用 . 表示，如果单元格很多，就比较麻烦。 网格线划分优先级要高于区域划分。 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为 区域名-start，终止网格线自动命名为 区域名-end。 隐形网格 # 加入网格容器划分了九个单元格，但是我们在网格容器中放置了超过 10 个或者更多的子元素，这时，浏览器会自动生成多余的网格，以便放置子元素。这种自动生成的网格就叫做隐形网格。\ngrid-auto-columns 和 grid-auto-rows 属性就是用来设置，浏览器自动创建的多余网格的列宽和行高。如果不指定这两个属性，浏览器根据单元格内容的大小，决定新增网格的列宽和行高。\n用法和 grid-template-columns、grid-template-rows 是一样的。\n网格单元中子元素的位置 # 在单元格中的子元素，如果没有设置宽高，那么会自动撑满整个单元格，如果设置了宽高，那么可以使用 justify-items 和 align-items 来设置子元素在单元格中的位置。justify-items 和 align-items 都是容器属性。\njustify-items：水平方向，可选值 start，end，center，strech。默认值是 strech。 align-items：垂直方向，可选值 start，end，center，strech。默认值是 strech。 容器设置了这两个属性后，所有单元格内的元素都会按照这个位置来排布。\n如果想要单独设置某个单元格的子元素，可以使用 justify-self 和 align-self。使用方法和 justify-items、align-items 一样。\nplace-self: {align-self} {justify-self} 是 justify-self 和 align-self 的复合属性。\n网格在容器中的位置 # justify-content、align-content 用来设置整个网格在容器中的排布，分别表示水平方向和垂直方向的排布。当整个网格没有撑满容器时，就可以使用这两个属性，可选值：\nstart：网格在起始边缘对齐。 end：网格在结束边缘对齐。 center：网格居中对齐。 strech：网格单元大小保持不变，网格单元的间隔拉伸，填满容器。 space-around：平均分布，每个网格单元的两侧的间隔相等。 space-between：平均分布，网格单元的之间的间隔相等，第一个单元贴近起始边缘，最后一个贴近结束边缘。 space-evenly：平均分布，间距一致。 inline-grid # display: inline-grid 和 display: grid 的唯一区别就是会把元素本身变为行内元素，元素内部的子元素仍然是网格元素。\n定位 # 可以设置元素具体在某个位置上。元素默认就是 static，也就是没有定位。\nrelative、absolute、fixed 这三个属性值有一个共同点，都是相对于某个基点的定位，只是基点不同。\n文档流 # 文档流（Normal Flow）简单说就是 HTML 元素的一种排布规则，元素默认是从上到下、从左到右依次排列（盒模型）。不同的布局模式，例如弹性布局或者网格布局，会有不同的排布规则。 不管是哪种文档流，本质都是对内部元素进行空间分配，元素与元素之间不产生重叠。\n脱离文档流 # 脱离文档流是指，元素会被文档流忽略，不分配空间。脱离文档流的元素可以理解为漂浮在文档流的上方。当一个元素脱离文档流后，文档流中的其他元素将忽略该元素并填补其原先的空间。\n脱离文档流的方法有浮动 float，绝对定位 position:absolute 和固定定位 position:fixed。\nstatic # static 表示浏览器会按照源码的顺序，决定每个元素的位置，每个块级元素占据自己的区块，元素与元素之间不产生重叠，这个位置就是元素的默认位置。\nstatic 定位的元素位置，是浏览器自主决定的，所以这时 left/right/top/bottom 这四个属性是无效的。\n相对定位 # position: relative：相对于默认位置（即 static 时的位置）进行偏移，虽然元素根据 left/right/top/bottom 这四个属性进行了偏移，但是在文档流中占据的位置是不变的。\ndiv { position: relative; top: 20px; } 上面的示例，div 元素从默认位置向下偏移 20px（即距离顶部 20px）。\n绝对定位 # position: absolute：相对于最接进自身并且设置了非 static 定位的父元素或者祖先元素（不是 static 的元素）。配合 left/right/top/bottom 属性使用。\n设置了绝对定位的元素，会脱离文档流，不会占据空间。正常的元素会顶上去。\n设置了绝对定位的元素的位置如何确定？\n没有设置定位偏移属性（left/right/top/bottom）的情况 要根据父元素的文档流模式来确定位置，例如 flex 布局：\n弹性容器设置了 justify-content: start;：\n弹性容器设置了 justify-content: end;：\n弹性容器设置了 justify-content: center;：\n设置了定位偏移属性的情况 元素的定位基点是设置了非 static 定位的最近的父元素或者祖先元素，如果没有非 static 定位的祖先元素，那么会以浏览器显示区域边界来进行定位。\n元素设置 position: absolute;bottom: 20px;left: 20px;：\n固定定位 # position: fixed：固定在浏览器窗口中的某个位置，相对于浏览器窗口定位。配合 left/right/top/bottom 属性使用。\n设置了固定定位的元素，会脱离文档流，不会占据空间。\n设置了固定定位的元素的位置如何确定？\n没有设置定位偏移属性（top、bottom、left、right）的情况下，和绝对定位的表现是一样的。 设置了定位偏移属性的情况下，元素的定位基点是浏览器的显示区域边界。无论页面如何滚动，元素的位置是固定不变的。 粘性定位 # sticky 的定位基点是设置了 overflow:scroll 的最近的祖先元素。如果没有就以浏览器显示区域边界来进行定位。\nsticky 定位不会脱离文档流。\nsticky 会产生动态效果，很像 relative 和 fixed 的结合。比如，网页的搜索工具栏，初始加载时，在自己的默认位置（relative 定位），页面向下滚动时，工具栏可以在距离浏览器相对应的位置固定住，始终停留在页面头部（fixed 定位）。等到页面重新向上滚动回到原位，工具栏也会回到默认位置。必须配合 left/right/top/bottom 属性使用。\n当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 sticky 元素的距离达到生效门槛，relative 定位自动切换为 fixed 定位；等到父元素完全脱离视口时（即完全不可见），fixed 定位自动切换回 relative 定位。sticky 元素这个时候也是不可见的。\n层 # 堆叠上下文 # 堆叠上下文就是一个独立的渲染层，里面的元素会按照自己的堆叠顺序进行渲染。\n页面的 \u0026lt;html\u0026gt; 元素是一个默认就有堆叠上下文的，所以被叫做根堆叠上下文。在根堆叠上下文中，元素是可以产生自己的堆叠上下文的。\n如何让一个元素产生堆叠上下文：\n默认情况下，元素的 position 不是 static，z-index 不是 auto，那么该元素就会产生堆叠上下文。 弹性（Flex）元素或者网格（Grid）元素，只要设置了 z-index 不是 auto，那么该元素就会产生堆叠上下文。 堆叠顺序 # 同一个堆叠上下文中，z-index 越大，元素的堆叠顺序越靠上。 同一个堆叠上下文中，z-index 相同，那么元素的堆叠顺序就按照元素在 DOM 中的先后顺序。 设置 z-index 只在元素所在的堆叠上下文中有效。一个堆叠上下文中子元素，无论设置的 z-index 是多少，都不会影响其他堆叠上下文的堆叠顺序。如下图：\n元素 A 产生了堆叠上下文，并且 z-index 为 1，元素 B 是 A 的子元素，z-index 为 20。但是元素 B 的是无法覆盖的元素 C 的。\n也就是说，任意元素的堆叠顺序是会被自己的祖先元素的堆叠上下文限制的，只有那些不存在祖先元素有堆叠上下文的元素，才能参与到根堆叠上下文的堆叠顺序中。所以碰到 z-index 层级高却无法覆盖层级低的元素，就要先去检查一下祖先元素是否有堆叠上下文，然后再设置 z-index。\n上图中，非 static 元素是介于 0 和 1 之间的，只要元素设置了 position 并且不是 static，那么元素就会跳到红色层级。\n"},{"id":4,"href":"/frontend-learn/docs/basic/html/04_animation/","title":"过渡和动画","section":"HTML 和 CSS","content":" 过渡和动画 # 页面中元素的变化，按照变化发起的逻辑可以分为触发型和自动型。\n让元素发生变化，有三种方式：\nCSS：适合简单的变化效果， CSS+JS：稍微复杂的变化效果，需要配合一下交互的 JS：类似在 canvas 元素上进行 2D 或者 3D 图像绘制的 元素变化的主要的属性：\n位置 尺寸 缩放，和尺寸类似，但是会带动元素整体，包裹内部元素进行缩放。 旋转 透明度 投影 颜色 边框 过渡效果 # 将状态从 A 变化到 B，中间的过程就可以用过渡的效果补齐。\n过渡属性的格式：transition: {过渡属性} {过渡时间} {过渡变化速度} {延迟时间}。多个属性 , 分隔。\n示例：\ntransition: background 2s：背景颜色变化 2 秒。 transition: background 2s,width 5s：背景颜色变化 2 秒，宽度变化 5 秒。 transition: background 2s 2s：背景颜色变化 2 秒，2 秒之后才开始变化。 transition: all：all 代表所有属性。 transition: all 5s linear：linear 表示线性变化速度。 transition 也可以分开设置：\ntransition-property：过渡属性。 transition-duration：过渡时间。 transition-timing-function：过渡缓动曲线。默认是 ease。 ease 先慢后快再慢， linear 线性。 ease-in 缓慢进。 ease-out 缓慢出。 cubic-bezier 自定义，贝塞尔曲线。可以使用一下工具来得到换动曲线： 浏览器开发者工具的 cubic-bezier 工具。 cubic-bezier easings steps，步数 transition-delay：过渡延迟时间。 steps # steps(count, start|end) 是一个特殊的时间函数，它和其他关键字 linear 等最大的区别就是，它不是一个连贯的变化，是一步一步的硬切换。\n例如 steps(3, start|end)，设置了 3 步，也就是会有 4 个状态，如下图：\n第一步切换由初始状态到过程状态1。 第二步由过程状态1到过程状态2。 第二步由过程状态2到目标状态。 整个变化过程分为了三个时间段，start 和 end 表示的转台切换是在时间段的开始还是时间段的结束。\n例如 steps(3, start)，就表示时间段一开始，就切换状态，以上图为例，第一个时间段一开始，直接从初始状态就切换到了过程状态1，然后等第一段时间走完，第二段时间开始，过程状态1直接切换到过程状态2，依次类推。\n如果是 steps(3, end)，就表示时间段结束，才切换状态，以上图为例，第一个时间段走完，才从初始状态切换到过程状态1，然后等第二段时间走完，过程状态1切换到过程状态2，依次类推。\nstep-start 等价于 steps(1, start)。 step-end 等价于 steps(1, end)。 steps 在动画效果中用的更多一点。\n动画效果 # 动画要先用 @keyframes 去定义好变化的过程，再去应用到某个元素。\n@keyframes {动画名称} 用来设置关键帧，动画的中间过程会被补全。\n只有两个状态时，使用 from 和 to，from 是动画开始时的状态，to 是动画结束时的状态。 多个状态时，使用百分比，0% 是动画开始时的状态，100% 是动画结束时的状态。更多中间状态用 10%，20%，25% 等。 定义好变化的过程，再用 animation 去应用到某个元素：animation 是一个复合属性，默认值 none 0 ease 0 1 normal none running。\nanimation 也可以分开设置：\nanimation-name：定义动画名称，要和 @keyframes 定义的名称一致。 animation-duration：动画时间。animation-duration 属性是必须的，否则时长为 0，就不会播放动画了。 animation-delay：延迟时间。 animation-timing-function：动画速度，默认是 ease。 ease 先慢后快。 linear 线性。 steps() 步数。 cubic-bezier() 自定义。可以在浏览器的 cubic-bezier 工具中修改。 animation-iteration-count 迭代次数，infinite 表示无限。 infinite 无限次。 n 表示 n 次。 animation-direction：方向，默认是 normal，alternate 表示往返动画。 normal 默认值，正常播放。 reverse 反向播放。 alternate 往返动画。 alternate-reverse 反向往返动画。 animation-fill-mode：最后填充模式，也就是动画结束时，要应用到元素的样式。默认值是 none。 none 不填充。动画播放完以后回到原始的样式。 forwards 应用动画结束时最后一帧的样式。 backwards 应用动画结束时第一帧的样式。 both 遵循 forwards 和 backwards 的规则，从而在两个方向上扩展动画属性。 animation-play-state：动画状态，默认值是 running。 running 正在播放。 paused 暂停。 示例：\n#div1 { /*3 次动画*/ animation-name: demo1; animation-duration: 2s; animation-timing-function: ease-in-out; /*animation: demo1 2s infinite alternate; 无限次的往返动画*/ } @keyframes demo1 { from { transform: translateX(0px); } to { transform: translateX(500px); } } @keyframes demo2 { 0% { transform: translateX(0px); background: red; } 20% { transform: translateX(500px); background: blue; } 70% { transform: translateX(500px); background: green; /* 时间函数是可以设置在单独的一段中，只会影响这一段的变化 */ animation-timing-function: linear; } 100% { transform: translateX(500px); background: yellow; } } 过渡和动画的区别 # 过渡的优点在于简单易用，但是它有几个很大的局限：\n需要事件触发，所以没法在网页加载时自动发生。 是一次性的，不能重复发生，除非一再触发。 只能定义两个状态，开始状态和结束状态，不能定义中间状态。 一条过渡规则，只能定义一个属性的变化，不能涉及多个属性。 动画通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果，可以解决过渡的不足。\n转换 # 2D 转换 # 2D 转换有 2 个轴, x，y。\n平移：transform: translate(x, y)，x 和 y 可以分开设置（transform: translateX(200px) transform: translateY(100px)） 旋转：transform: rotate(x)，transform: rotate(30deg) 顺时针旋转 30 度，负数就是逆时针旋转。 3D 转换 # 3D 转换实现 3D 立体效果，有 3 个轴, x，y，z。\n透视点：眼睛与屏幕之间的距离。perspective （perspective: 1000px）意思是距离屏幕 1000 像素点的距离（一般在 \u0026lt;body\u0026gt; 上设置透视点）。 透视点的位置默认是屏幕的正中央。 平移：transform: translate3d(x, y, z)，也可以分开设置，3D 比 2D 多了一个 translateZ(100px)。 旋转：transform: rotate3d(x, y,z, 30deg) 绕着 x，y，z 确定的轴旋转 30 度，rotateX(45deg) 绕着 X 轴旋转 45 度。rotateY() 绕着 Y 轴旋转。rotateZ() 绕着 Z 轴旋转。 放大和缩小： 放大：transform: scale(3) 放大 3 倍，transform: scale(0.5, 2) 表示水平缩小到 0.5 倍、垂直放大 2 倍。也可以分别设置 transform: scaleX(3) 水平放大 3 倍。scaleY 垂直缩放。 倾斜：transform: skew(15deg, 0deg) 基于 X 轴倾斜 15 度，Y 轴 0 度。值可以为负数。 transform-style: preserve-3d：可以渲染出一些在三维空间中的效果。 transform-origin：设置元素变换的中心点。 transform-box：变换中心点可设置的区域。 perspective-origin：可以修改透视点的位置，例如 perspective-origin: left buttom 将透视点的位置改为左下。 "},{"id":5,"href":"/frontend-learn/docs/basic/html/05_other/","title":"其他属性","section":"HTML 和 CSS","content":" 其他属性 # 渐变 # 线性渐变 # 线性渐变创建了一条沿直线前进的颜色带。MDN Web Docs (CSS gradients)\n示例：\n/* 基础线性渐变，只需指定两种颜色，这些被称为色标（color stop）*/ /* 从上到下，蓝色渐变到红色 */ linear-gradient(blue, red); /* 至少指定两个色标，也可以指定多个色标 */ linear-gradient(red, yellow, blue, orange); /* 默认情况下，线性渐变的方向是从上到下，可以指定一个值来改变渐变的方向 */ /* 从左到右、从蓝色渐变到红色 */ linear-gradient(to right, blue, pink); /* 从一个对角到另一个对角 */ linear-gradient(to left top, blue, red); linear-gradient(to bottom right, blue, pink); /* 设置渐变角度 */ /* 渐变轴为 45 度，从蓝色渐变到红色 */ linear-gradient(45deg, blue, red); /* 0deg 代表渐变方向为从下到上，90deg 代表渐变方向为从左到右，正角度都属于顺时针方向。负角度意味着逆时针方向。 */ linear-gradient(0deg, blue, green 40%, red); /* 透明度 */ linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 色标位置 */ /* 默认情况下，设置的颜色会均匀分布在渐变路径中 */ /* 可以设置百分比或者绝对长度来调整它们的位置 */ /* 如果没有明确设置，将会自动计算 */ /* 第一个色标在 0% 处，最后一个色标在 100% */ linear-gradient(to left, lime 28px, red 77%, cyan); linear-gradient(90deg, #19224A 0, #222E61 25%, #23346A 65%, #146693 90%, #088CB2); /* 重复线性渐变 */ repeating-linear-gradient(red, yellow 10%, green 20%); 径向渐变 # 径向渐变类似于线性渐变，除了是从一个中心点向外辐射的。你可以指定中心点的位置。你还可以使其为圆形或者是椭圆形。\n/* 基本的径向渐变 */ /* 默认情况下，渐变的中心点是 50% 50% 的位置 */ /* 椭圆 */ radial-gradient(red, blue); 滤镜属性 # -webkit-filter：滤镜属性。\nblur() 设置元素的模糊度，默认是 0px。 例如：-webkit-filter: blur(20px), blur() 中的值越大越模糊。 grayscale() 灰度，正常是 0%，也可以写数字。例如：-webkit-filter: grayscale(100%)。 sepia() 褐色，正常是 0% 可以写数字。例如：-webkit-filter: sepia(100%) 。 brightness() 亮度，正常亮度 100% 可以写数字，例如：-webkit-filter: brightness(100%) 。如果需要过度曝光的效果可以 brightness(500%)。 contrast() 对比度，正常是 100% 可以写数字，例如：-webkit-filter: contrast(1000%) 和 -webkit-filter: contrast(10) 是一个意思。 saturate() 饱和度，正常是 100% 可以写数字，例如：-webkit-filter: saturate(1000%)。 hue-rotate() 色相旋转，正常是 0deg 可以写数字，例如：-webkit-filter: hue-rotate(45deg)。 invert() 色相反转，底片效果，正常是 0 可以写数字，-webkit-filter: invert(100%)。 多个属性组合：-webkit-filter: blur(20px) brightness(100%)。\n滚动属性 # overflow 属性用于在内容超出容器时，如何处理内容的显示。\n容器必须有一个确定的高度或者宽度，overflow 才会生效。\noverflow 也可以分别设置 X 轴 overflow-x 和 Y 轴 overflow-y。\ndiv { overflow: hidden; /* overflow-x: hidden; overflow-y: hidden; */ } div { overflow: auto hidden; /* overflow-x: auto; overflow-y: hidden; */ } 常用的值：\nvisible：默认值，不会出现滚动条，溢出内容会直接显示在容器外部。 hidden：不会出现滚动条，溢出内容会被裁剪，超出容器的部分不可见。 scroll：显示滚动条，超出容器的内容，可以滚动滚动条来显示。 auto：和 scroll 基本一样。在内容有溢出时才显示滚动条，没有溢出则不显示滚动条。 overlay：和 auto 差不多，不同的是 auto 显示的滚动条会在容器内占据一个位置，会导致内容发生位移。overlay 则是会覆盖在容器右侧，不会占据位置 background-attachment # 滚动条的样式 # 主要涉及以下几个伪元素属性，-webkit 表示只对 webkit 内核浏览器有效。\n::-webkit-scrollbar：设置滚动条的整体样式，可以设置尺寸等。必须要设置宽高，否则不生效。 ::-webkit-scrollbar-button：滚动条两端的按钮（上下箭头）。不设置则不出现。 ::-webkit-scrollbar-thumb：滚动条上的滚动滑块。必须要设置，否则不会出现滑块。 ::-webkit-scrollbar-track：滚动条轨道。不设置则不出现轨道。 ::-webkit-scrollbar-track-piece：滚动条没有滑块的轨道部分。 ::-webkit-scrollbar-corner：当同时有垂直滚动条和水平滚动条时交汇的部分。通常是浏览器窗口的右下角。 示例：\n/* 滚动条所在容器 */ .scroll-container { margin: 10px; width: 200px; height: 250px; overflow: overlay; background-color: #fff; } /*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/ .scroll-container::-webkit-scrollbar { width:16px; height:16px; background-color:#F5F5F5; } /*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; } 伪类属性 # 滚动条的样式还可以搭配一些伪类属性来进行优化：\n:horizontal：适用于任何水平方向上的滚动条。 :vertical：适用于任何垂直方向的滚动条。\n/*定义滚动条轨道 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-track { -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3); border-radius:10px; background-color:#F5F5F5; \u0026amp;:horizontal { background-color: blue; } } /*定义滑块 内阴影+圆角*/ .scroll-container::-webkit-scrollbar-thumb { border-radius:10px; -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3); background-color:#555; \u0026amp;:vertical { background-color: red; } } 换行与溢出 # 相关属性：\nwhite-space：文本是否换行，空白符（换行符、空格、制表符等）的处理。 word-break，overflow-wrap：断句/断单词的换行处理，主要针对 non-CJK (CJK 指中文/日文/韩文) 的文本。 text-overflow：文字溢出的处理。 white-space # normal：默认值，文本中的连续空白符会被合并。根据填充的盒子宽度来决定换行。 nowrap：不换行，文本中的连续空白符会被合并。 pre：文本之间的空白符会被保留。只有遇到换行符或者 \u0026lt;br\u0026gt; 时才会换行。其行为方式类似 HTML 中的 \u0026lt;pre\u0026gt; 标签。 pre-wrap：换行，并且文本之间的空白符会被保留。遇到换行符或者 \u0026lt;br\u0026gt; 时换行，或者根据填充的盒子宽度来决定换行。 word-break # normal：默认值。 break-all：最常用的值，可在任意字符间断行，效果就是换行位置都会被填满，如果需要单词保持完整性，那就不要使用。 overflow-wrap # 和 word-break 一样也是用来截断单词的，不一样的是 overflow-wrap 侧重于处理超出元素宽度的单词。\nnormal：默认值。换行符将出现在空格和连字符处。 break-word：最常用的值。如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 text-overflow # 指定当文本溢出时，应该如何显示。可以设置溢出后，文本被剪切、显示省略号 (...) 或显示自定义字符串（不是所有浏览器都支持）。\nclip：剪切文本。 ellipsis：显示省略符号 ... 来代表被修剪的文本。 string：使用给定的字符串来代表被修剪的文本。 text-overflow 需要配合以下两个属性使用：\nwhite-space: nowrap; 不换行 overflow: hidden 不显示滚动条。 文本的水平对齐和垂直对齐 # 水平对齐 # text-align：默认值 left。 left：左对齐。 right：右对齐。 center：居中对齐。 justify：两端对齐。 start：如果内容方向是从左到右的话，左对齐。反之则右对齐。 end：如果内容方向是从左到右的话，右对齐，反之则左对齐。 只有块级元素内的文字或者行内元素才生效。\n垂直对齐 # 垂直对齐，是设置文字在一行内的空间中的垂直对齐。\nvertical-align：默认值 baseline。 baseline：默认值，基线对齐。 top：整行的顶部对齐。 middle：垂直居中。 bottom：整行的底部对齐。 text-top：与父元素的字体的顶部对齐。 text-bottom：与父元素的字体的底部对齐。 只有表格元素或者行内元素才生效。\nclientHeight、offsetHeight、scrollHeight # 每个元素都具有以和元素高度、滚动、位置相关的属性。这些属性通常用于计算元素的实际高度，尤其在涉及到滚动的情况下。\nclientWidth、clientHeight、clientLeft、clientTop # clientWidth：只读属性，表示元素的内部宽度，单位 px，包括 padding 但不包括 border margin 和垂直滚动条的宽度。对于 inline 的元素这个属性一直是 0。 clientHeight：只读属性，表示元素内容的高度，单位 px，包括 padding 但不包括 border margin 和水平滚动条的高度。对于 inline 的元素这个属性一直是 0。 clientLeft：只读属性，表示元素左边框的宽度，单位 px，不包括左外边距和左内边距。 clientTop：只读属性，表示元素顶部边框的宽度，单位 px，不包括顶部外边距或内边距。\noffsetWidth、offsetHeight、offsetLeft、offsetTop # offsetWidth：只读属性，表示元素的布局宽度，单位 px，包括 padding border margin 和垂直滚动条的宽度。 offsetHeight：只读属性，表示元素内容的高度，单位 px，包括 padding border margin 和水平滚动条的高度。 offsetLeft：只读属性，表示元素左上角相对于 offsetParent 左边界的偏移，单位 px，如果元素被隐藏则是 0。 offsetTop：只读属性，表示元素相对于 offsetParent 元素的顶部内边距的距离，单位 px，如果元素被隐藏则是 0。\nscrollWidth、scrollHeight、scrollLeft、scrollTop # scrollWidth：只读属性，表示元素内容的总宽度，包括由于溢出而被隐藏的部分。没有水平滚动条的情况下，scrollWidth 值与元素视图填充所有内容所需要的最小值 clientWidth 相同。 scrollHeight：只读属性，表示元素内容的总高度，包括由于溢出而被隐藏的部分。没有垂直滚动条的情况下，scrollHeight 的值与元素视图填充所有内容所需要的最小值 clientHeight 相同。 scrollLeft：可读可写，代表在有滚动条时，滚动条向右（向左）滚动的距离也就是元素左边（右边）被遮住部分的宽度。在没有滚动条时 scrollLeft = 0。 scrollTop：可读可写，代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时 scrollTop = 0。\n应用 # 判断是否有垂直滚动条 # 如果 scrollHeight = clientHeight 则表示没有垂直滚动条。\n判断是否有水平滚动条 # 如果 scrollWidth = clientWidth 则表示没有水平滚动条。\n判断滚动区域是否滚动到底 # scrollTop + clientHeight \u0026gt;= scrollHeigh，scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的，因此确定滚动区域是否滚动到底的唯一方法是查看滚动量是否足够接近某个阈值：\nMath.abs(element.scrollHeight - element.clientHeight - element.scrollTop) \u0026lt; 1 tabindex # tabindex 全局属性，表示元素是否可以被聚焦，以及是否能用 Tab 键选中。MDN Web Docs (tabindex)。\n支持聚焦的元素 # \u0026lt;button\u0026gt; 有 herf 属性的 \u0026lt;a\u0026gt; 有 herf 属性的 \u0026lt;link\u0026gt; type 不是 hidden 的 \u0026lt;input\u0026gt; \u0026lt;select\u0026gt; \u0026lt;textarea\u0026gt; 默认情况下，在使用 Tab 键聚焦元素时，聚焦顺序等于元素在源当前 DOM 中的先后顺序。\ntabindex 的值 # tabindex=负值 (例如 tabindex=\u0026quot;-1\u0026quot;)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用 JS 做页面小组件内部键盘导航的时候非常有用。 tabindex=\u0026quot;0\u0026quot;，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的 DOM 结构来决定的。 tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序是 tabindex 的数值越大顺序越靠后。如果多个元素拥有相同的 tabindex，它们的相对顺序按照他们在当前 DOM 中的先后顺序决定。tabindex=0 的顺序会被放到最后。 例如：1,1,2,2,2,2,3,4,5,0,0,0 ...。tabindex 是非法值、或者没有 tabindex 值的元素，也是放到最后。 div 默认情况下是不会被聚焦的，就可以添加属性 tabindex，让 div 元素可以被聚焦。如果在 div 上设置了 tabindex 属性，它的子元素内容不能使用箭头键来滚动，除非在内容上也设置 tabindex。\nuser-select # user-select：设置为本是否可以被选中。默认值 auto。 auto：可以被选中。 none：不能被选中。 "},{"id":6,"href":"/frontend-learn/docs/basic/html/06_selector/","title":"CSS 选择器","section":"HTML 和 CSS","content":" CSS 选择器 # 通用选择器，* 匹配任何元素。 标签选择器，匹配所有对应标签的元素。 类名选择器，匹配所有 class 属性中包含对应类名的元素。 ID 选择器，匹配 id 属性等于指定值的元素。 属性选择器 [attr]：存在某个属性，无论该属性有没有值 [attr=value]：属性等于特定值 [attr~=value]：属性具有多个空格分隔的值中的一个。例如一个元素具有属性 class=\u0026quot;btn btn-primary\u0026quot;，那么可以被 [class~=\u0026quot;btn\u0026quot;] 所匹配。 [attr|=value]：属性值是特定值或以 {值}- 开始。例如选择器 [title|=\u0026quot;hello\u0026quot;]： 一个元素具有属性 title=\u0026quot;hello\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello-1\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello1\u0026quot;，不可以匹配 [attr^=value]：属性值以特定值开始。例如选择器 [title^=\u0026quot;hello\u0026quot;]： 一个元素具有属性 title=\u0026quot;hello\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello-1\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello1\u0026quot;，可以匹配 [attr$=value]：属性值以特定值结束。例如选择器 [title$=\u0026quot;abc\u0026quot;]： 一个元素具有属性 title=\u0026quot;hello\u0026quot;，不可以匹配 一个元素具有属性 title=\u0026quot;hello-abc\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;helloabc\u0026quot;，可以匹配 [attr*=value]：属性值包含特定值。例如选择器 [title*=\u0026quot;abc\u0026quot;]： 一个元素具有属性 title=\u0026quot;heabcllo\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;hello-abc\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;helloabc\u0026quot;，可以匹配 一个元素具有属性 title=\u0026quot;abchello\u0026quot;，可以匹配 组合选择器 # 例如 h1.test[title*=\u0026quot;abc\u0026quot;]，这是一个组合选择器，表示含有 class=test 和符合 [title*=\u0026quot;abc\u0026quot;] 的 h1 标签。\n组合选择器的顺序是可以随意的，但是标签选择器因为没有特定的前缀符号，所以只能放在第一个，例如 .testh1 会被认为是 class=testh1。\n关系选择器 # 选择器 含义 示例 A B 后代选择器 div p { color: #f00; }、#nav li { display: inline; } A \u0026gt; B 直接子元素选择器 div \u0026gt; p { color: #f00; } A + B 相邻兄弟选择器，两个挨着的同级元素 div + p { color: #f00; } A ~ B 通用兄弟选择器，只要是同级的元素，不需要紧挨着 div ~ p { color: #f00; } 多元素选择器 # A,B 多元素选择器，同时匹配所有 A 元素或 B 元素，, 分隔。\n伪类选择器 # 伪类可以简单理解为是一种状态，条件，可以通过伪类选择器再配合一些其他选择器来选中页面当中已经存在的元素。\n常用的伪类选择器：\n链接伪类 link：普通的、未被访问的链接。 visited：用户已访问的链接。 用户行为伪类 :hover：鼠标指针位于其上。 :active：用户正在点击的元素。 :focus：元素获得焦点。 输入表单伪类 :enabled：用户可以编辑的元素。 :disabled：用户无法编辑的元素。 :checked：复选框或单选框被选中。 位置/结构伪类 :first-child：选择其父元素的第一个子元素。 :last-child：选择其父元素的最后一个子元素。 :only-child：选择其父元素的唯一子元素。也就是说这个父元素中只有一个子元素。 :only-of-type：选择其父元素中唯一的某个特定类型的元素。 :first-of-type：选择其父元素中第一个的某个特定类型的元素。与 :first-child 不同，:first-of-type 不关心元素是否是第一个子元素，关注的是是否为第一个该类型的子元素。 :last-of-type：选择其父元素中最后一个的某个特定类型的元素。 :nth-child：选择其父元素中第 n 个子元素。n 可以是一个数字，也可以是一个公式（例如 2n+1）。 :nth-last-child：选择其父元素中倒数第 n 个子元素。 :nth-of-type：选择其父元素中第 n 个特定类型的子元素。 :nth-last-of-type：选择其父元素中倒数第 n 个特定类型的子元素。 其他伪类 :root：根元素。 :empty：没有子元素的元素。 MDN Web Docs (Pseudo-classes)。\n状态伪类 # 状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的。\n状态伪类的顺序很重要，顺序错误可能会导致没有效果。\n例如为链接的不同状态设置样式时，必须按照以下次序规则：\na:hover 必须位于 a:link 和 a:visited 之后，a:active 必须位于 a:hover 之后。\n\u0026lt;!-- 设置四种状态的背景颜色 --\u0026gt; a:link { background-color:#B2FF99; } a:visited { background-color:#FFFF85; } a:hover { background-color:#FF704D; } a:active { background-color:#FF704D; } 结构化伪类 # 结构化伪类是 CSS3 新增的选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，可以减少 class 和 id 属性的定义，使文档结构更简洁。\n例如 :first-child 用来选择父元素的第一个子元素。\n/* 第一个子元素是 p 元素 */ p:first-child { color:blue; } /* 匹配的 p 元素中的第一个 i 元素 */ p \u0026gt; i:first-child { color:blue; } /* 第一个子元素是 p 元素的任意元素中的所有 i 元素 */ p:first-child i { color:blue; } 伪元素选择器 # 伪元素用于创建一些不在 DOM 树中的元素，‌并为其添加样式。‌虽然用户可以看到这些元素，但是这些文本实际上不在 DOM 树中。\n常用的伪元素选择器：\n::before，::after：在一个元素前或后插入一些内容，文字，图片等，‌并添加样式。 ::first-line，::first-letter：可以理解为把元素内的第一行文字或者第一个文字变成一个虚拟元素，‌并添加样式。 ::selection：为选中效果设置样式。 ::placeholder 最新的标准伪元素前面都是 ::，: 不再推荐使用。\nMDN Web Docs (Pseudo-elements)。\n伪元素不能被 JS 获取操控的。\n::before、::after # 可以在元素的内容前面或者后面插入新内容。content 属性是必须设置的，否则不会显示在页面中。可以设置为空字符串。\n/* 在每个 h1 元素前面插入一幅图片 */ h1::before { content:url(smiley.gif); } /* 在每个 h1 元素后面插入一幅图片 */ h1::after { content:url(smiley.gif); } /* 在每个 h1 元素后面插入字符 */ h1::after { content: \u0026#39;222\u0026#39;; } /* 可以为空，但是 content 必须在 */ h1::after { content: \u0026#39;\u0026#39;; } 默认情况下，::before、::after 伪元素都是行内元素，这是宽高是无效的，如果需要设置宽高，可以把元素改为块元素：\nh1::after { content: \u0026#39;222\u0026#39;; display: block; /*display: inline-block;*/ width: 100px; height: 100px; } 优先级 # 特指性等级 # 选择器 特指性等级 通用选择器，关系选择器（+、\u0026gt;、~），否定伪类（:not()） 0 标签选择器和伪元素 1 Class 选择器，属性选择器，伪类 2 ID 选择器 3 内联样式 4 !important 5 特指性等级数值越大，优先级越高。!important 是最高优先级。内联样式仅次于 !important。\n值计算 # 每一段 CSS 语句的选择器都可以对应一个具体的数值，数值越大优先级越高。\n一个 0 级选择器优先级数值 +0。 一个 1 级选择器优先级数值 +1。 一个 2 级选择器优先级数值 +10。 一个 3 级选择器优先级数值 +100。 示例：\n选择器 计算值 * 0 button 1 ul \u0026gt; li 1+0+1 a:not([target=\u0026quot;_blank\u0026quot;]) 1+0+10 #list .item p 100+10+1 "},{"id":7,"href":"/frontend-learn/docs/basic/html/07_responsive/","title":"响应式","section":"HTML 和 CSS","content":" 响应式 # 响应式的目的就是让页面在不同的设备，不同的尺寸上能够正常的合理的显示页面内容。\n使用固定尺寸的方式开发页面，就会碰到尺寸不同导致页面显示不完整等问题：\n电脑端浏览器的显示尺寸是可变的。 不同电脑的显示尺寸不同。 移动端设备屏幕小，尺寸多，浏览器的显示尺寸是固定的。 设备的交互方式不同，例如在电脑浏览器中的 :hover 在移动端是不存在的。 响应式的处理核心是基于浏览器的显示区域的宽度，然后来调整页面中元素的布局和尺寸。\n响应式处理，变化的主要是三个方面：\n元素尺寸 文字、图片 布局结构 交互方式 利用单位实现元素的逐步变化 # 实现元素尺寸的逐步变化，最常用的单位就是 % 和 vh、vw 等视窗单位。如果想要元素跟随父元素的尺寸逐步变化，那么可以使用 % 来实现。如果想要元素跟随视窗的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。\nvh 和 vw 相对于浏览器整个显示区域的尺寸，但是对于移动端设备，这个尺寸是包括地址栏和功能栏的。例如，一个元素设置了 100vh 的高度，在移动端浏览器中，元素的一部分是会被地址栏工具栏覆盖的。这个时候就可以使用移动端专用的视窗单位：\nlvh、lvw：l 表示 large。 svh、svw：s 表示 small。 dvh、dvw：d 表示 dynamic。 详细的使用方式：CSS 新 Viewport 视口单位 svh、lvh 和 dvh\n文字大小的逐步变化 # 文字大小的尺寸设置一般是用 px，em 和 rem，这三种单位都可以算是固定单位。因为 em 是相对于父元素的字体大小。rem 是相对于根元素（html 标签）的字体大小。也就是说如果父元素或者根元素的字体大小不变，那么利用 em 或 rem 设置尺寸的元素的内部元素的文字大小肯定也不会变化。\n如果想要文字的尺寸逐步变化，那么可以使用 vh、vw 等视窗单位来实现。\n通常，文字是不需要根据页面尺寸变化而变化的。\nFlex 布局和 Grid 布局中元素的逐步变化 # Flex 布局和 Grid 布局中的子元素都是可以缩放的。\nFlex 布局子元素的逐步变化主要是利用两个属性：\nflex-grow：默认值 0。占据剩余空间的份数。flex-grow: 1 就表示占据剩余空间的 1 份。 flex-shrink：默认值 1。当子元素的大小超过了主轴或者侧轴，那么设置了 flex-shrink 的子元素就会自动收缩。如果设置了换行，那么这个属性就没有用了。 Grid 布局子元素的逐步变化主要时在划分网格时，grid-template-columns 和 grid-template-rows 值的设定使用 fr % auto 等单位。\n媒体查询 # 媒体查询是 CSS3 中新增的特性，用于根据不同的设备类型，设置不同的样式。\n媒体查询最常用的媒体特征：\nmin-width：大于等于指定宽度。 max-width：小于等于指定宽度。 语法：\n@media not|only mediatype and (mediafeature and|or|not mediafeature) { CSS-Code; } mediatype 媒体类型：\nall：所有设备。 print：用于打印机和打印预览。 screen：用于电脑屏幕，平板电脑，智能手机等。。 speech：应用于屏幕阅读器等发声设备。 only 是为了兼容旧版本的浏览器，如果不写，默认就是 only。\n媒体查询 Level4 已经支持符号 \u0026lt;=，不支持 =\u0026gt;，这种语法更直观，但是由于比较新，老版本的浏览器可能不兼容：\n/* 等同于 @media (max-width: 480px) */ @media (width \u0026lt;= 480px) { } /* 等同于 @media (min-width: 640px) and (max-width: 1200px) */ @media (640px \u0026lt;= width \u0026lt;= 1200px) { h1 { color: #66bbff; } } mediafeature 媒体特征，必须使用 () 包裹起来。\n示例：\n/* 屏幕小于等于 640px 时，改变 h1 的颜色*/ @media screen and (max-width: 640px) { h1 { color: #0055bb; } } /* 屏幕大于等于 1200px 时，改变 h1 的颜色*/ @media screen and (min-width: 1200px) { h1 { color: #264D73; } } /* 屏幕大于等于 640px 并且小于等于 1200px 时，改变 h1 的颜色*/ /* 640px \u0026lt;= width \u0026lt;= 1200px */ @media screen and (min-width: 640px) and (max-width: 1200px) { h1 { color: #66bbff; } } 当多个媒体查询同时匹配时，会按照从上到下的顺序进行匹配。也就是说最后的才会生效。\n移动优先和桌面优先 # 媒体查询设置的 max-width 或者 min-max 这个宽度的分界点，称为断点。\n常用的断点：\n宽度 480px 一般是手机设备。 宽度 768px 主流平板设备的基本宽度。 宽度 1024px 主要是大尺寸平板设备，或者比较老的笔记本。 宽度 1280px 笔记本电脑。 宽度 1440px 台式机显示器。 一般选择三个断点就够了，通常是 480px、1024px、1440px。\n常用的断点设置的模式有两种，一种是移动优先，一种是桌面优先。\n移动优先 # 移动优先，基础 CSS 样式是为移动端设备编写的，然后使用媒体查询 min-width，逐步的为更大的设备添加样式。\n例如：\n.container { display: grid; grid-template-columns: 1fr; grid-template-rows: 100px; grid-auto-rows: 100px; width: 100%; gap: 10px; } @media (min-width: 480px) { .container { grid-template-columns: 1fr 1fr; } } @media (min-width: 1024px) { .container { grid-template-columns: 1fr 1fr 1fr; } } @media (min-width: 1440px) { .container { grid-template-columns: 1fr 1fr 1fr 1fr; } } 桌面优先 # 桌面优先，基础 CSS 样式是为桌面电脑编写的，然后使用媒体查询 max-width，逐步的为更小的设备添加样式。\n例如：\n.container { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 100px; grid-auto-rows: 100px; width: 100%; gap: 10px; } @media (max-width: 1440px) { .container { grid-template-columns: 1fr 1fr 1fr; } } @media (max-width: 1024px) { .container { grid-template-columns: 1fr 1fr; } } @media (max-width: 480px) { .container { grid-template-columns: 1fr; } } 媒体查询的引入方式 # 通常会把媒体查询的样式 @media 放到单独的 CSS 文件中（queries.css），然后在需要使用媒体查询的地方，使用导入 CSS 文件。\n还可以在 style 标签上使用 media 属性引入媒体查询的 CSS 文件，例如：\n\u0026lt;style media=\u0026#34;(min-device-width: 300px) and (max-device-width: 500px)\u0026#34;\u0026gt; .box { width: 100px; height: 100px; background-color: cadetblue; } \u0026lt;/style\u0026gt; 还有一种方式是在 link 标签上使用 media 属性引入媒体查询的 CSS 文件，例如：\n\u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style1.css\u0026#34; media=\u0026#34;(min-device-width: 300px) and (max-device-width: 500px)\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; 最后，使用 @import 属性引入媒体查询的 CSS 文件，例如：\n@import url=\u0026#34;./queries.css\u0026#34; screen and (max-width: 500px); 容器查询 # 容器查询是一种 CSS 特性，主要根据元素所在的容器父元素的大小来设置样式，而不是整个视窗。\n容器查询包含 container-type、container-name 和 container 三个属性。container 是 container-type 和 container-name 的简写属性。\n例如，定义一个容器：\n.parent { background-color: blueviolet; height: 300px; width: 50vw; container-type: size; } .child { background-color: aqua; width: 100%; height: 100px; } @container (min-width: 320px) { .child { background-color: red; } } 上面的示例，@container 是如何知道要查询哪个容器？\n就是声明了 container-type 这个属性，就意味着告诉浏览器，在该元素上创建一个容器上下文，之后可能要查询此容器。\ncontainer-type 属性有三个可选值：\nnormal：默认值。 size：表示容器查询时，既可以查询高度，也可以查询宽度（@container (max-height: 800px) and (max-width: 800px)） inline-size：表示容器查询时，只能查询文字书向的尺寸，通常元素内部的文字都是水平方向书写的，也就是查询宽度。可以使用 writing-mode 修改文字的书写方向。 container-name 用来指定当前容器所对应的容器查询的名称。例如：\n.parent { background-color: blueviolet; height: 300px; width: 50vw; container-type: size; container-name: my-container; } /* 指定查询名称为 my-container 的容器 */ @container my-container (max-width: 800px) {} 这两个属性组合起来，例如：\n.parent { container: size / my-container; /* * 等价于 * container-type: size; * container-name: my-container; */ } 容器查询的单位 # cqw：容器查询宽度（Container Query Width）占比。1cqw 等于容器宽度的 1%。例如容器宽度是 1000px，则此时 1cqw 对应的计算值就是 10px。 cqh：容器查询高度（Container Query Height）占比。1cqh 等于容器高度的 1%。 cqi：表示容器查询文字书写方向的尺寸（Container Query Inline-Size）占比。这个是逻辑属性单位，默认情况下等同于 cqw。 cqb：容器查询垂直于文字书写方向尺寸（Container Query Block-Size）占比。同上，默认情况下等同于 cqh。 cqmin：容器查询较小尺寸的（Container Query Min）占比。取 cqw 和 cqh 中较小的一个。 cqmax：表示容器查询较大尺寸的（Container Query Min）占比。取 cqw 和 cqh 中较大的一个。\n图片的处理 # 图片在做响应式处理时，是比较特殊的。图片一般分两类，矢量图（svg）和位图（jpg、png、gif 等）。矢量图不管放大还是缩小都不会影响显示的。但是位图随着放大超过自身的分辨率，是会变的模糊的。\n所以对于位图，一般会使用 @media 媒体查询来处理。对于不同显示尺寸，准备不同分辨率的图片。\n为什么不准备一个高分辨率的图片，而是准备多个分辨率的图片？\n对于显示尺寸较小的设备，加载大分辨率的图片，图片可能几兆甚至十几兆，这会导致页面加载速度变慢，并且客户端访问时会去服务器下载，耗费大量的服务器带宽。\n如何准备不同分辨率的图片 # 如果一个图片在页面上展示的尺寸是 400px*300px，那么根据屏幕的 DPR 来计算实际需要的图片的分辨率。\n如果屏幕的 DPR 是 1，那么需要的图片分辨率就是 400px*300px。如果屏幕的 DPR 是 2，那么需要的图片分辨率就是 800px*600px。\n需要展示的尺寸（逻辑像素）* 屏幕 DPR =\u0026gt; 需要的图片原始分辨率 图片响应式处理 # 图片响应式处理主要有四种方式\nimg 标签 # \u0026lt;img\u0026gt; 标签引入了 srcset 属性，srcset 属性用来指定多张图片，适应不同像素密度的屏幕。\n示例：\n\u0026lt;img src=\u0026#34;small-640.jpg\u0026#34; srcset=\u0026#34; small-640.jpg 640w, medium-1280.jpg 1280w, large-1920.jpg 1920w\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; 上面的示例 srcset 属性给出了三个图片 URL，适应三种不同的像素密度。图片 URL 空格后面的是像素密度描述符或者宽度描述符（如 640w，w 表示 width。）。\n像素密度描述符，格式是像素密度倍数（DPR） + 字母x。1x 表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度（DPR），选择需要加载的图片。\n如果 srcset 属性中的图片都不满足条件，那么就加载 src 属性指定的默认图片。\n像素密度的适配，是根据整个屏幕的宽度来计算的，这样可能会导致实际使用的图片分辨率会比需要的分辨率大很多。例如：\n\u0026lt;img src=\u0026#34;small-640.jpg\u0026#34; srcset=\u0026#34; small-640.jpg 640w, medium-1280.jpg 1280w, large-1920.jpg 1920w\u0026#34; style=\u0026#34;width: 50%\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; 图片设置了宽度为 50%，实际使用的图片分辨率会大很多。这时就需要使用 sizes 属性。\nsizes 属性列出不同设备的图片显示宽度.\nsizes 属性的值是一个逗号 , 分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图片的显示宽度。\n\u0026lt;img srcset=\u0026#34;foo-160.jpg 160w, foo-320.jpg 320w, foo-640.jpg 640w, foo-1280.jpg 1280w\u0026#34; sizes=\u0026#34;(max-width: 440px) 100vw, (max-width: 900px) 33vw, 254px\u0026#34; src=\u0026#34;foo-1280.jpg\u0026#34;\u0026gt; sizes 属性给出了三种屏幕条件，以及对应的图片显示宽度。宽度不超过 440px 的设备，图片显示宽度为 100%；宽度 441px 到 900px 的设备，图片显示宽度为 33%；宽度 900px 以上的设备，图片显示宽度为 254px。\n浏览器根据当前设备的宽度，从 sizes 属性获得图片的显示宽度，然后从 srcset 属性找出最接近该宽度的图片，进行加载。\n例如当前设备的屏幕宽度是 480px，浏览器从 sizes 属性查询得到，图片的显示宽度是 33vw（即 33%），等于 160px。srcset 属性里面，正好有宽度等于 160px 的图片，于是加载 foo-160.jpg。\npicture、source、img 标签组合 # 如果要同时考虑屏幕尺寸和像素密度的适配，就要用到 \u0026lt;picture\u0026gt; 标签。\n\u0026lt;picture\u0026gt; \u0026lt;source srcset=\u0026#34;homepage-person@desktop.png, homepage-person@desktop-2x.png 2x\u0026#34; media=\u0026#34;(min-width: 990px)\u0026#34;\u0026gt; \u0026lt;source srcset=\u0026#34;homepage-person@tablet.png, homepage-person@tablet-2x.png 2x\u0026#34; media=\u0026#34;(min-width: 750px)\u0026#34;\u0026gt; \u0026lt;img srcset=\u0026#34;homepage-person@mobile.png, homepage-person@mobile-2x.png 2x\u0026#34; alt=\u0026#34;Shopify Merchant, Corrine Anestopoulos\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 浏览器按照 \u0026lt;source\u0026gt; 标签出现的顺序，依次判断当前设备是否满足 media 属性的媒体查询表达式，如果满足就加载 srcset 属性指定的图片文件，并且不再执行后面的 \u0026lt;source\u0026gt; 标签和 \u0026lt;img\u0026gt; 标签。\n\u0026lt;img\u0026gt; 标签是默认情况下加载的图片，用来满足上面所有 \u0026lt;source\u0026gt; 都不匹配的情况。\n\u0026lt;picture\u0026gt; 标签还可以用来选择不同格式的图片。比如，如果当前浏览器支持 Webp 格式，就加载这种格式的图片，否则加载 PNG 图片。\n\u0026lt;picture\u0026gt; \u0026lt;source type=\u0026#34;image/svg+xml\u0026#34; srcset=\u0026#34;logo.xml\u0026#34;\u0026gt; \u0026lt;source type=\u0026#34;image/webp\u0026#34; srcset=\u0026#34;logo.webp\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;logo.png\u0026#34; alt=\u0026#34;ACME Corp\u0026#34;\u0026gt; \u0026lt;/picture\u0026gt; 浏览器按照 \u0026lt;source\u0026gt; 标签出现的顺序，依次检查是否支持 type 属性指定的图片格式，如果支持就加载图片，并且不再检查后面的 \u0026lt;source\u0026gt; 标签了。\nCSS # CSS 媒体查询，CSS 样式只针对背景图片。\n移动端响应式 # 声明视窗的大小：\u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\u0026quot;\u0026gt;\nviewport 声明视窗。只适用于移动端。 width=device-width 宽度等于设备宽度。 initial-scale=1 初始化比例是 1。 minimum-scale=1 最小的缩小比例是 1。 maximum-scale=1 最大的放大比例是 1。 user-scalable=no 用户不允许缩放。 物理分辨率和逻辑分辨率 # 屏幕的发展，最初是以像素为单位，像素越多，屏幕尺寸也越大，这是一种物理性的变大。但是物理的变大时有限制的，不能过大，所以后来出现了在同样尺寸下放入更多的像素的技术，例如苹果的 Retina 显示屏（高倍屏），5K 的显示屏分辨率是 5120*2880，而普通屏幕的在同样的尺寸下分辨率是 2560*1440。\n如果我们用高倍屏去显示内容，那么就会出现一个问题，就是内容会变小。\n例如下图，如果按照 1:1 的比例去显示，在普通屏幕上占 6 个像素的图片，放到高倍屏还是占据 6 个像素，按照这个逻辑，同样的内容，在高倍屏上显示差不多就是 1/4。\n那么这显然是不合理的，所以操作系统层面就出现了逻辑分辨率，就是一个虚拟的分辨率。对应屏幕的物理分辨率。逻辑分辨率就是为了让高倍屏和普通屏在显示内容时能显示出一样的大小。\n如下图，如果一张图片占 6 个像素，那么在高倍屏时，操作系统会根据高倍屏的逻辑分辨率，把这张图片放大到 24 个像素，这样就不会出现内容变小的情况。\n设备像素比就是逻辑分辨率的宽度（高度）除以物理分辨率的宽度（高度）。对于移动端设备，设备像素比可能更高。设备像素比可以在浏览器的控制台查看，输入 devicePixelRatio 回车即可。\n移动端适配 # 不同的移动端设备分辨率，尺寸都不同，可以先针对一种设备，以 iphone6 为例，设计好页面的样式之后，设置 content=\u0026quot;width=375,user-scalable=no\u0026quot;，禁止用户缩放，指定宽度为 iphone6 的宽度，那么不同分辨率的设备（移动端）都会自适应这个宽度。\n"},{"id":8,"href":"/frontend-learn/docs/basic/html/08_chrome/","title":"Chrome 开发者工具","section":"HTML 和 CSS","content":" Chrome 开发者工具 # Chrome 的开发者工具查看元素的样式如下图：\n右侧样式的排序，选择器的优先级高的会在上面。\nuse agent stylesheet 是浏览器给元素的默认样式。 :hov 给元素强制加上某种伪类，使元素显示对应的样式。 :cls 给元素添加 class 切换页面的深色模式：\nComputed 包含盒子模型和元素最终显示出来的样式的值。\n如果在修改一些元素的样式，发现不生效时，就可以在列表中，点击对应属性。它会把这个属性相关的所有设置都列出来。列表中的第一个就是最终生效的那个，下面的就是被覆盖的。\n上面的盒子模型的值都是可以修改的。\nDevice ToolBar # 1：切换移动端模式。 2：添加更多的移动端设备，并且可以添加自定义尺寸的设备。 3：选择自适应模式，设备尺寸可以任意调整。 4：缩放。 5：节流模式，可以模拟网速的快慢，无网络等状态。 6：旋转，模拟屏幕旋转。 媒体查询 # 打开媒体查询工具：\n打开之后，尺寸下面多了一栏，鼠标悬浮上去会显示，当前的宽度是什么设备的尺寸。\n如果设置了媒体查询，会出现对应的一行，鼠标悬浮上去会显示匹配的规则。\n上图中有三条媒体查询的规则：\n.parent { width: 50vh; height: 50vh; background-color: aqua; } @media (min-width: 600px) { .parent { background-color: blueviolet; } } @media (max-width: 1000px) { .parent { background-color: blueviolet; } } @media (min-width: 600px) and (max-width: 1000px) { .parent { background-color:burlywood; } } 当多个媒体查询同时匹配时，会按照从上到下的顺序进行匹配。也就是说最后的才会生效。\n"}]